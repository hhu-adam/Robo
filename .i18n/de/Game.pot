msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Thu Aug 29 19:12:17 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: de\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! ğŸ‰"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsâ€¦ ğŸ­"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ğŸ‰"
msgstr ""

#: Game.Doc.Definition
msgid "Eine Funktion `f` is injektiv wenn:\n"
"\n"
"```\n"
"âˆ€ a b, f a = f b â†’ a = b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "Eine Funktion `f` is surjektiv wenn:\n"
"\n"
"```\n"
"âˆ€ b, âˆƒ a, f a = b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "Eine Funktion `f` is bijectiv wenn sie injektiv und surjektiv ist."
msgstr ""

#: Game.Doc.Definition
msgid "`f` ist strikt monoton wenn\n"
"\n"
"```\n"
"âˆ€ a b, a < b â†’ f a < f b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "Anonyme Funktionen kann man mit `fun (x : â„¤) => 2 * x` definieren und\n"
"wie andere Objekte verwenden.\n"
"\n"
"Note: `=>` wird in mathlib oft auch `â†¦` (`\\\\maps`) geschrieben."
msgstr ""

#: Game.Doc.Definition
msgid "`A âˆ§ B` (\"und\") ist die Aussage dass sowohl `A` als auch `B` wahr ist."
msgstr ""

#: Game.Doc.Definition
msgid "* FÃ¼r `A B : Prop` ist `A â†’ B` eine Implikation \"`A` impliziert `B`\"\n"
"* FÃ¼r andere `X Y : Type` ist `X â†’ Y` eine Funktion, die Werte aus `X` nach `Y` abbildet,\n"
"  z.B. `f : â„• â†’ â„¤ := n â†¦ -n`."
msgstr ""

#: Game.Doc.Definition
msgid "NÃ¼tzliche Taktiken fÃ¼r Gleicheit sind: `rfl`, `rw`, `trans`"
msgstr ""

#: Game.Doc.Definition
msgid "Die Aussage `False : Prop` ist nie wahr.\n"
"\n"
"Lean benÃ¼tzt diese intern fÃ¼r WidersprÃ¼che, ein Widerspruch ist ein Beweis `(hF : False)` von\n"
"`False` und z.B. `Â¬ A` ist als `A â†’ False` implementiert."
msgstr ""

#: Game.Doc.Definition
msgid "Genau-dann-wenn (if-and-only-if). Can meistens mit `constructor` oder `obtain âŸ¨fwd, bwdâŸ© := h`\n"
"in Einzelteile zerlegt werden.\n"
"\n"
"Bei einer Annahme `h : A â†” B`, heissen die Einzelteile zudem `h.mp : A â†’ B` und `h.mpr : B â†’ A`."
msgstr ""

#: Game.Doc.Definition
msgid "Ungleichheit `x â‰  y` ist definiert als `x = y â†’ False`."
msgstr ""

#: Game.Doc.Definition
msgid "`Â¬ A` ist intern als `A â†’ False` implementiert.\n"
"\n"
"NÃ¼tliche Tactiken sind: `push_neg`, `by_contra`, `contrapose`."
msgstr ""

#: Game.Doc.Definition
msgid "`A âˆ¨ B` (\"oder\") ist die Aussage mindestens eine der Aussagen `A`, `B` wahr ist."
msgstr ""

#: Game.Doc.Definition
msgid "`(A : Prop)` ist eine beliebige Aussage, ohne weitere Angabe, ob diese wahr, falsch oder\n"
"nicht beweisbar ist.\n"
"\n"
"Siehe auch `(True : Prop)` und `(False : Prop)` die uneingeschrÃ¤nkt wahre (rsp. falsche)\n"
"Aussage."
msgstr ""

#: Game.Doc.Definition
msgid "Die Aussage `True : Prop` ist immer wahr."
msgstr ""

#: Game.Doc.Tactic
msgid "Sind eine Annahme `h : A` und eine Implikation `hAB : A â†’ B` gegeben, so\n"
"verwandelt `apply hAB at h` die gegebene Annahme in die Annahme `h : B`.\n"
"Ist `B` unser Beweisziel, kÃ¶nnen wir mit `apply hAB` auch rÃ¼ckwÃ¤rts argumentieren und\n"
"erhalten `A` als neues Beweisziel.   In beiden FÃ¤llen kann die Implikation `hAB` wahlweise\n"
"als Annahme gegeben oder ein bereits bekanntes Lemma sein.\n"
"\n"
"\n"
"## Beispiel\n"
"\n"
"Gegeben sei fÃ¼r `n : â„•` folgendes Lemma:\n"
"```\n"
"lemma lem (h : n â‰¤ 0) : n = 0\n"
"```\n"
"\n"
"Finden wir nun als Beweisziel\n"
"\n"
"```\n"
"Goal\n"
"  n = 0\n"
"```\n"
"\n"
"vor, so Ã¤ndert `apply lem` das Beweisziel zu `n â‰¤ 0`.\n"
"\n"
"Anders herum, falls wir eine Annahme `g : m â‰¤ 0` in unseren Annahmen finden, kÃ¶nnen wir\n"
"diese mit `apply lem at g` zu `g : m = 0` umwandeln.\n"
"\n"
"(Das Lemma ist gemeinhin als `Nat.eq_zero_of_le_zero` bekannt.)"
msgstr ""

#: Game.Doc.Tactic
msgid "`assumption` sucht nach einer Annahme, die genau dem Goal entspricht.\n"
"\n"
"## Beispiel\n"
"\n"
"`assumption` sucht durch die Annahmen und merkt dass `h` genau mit dem Goal Ã¼bereinstimmt.\n"
"\n"
"```\n"
"Objekte\n"
"  a b c d : â„•\n"
"  h : a + b = c\n"
"  g : a * b = 16\n"
"  t : c = 12\n"
"Goal\n"
"  a + b = c\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`by_cases h : P` macht eine Fallunterscheidung. Im ersten Goal wird eine Annahme\n"
"`(h : P)` hinzugefÃ¼gt, im zweiten `(h : Â¬P)`.\n"
"\n"
"## Details\n"
"\n"
"`P` kann eine beliegige Aussage sein, die als entweder wahr oder falsch angenommen wird.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"example (A : Prop) : A âˆ¨ Â¬ A := by\n"
"  by_cases h : A\n"
"  Â· left\n"
"    assumption\n"
"  Â· right\n"
"    assumption\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`by_contra h` startet einen Widerspruchsbeweis.\n"
"\n"
"## Details\n"
"Sei `P` das aktuelle Goal. `by_contra h` fÃ¼gt eine neue Annahme `(h : Â¬P)` hinzu\n"
"und setzt das Goal auf `False`.\n"
"\n"
"Oft will man `by_contra` nutzen wenn das Goal von der Form `Â¬ P` ist.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `contradiction` schliesst den Widerspruchsbeweis wenn sich (zwei) Annahmen\n"
"widersprechen.\n"
"* `contrapose` fÃ¼hrt einen Beweis durch Kontraposition und ist entsprechend\n"
"in Ã¤hnlichen Situationen nutzbar wie `by_contra`"
msgstr ""

#: Game.Doc.Tactic
msgid "`change t` Ã¤ndert das Goal zu `t`. Voraussetzung ist, dass `t` und das alte Goal defEq sind.\n"
"\n"
"## Details\n"
"\n"
"Dies ist insbesonder hilfreich wenn eine Taktik nicht merkt, dass das Goal defEq ist zu einem\n"
"Term, der eigentlich gebraucht wÃ¼rde.\n"
"\n"
"## Beispiel\n"
"\n"
"Aktuelles Goal:\n"
"\n"
"```\n"
"b: â„\n"
"âŠ¢ 1 â€¢ b = b\n"
"```\n"
"Wobei die Skalarmultiplikation als `fun (a : â„š) (r : â„) => â†‘a * r` definiert war. Dann\n"
"kann man mit `change (1 : â„š) * b = b` das Goal umschreiben und anschliessend mit Lemmas\n"
"Ã¼ber die Multiplikation beweisen."
msgstr ""

#: Game.Doc.Tactic
msgid "`constructor` teilt ein Beweisziel, das eine Struktur ist, in seine Bestandteile auf.\n"
"\n"
"## Detail\n"
"\n"
"Ãœbliche AnwendungsfÃ¤lle sind Beweisziele der Form `A âˆ§ B` sowie Ã„quivalenzen, also Beweisziele der Form `A â†” B`.\n"
"Im ersten Fall ersetzt `constructor` das Ziel `A âˆ§ B` durch die zwei Ziel `A` and `B`, im zweiten Fall ersetzt `constructor` die Ã„quivalenz durch die beiden Beweisziele `A â†’ B` and `B â†’ A`.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* Das Gegenteil von `constructor` ist `âŸ¨_, _âŸ©` (`\\\\<>`), der *anonyme Konstruktor*.\n"
"Dieser enspricht ungefÃ¤hr der Tupel-Notation in\n"
"\\\"eine Gruppe ist ein Tupel $(G, 0, +)$, sodass â€¦\\\".\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"example {A B : Prop} (h : A) (g : B) : A âˆ§ B := by\n"
"  constructor\n"
"  Â· assumption\n"
"  Â· assumption\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`contradiction` schliesst den Beweis wenn es einen Widerspruch in den Annahmen findet.\n"
"\n"
"## Details\n"
"\n"
"Ein Widerspruch in den Annahmen kann unter anderem folgendermaÃŸen aussehen:\n"
"\n"
"* `(h : n â‰  n)`\n"
"* `(h : A)` und `(h' : Â¬A)`\n"
"* `(h : False)` (i.e. ein Beweis von `False`)\n"
"\n"
"## Beispiel\n"
"\n"
"Folgenes Goal wird von `contradiction` bewiesen\n"
"\n"
"```\n"
"Objekte:\n"
"  (n m : â„•)\n"
"  (h : n = m)\n"
"  (g : n â‰  m)\n"
"Goal\n"
"  37 = 60\n"
"```\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* Normalerweise wird `contradiction` gebraucht um einen Widerspruchsbeweis zu\n"
"  schliessen, der mit `by_contra` erÃ¶ffnet wurde.\n"
"* Ein Beweis von `False` representiert in Lean einen Widerspruch.\n"
"  nach dem Motto \\\"ein Widerspruch beweist alles.\\\""
msgstr ""

#: Game.Doc.Tactic
msgid "`contrapose` Ã¤ndert ein Goal der Form `A â†’ B` zu `Â¬B â†’ Â¬A` und fÃ¼hrt damit\n"
"eine Beweis durch Kontraposition.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `revert h` kann nÃ¼tzlich sein um eine Annahme als ImplikationsprÃ¤misse zu schreiben bevor man\n"
"  `contrapose` verwendet."
msgstr ""

#: Game.Doc.Tactic
msgid "`exact h` schliesst das Goal wenn der Term `h` mit dem Goal Ã¼bereinstimmt."
msgstr ""

#: Game.Doc.Tactic
msgid "`fin_cases i` fÃ¼hrt eine Fallunterscheidung wenn `i` ein endlicher Typ ist.\n"
"\n"
"## Details\n"
"`fin_cases i` ist insbesondere nÃ¼tzlich fÃ¼r `(i : Fin n)`, zum Beispiel als Index in\n"
"endlich dimensionalen VektorrÃ¤umen.\n"
"\n"
"In diesem Fall bewirkt `fin_cases i` dass man Komponentenweise arbeitet."
msgstr ""

#: Game.Doc.Tactic
msgid "`funext x` wird bei Gleichungen von Funktionen `f = g` gebraucht. Das Goal wird zu\n"
"`f x = g x`.\n"
"\n"
"## Details\n"
"Nach dem Motto `f = g â†” âˆ€ x, f x = g x` sind zwei Funktionen dann identisch, wenn sie\n"
"angewendet auf jedes Element identisch sind. `funext x` benutzt dieses Argument."
msgstr ""

#: Game.Doc.Tactic
msgid "`have h : P` fÃ¼hrt ein Zwischenresultat ein.\n"
"\n"
"## Details\n"
"Anschliessend muss man zuerst dieses Zwischenresultat beweisen bevor man mit dem Beweis\n"
"weitermachen und das Zwischenresultat verwenden kann.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `suffices h : P` funktioniert genau gleich, auÃŸer dass die beiden entstehenden Beweise\n"
"  vertauscht sind.\n"
"* `let h : Prop := A âˆ§ B` ist verwandt mit `have`, mit Unterschied, dass man mit `let`\n"
"  eine temporÃ¤re Definition einfÃ¼hrt."
msgstr ""

#: Game.Doc.Tactic
msgid "`induction n` fÃ¼hrt einen Induktionsbeweis Ã¼ber `n`.\n"
"\n"
"## Detail\n"
"\n"
"Diese Taktik erstellt zwei Goals:\n"
"* Induktionsanfang, wo `n = 0` ersetzt wird.\n"
"* Induktionsschritt, in dem man die Induktionshypothese `n_ih` zur VerfÃ¼gung hat.\n"
"\n"
"## Modifikationen in diesem Spiel\n"
"\n"
"* `induction n with d hd` benennt Induktionsvariable und -hypothese. (das ist Lean3-Syntax)\n"
"und funktioniert auÃŸerhalb vom Spiel nicht genau so.\n"
"* AuÃŸerhalb des Spiels kriegst du `Nat.zero` und `Nat.succ n` anstatt `0` und `n + 1`\n"
"als FÃ¤lle. Diese\n"
"Terme sind DefEq, aber manchmal benÃ¶tigt man die lemmas `zero_eq` und `Nat.succ_eq_add_one`\n"
"um zwischen den schreibweisen zu wechseln\n"
"\n"
"Der richtige Lean4-Syntax fÃ¼r `with` streckt sich Ã¼ber mehrere Zeilen und ist:\n"
"\n"
"```\n"
"induction n with\n"
"| zero =>\n"
"  sorry\n"
"| succ m m_ih =>\n"
"  sorry\n"
"```\n"
"\n"
"da dieser sich Ã¼ber mehrere Zeilen erstreckt wird er im Spiel nicht eingefÃ¼hrt.\n"
"\n"
"## Hifreiche Resultate\n"
"\n"
"* `Nat.succ_eq_add_one`: schreibt `n.succ = n + 1` um.\n"
"* `Nat.zero_eq`: schreibt `Nat.zero = 0` um.\n"
"\n"
"Beide sind DefEq, aber manche Taktiken kÃ¶nnen nicht damit umgehen\n"
"\n"
"* Siehe Definition `âˆ‘` fÃ¼r Hilfe mit Induktion Ã¼ber Summen.\n"
"* `obtain âŸ¨âŸ© := n` ist sehr Ã¤hnlich zu `induction n`. Der Unterschied ist, dass bei\n"
"`obtain` keine Induktionshypothese im Fall `n + 1` zur VerfÃ¼gung steht.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"example (n : â„•) : 4 âˆ£ 5^n + 7 := by\n"
"  induction n\n"
"  sorry      -- Fall `n = 0`\n"
"  sorry      -- Fall `n + 1`\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`intro x` wird fÃ¼r Goals der Form `A â†’ B` oder `âˆ€ x, P x` verwendet.\n"
"Dadurch wird die ImplikationsprÃ¤misse (oder das Objekt `x`) den Annahmen hinzugefÃ¼gt.\n"
"\n"
"## Beispiele\n"
"\n"
"```\n"
"Goal:\n"
"  âˆ€ (m n : â„•), n â‰¤ m âˆ¨ m â‰¤ n\n"
"```\n"
"\n"
"die Taktik `intro a n` fÃ¼hrt 2 Variablen ein und gibt diesen die Namen `a` und `n`:\n"
"\n"
"```\n"
"Objekte:\n"
"  a n : â„•\n"
"Goal:\n"
"  n â‰¤ a âˆ¨ a â‰¤ n\n"
"```\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `revert h` macht das Gegenteil von `intro`."
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn das Goal von der Form `A âˆ¨ B` ist, enscheidet man mit `left` die linke Seite zu zeigen.\n"
"\n"
"## Beispiele\n"
"\n"
"Folgendes Beispiel kann mit `left` und `assumption` gelÃ¶st werden.\n"
"```\n"
"Objekte:\n"
"  ha : A\n"
"Goal:\n"
"  A âˆ¨ B\n"
"```\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `right` entscheidet sich fÃ¼r die right Seite."
msgstr ""

#: Game.Doc.Tactic
msgid "`let x : â„• := 5 ^ 2` fÃ¼hrt eine neue temporÃ¤re Definition ein.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `have x : â„• := 5 ^ 2` fÃ¼hrt ebenfalls eine neue natÃ¼rliche Zahle `x` ein, aber\n"
"  Lean vergisst sofort, wie die Zahl definiert war. D.h. `x = 25` wÃ¤re dann nicht\n"
"  beweisbar. Mit `let x : â„• := 5 ^ 2` ist `x = 25` durch `rfl` beweisbar.\n"
"* `set x : â„• := 5 ^ 2` macht das Gleiche wie `let` aber versucht auch `x` im Goal Ã¼berall einzusetzen wo `5 ^ 2` steht."
msgstr ""

#: Game.Doc.Tactic
msgid "`set f := _` funktioniert wie `let` aber versucht auch `f` im Goal Ã¼berall einzusetzen."
msgstr ""

#: Game.Doc.Tactic
msgid "`linarith` lÃ¶st Systeme linearer (Un-)Gleichungen.\n"
"\n"
"## Detail\n"
"`linarith` kann lineare Gleichungen und Ungleichungen beweisen indem\n"
"es das Gegenteil vom Goal annimmt und versucht einen Widerspruch in den\n"
"Annahmen zu erzeugen (Widerspruchsbeweis). Es braucht ein `â‰¤` definiert um\n"
"zu funktionieren.\n"
"\n"
"## Beispiel\n"
"\n"
"Folgendes kann `linarith` beweisen.\n"
"```\n"
"Objekte\n"
"  x y : â„¤\n"
"  hâ‚ : 5 * y â‰¤ 35 - 2 * x\n"
"  hâ‚‚ : 2 * y â‰¤ x + 3\n"
"Goal\n"
"  y â‰¤ 5\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`push_neg` schreibt `Â¬âˆ€ x, _` zu `âˆƒ x, Â¬ _` und `Â¬âˆƒ x, _` zu `âˆ€x, Â¬ _` um.\n"
"\n"
"## Details\n"
"\n"
"`push_neg` schiebt das `Â¬` soweit nach innen wie mÃ¶glich.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* Die beiden Lemmas heissen `not_forall` und `not_exists` und kÃ¶nnen mit `rw` einzeln angewendet\n"
"  werden."
msgstr ""

#: Game.Doc.Tactic
msgid "obtain âŸ¨arg1, arg2âŸ© := h decomposes `h` to its parts `arg1` and `arg2`"
msgstr ""

#: Game.Doc.Tactic
msgid "`obtain âŸ¨âŸ© := h` teilt eine Annahme `h` in ihre Einzelteile auf.\n"
"\n"
"## Details\n"
"FÃ¼r Annahmen die Strukturen sind, wie z.B. `h : A âˆ§ B` (oder `âˆƒx, P x`) kann man die\n"
"Einzelteile mit  `obtain âŸ¨a, bâŸ© := h` benennen.\n"
"\n"
"FÃ¼r eine Annahme der Form `h : A âˆ¨ B` kann man mit `obtain ha | hb := h` zwei Goals\n"
"erzeugen, einmal unter Annahme der linken Seite, einmal unter Annahme der Rechten.\n"
"\n"
"Die Wildcard `obtain âŸ¨âŸ© := h` entscheidet selbstÃ¤ndig, welcher Fall vorliegt und\n"
"benennt die entehenden Annahmen.\n"
"\n"
"## Beispiele\n"
"\n"
"```\n"
"Annahmen:\n"
"  h : A âˆ§ B\n"
"  g : A â†’ C âˆ¨ B â†’ C\n"
"Goal:\n"
"  C\n"
"```\n"
"\n"
"wenn man hier `obtain âŸ¨hâ‚, hâ‚‚âŸ© := h` und danach `obtain gâ‚ | gâ‚‚ := g` benÃ¼tzt, kriegt man\n"
"zwei Goals:\n"
"\n"
"```\n"
"Annahmen:\n"
"  hâ‚ : A\n"
"  hâ‚‚ : B\n"
"  gâ‚ : A â†’ C\n"
"Goal:\n"
"  C\n"
"```\n"
"\n"
"```\n"
"Annahmen:\n"
"  hâ‚ : A\n"
"  hâ‚‚ : B\n"
"  gâ‚‚ : B â†’ C\n"
"Goal:\n"
"  C\n"
"```\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* FÃ¼r `n : â„•` hat `obtain âŸ¨âŸ© := n` einen Ã¤hnlichen Effekt wie `induction n` mit dem Unterschied,\n"
"  dass im Fall `n + 1` keine Induktionshypothese zur VerfÃ¼gung steht."
msgstr ""

#: Game.Doc.Tactic
msgid "`refine { ?..! }` wird benÃ¶tigt um eine Struktur (z.B. ein $R$-Modul) im Taktikmodus in einzelne\n"
"Goals aufzuteilen. Danach hat man ein Goal pro Strukturfeld.\n"
"\n"
"(*Bemerkung*: Es gibt in Lean verschiedenste bessere Varianten dies zu erreichen,\n"
"z.B. \\\"Term Modus\\\" oder \\\"anonyme Konstruktoren\\\", aber fÃ¼r den Zweck des Spieles bleiben wir\n"
"bei diesem Syntax.)"
msgstr ""

#: Game.Doc.Tactic
msgid "`refine' { .. }` wird benÃ¶tigt um eine Struktur (z.B. ein $R$-Modul) im Taktikmodus in einzelne\n"
"Goals aufzuteilen. Danach hat man ein Goal pro Strukturfeld.\n"
"\n"
"(*Bemerkung*: Es gibt in Lean verschiedenste bessere Varianten dies zu erreichen,\n"
"z.B. \\\"Term Modus\\\" oder \\\"anonyme Konstruktoren\\\", aber fÃ¼r den Zweck des Spieles bleiben wir\n"
"bei diesem Syntax.)"
msgstr ""

#: Game.Doc.Tactic
msgid "`revert h` fÃ¼gt die Annahme `h` als ImplikationsprÃ¤misse vorne ans Goal an.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Objekte:\n"
"  A B : Prop\n"
"Annahmen:\n"
"  h : A\n"
"  g : A â†’ B\n"
"Goal:\n"
"  B\n"
"```\n"
"\n"
"In diesem Fall bewirkt `revert h`, dass `h` aus den Annahmen vorne als `A â†’` ans Goal angefÃ¼gt wird:\n"
"\n"
"```\n"
"Objekte:\n"
"  A B : Prop\n"
"Annahmen:\n"
"  g : A â†’ B\n"
"Goal:\n"
"  a â†’ B\n"
"```\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `revert` ist das Gegenteil von `intro`.\n"
"* `revert` kann insbesondere nÃ¼tzlich sein, um anschliessend `contrapose` zu verwenden.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Objekte\n"
"  A P : Prop\n"
"  h : P\n"
"Goal\n"
"  A\n"
"```\n"
"\n"
"hier Ã¤ndert `revert h` das Goal zu\n"
"\n"
"```\n"
"Objekte\n"
"  A P : Prop\n"
"Goal\n"
"  P â†’ A\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`rfl` beweist ein Goal der Form `X = X`.\n"
"\n"
"## Detail\n"
"\n"
"`rfl` beweist jedes Goal `A = B` wenn `A` und `B` per Definition das gleiche sind (DefEq).\n"
"Andere Taktiken rufen `rfl` oft am Ende versteckt\n"
"automatisch auf um zu versuchen, den Beweis zu schliessen.\n"
"\n"
"\n"
"## Beispiel\n"
"`rfl` kann folgende Goals beweisen:\n"
"\n"
"```\n"
"Objekte\n"
"  a b c : â„•\n"
"Goal:\n"
"  (a + b) * c = (a + b) * c\n"
"```\n"
"\n"
"```\n"
"Objekte\n"
"  n : â„•\n"
"Goal\n"
"  1 + 1 = 2\n"
"```\n"
"denn Lean liest dies intern als `0.succ.succ = 0.succ.succ`."
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn das Goal von der Form `A âˆ¨ B` ist, enscheidet man mit `right` die rechte Seite zu zeigen.\n"
"\n"
"## Beispiele\n"
"\n"
"Folgendes Beispiel kann mit `right` und `assumption` gelÃ¶st werden.\n"
"```\n"
"Objekte:\n"
"  hB : B\n"
"Goal:\n"
"  A âˆ¨ B\n"
"```\n"
"\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `left` entscheidet sich fÃ¼r die linke Seite."
msgstr ""

#: Game.Doc.Tactic
msgid "LÃ¶st Gleichungen mit den Operationen `+, -, *, ^`.\n"
"\n"
"## Details\n"
"Insbesondere funktioniert `ring` in Ringen/Semiringen wie z.B. `â„•, â„¤, â„š, â€¦`\n"
"(i.e. Typen `R` mit Instanzen `Ring R` oder `Semiring R`).\n"
"Die Taktik ist besonders auf kommutative Ringe (`CommRing R`) ausgelegt.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `ring` kann nicht wirklich mit Division (`/`) oder Inversen (`â»Â¹`) umgehen. DafÃ¼r ist die\n"
"  Taktik `field_simp` gedacht, und die typische Sequenz ist\n"
"  ```\n"
"  field_simp\n"
"  ring\n"
"  ```"
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn man eine Annahme `(h : X = Y)` hat, kann man mit\n"
"`rw [h]` alle `X` im Goal durch `Y` ersetzen.\n"
"\n"
"## Details\n"
"\n"
"* `rw [â†h]` wendet `h` rÃ¼ckwÃ¤rts an und ersetzt alle `Y` durch `X`.\n"
"* `rw [h, g, â†f]`: Man kann auch mehrere `rw` zusammenfassen.\n"
"* `rw [h] at hâ‚‚` ersetzt alle `X` in `hâ‚‚` zu `Y` (anstatt im Goal).\n"
"* `rw [my_theorem]` sucht nach dem ersten Ort, wo es umschreiben kann um die Impliziten\n"
"  Argumente von `my_theorem` zu fÃ¼llen\n"
"* `nth_rw 2 [my_theorem]` ist eine Variante, die stattdessen am 2. Ort umschreibt.\n"
"\n"
"`rw` funktioniert gleichermaÃŸen mit Annahmen `(h : X = Y)` also auch\n"
"mit Theoremen/Lemmas der Form `X = Y`\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Objekte:\n"
"  m n : â„•\n"
"  f g : â„• â†’ â„•\n"
"Annahmen:\n"
"  hâ‚ : m = n\n"
"  hâ‚‚ : f = g\n"
"Goal:\n"
"  f m = g n\n"
"```\n"
"\n"
"`rw [hâ‚‚]` schreibt das Goal zu `g n = g m` um, ein weiteres `rw [hâ‚]` dann zu `g m = g m`, was es\n"
"direkt auch schlieÃŸt."
msgstr ""

#: Game.Doc.Tactic
msgid "(shouldn't be visible to the player!)"
msgstr ""

#: Game.Doc.Tactic
msgid "`simp` versucht alle Vereinfachungslemmas anzuwenden, die in der `mathlib` mit `@[simp]`\n"
"gekennzeichnet sind.\n"
"\n"
"## Details\n"
"\n"
"* `simp?` zeigt welche Lemmas verwendet wurden.\n"
"* `simp [my_lemma]` fÃ¼gt zudem `my_lemma` temporÃ¤r zur Menge der `simp`-Lemmas hinzu.\n"
"* ein `simp`, das nicht am Ende des Beweis steht sollte durch eine entsprechende\n"
"  `simp only [...]` Aussage ersetzt werden, um den Beweis stabiler zu machen."
msgstr ""

#: Game.Doc.Tactic
msgid "`simp_rw [hâ‚, hâ‚‚, hâ‚ƒ]` versucht wie `rw` jedes Lemma der Reihe nach zu Umschreiben zu verwenden,\n"
"verwendet aber jedes Lemma so oft es kann.\n"
"\n"
"## Details\n"
"\n"
"Es bestehen aber drei grosse Unterschiede zu `rw`:\n"
"\n"
"* `simp_rw` wendet jedes Lemma so oft an wie es nur kann.\n"
"* `simp_rw` kann besser unter Quantifiern umschreiben als `rw`.\n"
"* `simp_rw` fÃ¼hrt nach jedem Schritt ein `simp only []` aus und vereinfacht dadurch grundlegenste\n"
"  Sachen."
msgstr ""

#: Game.Doc.Tactic
msgid "`suffices h : P` fÃ¼hrt ein neues Zwischenresultat ein, aus dem das Goal direkt folgen soll.\n"
"\n"
"## Details\n"
"\n"
"Der einzige Unterschied zu `have h : P` ist, dass die beiden resultierenden Goals vertauscht sind.\n"
"\n"
"Mathematisch braucht man diese in ein bisschen unterschiedlichen FÃ¤llen:\n"
"\n"
"* `suffices h : P` : \\\"Es genÃ¼gt zu zeigen, dass â€¦\\\". Als erstes folgt die ErklÃ¤rung wieso\n"
"  das genÃ¼gt, danach muss man nur noch `P` beweisen.\n"
"* `have h : P` : Ein (kleines) Zwischenresultat. Als erstes folgt dann der Beweis dieses\n"
"Resultats, anschliessend setzt man den Beweis mit Hilfe des Zwischenresultats fort."
msgstr ""

#: Game.Doc.Tactic
msgid "`symm` (fÃ¼r \"symmetry\") kann Gleichheiten oder `â†”` umdrehen. `symm at h` dreht eine Gleichheit\n"
"(oder `â†”`) in der Annahme `h`.\n"
"\n"
"## Details\n"
"\n"
"Man kann auch `h.symm` fÃ¼r die gedrehte Annahme schreiben, wenn man diese irgendwo\n"
"verwendet. Das verwendet intern die Lemmata\n"
"`Eq.symm` oder `Iff.symm`.\n"
"\n"
"## Beispiel\n"
"\n"
"ist das Goal `x = y`, dann wandelt es `symm` in `y = x` um. Analog, wandelt `symm at h` die Annahme\n"
"`(h : z = w)` in `(h : w = z)` um."
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn man `X = Z` zeigen mÃ¶chte, kann man mit\n"
"`trans Y` einen Zwischenschritt `Y` einfÃ¼gen.\n"
"Zu zeigen sind dann also `X = Y`  und `Y = Z`.\n"
"\n"
"## Details\n"
"`trans` ist besondern gut geeignet, um eine Gleichung `X = Z `\n"
"durch eine â€Rechnungâ€œ der Form `X = Yâ‚ = Yâ‚‚ = Yâ‚ƒ â€¦ = Z` Schritt fÃ¼r Schritt nachzuweisen:\n"
"\n"
"* `trans Yâ‚`\n"
"* Beweis von `X = Yâ‚`\n"
"* `trans Yâ‚‚`\n"
"* Beweis von `Yâ‚ = Yâ‚‚`\n"
"* `trans Yâ‚ƒ`\n"
"* â€¦\n"
"* Beweis von `â€¦ = Z`\n"
"\n"
"Genauso wie fÃ¼r Gleichungen `X = Z` funktioniert `trans` auch fÃ¼r Ã„quivalenzen `X â†” Z` und gewisse\n"
"transitive Relationen im Beweisziel.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Objekte:\n"
"  A B C : Prop\n"
"Annahmen:\n"
"  hâ‚ : A â†” B\n"
"  hâ‚‚ : B â†” C\n"
"Goal:\n"
"  A â†” C\n"
"```\n"
"\n"
"Die Taktik `trans B` erstellt dann aus dem Goal zwei neue `A â†” B` und `B â†” C`."
msgstr ""

#: Game.Doc.Tactic
msgid "`trivial` versucht durch Kombination von wenigen simplen Taktiken das Goal zu schliessen.\n"
"\n"
"## Details\n"
"Die Taktiken, die verwendet werden sind unter anderem:\n"
"\n"
"* `assumption`\n"
"* `rfl`\n"
"* `contradiction`\n"
"* und noch 3 andere, die hier nicht behandelt werden\n"
"  (`decide`, `apply True.intro`, `apply And.intro`).\n"
"\n"
"## Beispiel\n"
"\n"
"Das folgende Goal ist `trivial`:\n"
"\n"
"```\n"
"Objekte:\n"
"  n m : â„•\n"
"  h : n â‰¤ m\n"
"Goal:\n"
"  n â‰¤ m\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`unfold myDef` Ã¶ffnet eine Definition im Goal.\n"
"\n"
"## Details\n"
"Bis auf DefEq (definitinal equality) Ã¤ndert `unfold` nichts, manche Taktiken\n"
"(z.B. `push_neg`, `rw`) brauchen aber manchmal die Hilfe.\n"
"\n"
"`unfold myDef at h` kann auch Definitionen in Annahmen Ã¶ffnen\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `change P` ist eine andere Taktik, die das aktuelle Goal in einen DefEq-Ausdruck umschreibt.\n"
"  Diese Taktik braucht man auch manchmal um zu hacken, wenn Lean MÃ¼he hat etwas zu verstehen."
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn das Goal von der Form `âˆƒx, P x` ist, kann man mit `use n` ein konkretes Element angeben\n"
"mit dem man das Goal beweisen mÃ¶chte.\n"
"\n"
"## Details\n"
"\n"
"`use n` versucht zudem anschliessend `rfl` aufzurufen, und kann das Goal damit manchmal direkt\n"
"schlieÃŸen."
msgstr ""

#: Game.Doc.Tactic
msgid "`tauto` proves all logical tautologies.\n"
"\n"
"## Beispiel\n"
"\n"
"Folgendes Goal ist mit `tauto` lÃ¶sbar\n"
"\n"
"```\n"
"Objekte:\n"
"  (A B C : Prop)\n"
"Goal:\n"
"  Â¬((Â¬B âˆ¨ Â¬ C) âˆ¨ (A â†’ B)) â†’ (Â¬A âˆ¨ B) âˆ§ Â¬ (B âˆ§ C)\n"
"```"
msgstr ""

#: Game.Doc.Theorem
msgid "Die Taktiken `tauto` oder `simp` kÃ¶nnen oft stattdessen verwendet werden."
msgstr ""

#: Game.Doc.Theorem
msgid "Oft kann `tauto` diese Art von logischen AusdrÃ¼cken lÃ¶sen."
msgstr ""

#: Game.Levels.Logos.L01_Tauto
msgid "Automatisierung"
msgstr ""

#: Game.Levels.Logos.L01_Tauto
msgid "Gerade seid Ihr auf KÃ¶nigin *Logisindes* Planeten. Sie kommt ohne Umschweife zum Punkt:\n"
"\n"
"**Logisinde**: Werte Wesen aus fremden Welten, gestatten Sie eine Frage. Warum gilt â€¦\n"
"\n"
"Und sie kritzelt etwas auf ein StÃ¼ck Papier: oben ein paar Annahmen, unten eine Schlussfolgerung.\n"
"Dazwischen sollst du offenbar einen Beweis eintragen.\n"
"Du siehst Robo hilflos an."
msgstr ""

#: Game.Levels.Logos.L01_Tauto
msgid ""
msgstr ""

#: Game.Levels.Logos.L01_Tauto
msgid "**Robo**: Das ist ganz einfach. Mit `Â«{A}Â» Â«{B}Â» Â«{C}Â» : Prop` meint sie:\n"
"`Â«{A}Â»`, `Â«{B}Â»` und `Â«{C}Â»` sind irgendwelche Aussagen (*propositions*).\n"
"Und mit `â†’` meint sie â‡’, also â€œimpliziertâ€. Die anderen Symbole kennst du, oder?\n"
"\n"
"**Du**: Ehhm, ja. Aber da muss ich jetzt trotzdem erst einmal Ã¼berlegen.\n"
"\n"
"**Robo**: (flÃ¼sternd) Behaupte doch einfach, dass sei eine Tautologie.\n"
"\n"
"**Du**: Ernsthaft?\n"
"\n"
"**Robo**: Ja. Schreib einfach `tauto`.\n"
"\n"
"**Robo**: Mach schon â€¦"
msgstr ""

#: Game.Levels.Logos.L01_Tauto
msgid "**Logisinde**: (etwas konsterniert) Ja, das ist streng genommen richtig.\n"
"Aber glaubt bloÃŸ nicht, dass Ihr damit auf *diesem* Planeten viel weiterkommt!\n"
"Meine Untertanen verstehen `tauto` nicht. Da mÃ¼sst Ihr Euch schon etwas mehr anstrengen."
msgstr ""

#: Game.Levels.Logos.L02_Rfl
msgid "Aller Anfang ist... ein Einzeiler?"
msgstr ""

#: Game.Levels.Logos.L02_Rfl
msgid "In der Zwischenzeit hat bereits sich eine lange Schlange Untertanen gebildet, die gern ihren\n"
"Fragen stellen wÃ¼rden. Logisinde winkt den ersten nach vorn. Er rÃ¤uspert sich.\n"
"\n"
"**Untertan**: Warum ist $42 = 42$?\n"
"\n"
"Du schaust ihn fassungslos an.\n"
"Er schreibt es dir wieder auf."
msgstr ""

#: Game.Levels.Logos.L02_Rfl
msgid "**Robo**: Ist doch klar. Du musst ihn einfach daran erinnern,\n"
"dass Gleichheit *reflexiv* ist. Probier mal `rfl`."
msgstr ""

#: Game.Levels.Logos.L02_Rfl
msgid "**Untertan**: Ah, richtig. Ja, Sie haben ja so recht. Das vergesse ich immer. Rfl, rfl, rfl â€¦"
msgstr ""

#: Game.Levels.Logos.L03_Assumption
msgid "Annahmen"
msgstr ""

#: Game.Levels.Logos.L03_Assumption
msgid "WÃ¤hrend der erste Untertan noch rfl, rfl, rfl murmelt, tritt schon der nÃ¤chste nach vorne.\n"
"Es ist schÃ¼chtern und schreibt bloÃŸ."
msgstr ""

#: Game.Levels.Logos.L03_Assumption
msgid "**Robo**: `Â«{n}Â» : â„•` bedeutet, `Â«{n}Â»` ist eine natÃ¼rliche Zahl.\n"
"\n"
"**Du**: Warum schreibt er dann nicht `Â«{n}Â» âˆˆ â„•`??\n"
"\n"
"**Robo**: Weil das hier alles komische Typen sind â€¦ Ich kann dir das spÃ¤ter mal in Ruhe\n"
"erklÃ¤ren. Jetzt will ich erst einmal die Frage entschlÃ¼sseln.\n"
"\n"
"**Robo**: Also, `Â«{hâ‚}Â»`, `Â«{hâ‚‚}Â»`, `Â«{hâ‚ƒ}Â»` sind einfach nur Namen fÃ¼r verschiedene Annahmen,\n"
"und zwar fÃ¼r die Annahme `n < 10`, `1 < n` und `n â‰  5`. Beweisen sollen wir: `1 < n`.\n"
"\n"
"**Du**: Aber das war doch gerade eine der Annahmen.\n"
"\n"
"**Robo**: Ja, stimmt.\n"
"\n"
"**Du**: ???\n"
"\n"
"**Robo**: Du musst ihm das halt explizit sagen. Probiers mal mit `assumption`."
msgstr ""

#: Game.Levels.Logos.L03_Assumption
msgid "**Untertan**: Ja richtig! Wenn Ihr nur wÃ¼sstet, was ich mir an dieser Frage schon den Kopf\n"
"zerbrochen habe!"
msgstr ""

#: Game.Levels.Logos.L04_Assumption
msgid "Logische Aussagen"
msgstr ""

#: Game.Levels.Logos.L04_Assumption
msgid "Ein dritter Untertan kommt mit folgendem Problem."
msgstr ""

#: Game.Levels.Logos.L04_Assumption
msgid "**Robo**: Hier bedeutet `Â«{A}Â» : Prop` wieder, dass `Â«{A}Â»` irgendeine Aussage ist.\n"
"Und `Â«{hA}Â»` ist eine Name fÃ¼r die Annahme, dass `Â«{A}Â»` wahr ist.\n"
"\n"
"**Du**: Und unter dieser Annahme sollen wir jetzt `Â«{A}Â»` beweisen?\n"
"\n"
"**Robo**: Ja. Da kommst du jetzt selbst drauf, wie das geht, oder?"
msgstr ""

#: Game.Levels.Logos.L04_Assumption
msgid "**Robo**: Ist doch genau wie eben:\n"
"die Aussage, die zu beweisen ist, gehÃ¶rt selbst zu den Annahmen.\n"
"Also wird `assumption` auch wieder funktionieren."
msgstr ""

#: Game.Levels.Logos.L04_Assumption
msgid "**Untertan**: Das ging ja schnell. Super! Vielen Dank."
msgstr ""

#: Game.Levels.Logos.L05_True
msgid "True or False"
msgstr ""

#: Game.Levels.Logos.L05_True
msgid "Der nÃ¤chste Untertan in der Reihe ist ein Schelm."
msgstr ""

#: Game.Levels.Logos.L05_True
msgid "**Robo**: Dieses `True` ist eine spezielle Aussage, nÃ¤mlich die Aussage, die immer und\n"
"bedingungslos wahr ist.\n"
"\n"
"**Du**: Und was genau ist dann zu beweisen?\n"
"\n"
"**Robo**: Ich glaube, nichts. Ich glaube, du kannst einfach `trivial` schreiben."
msgstr ""

#: Game.Levels.Logos.L05_True
msgid "**Schelm**: Wollte nur mal sehen, dass Ihr nicht auf den Kopf gefallen seid â€¦\n"
"\n"
"**Du** *(zu Robo)*: KÃ¶nnen wir nicht einfach immer dieses `trivial` verwenden?\n"
"Wie in einer Mathe-Vorlesung?\n"
"\n"
"**Robo**: Nein, das `trivial` hier hat eine ziemlich spezielle Bedeutung.\n"
"Das funktioniert nur in einer Handvoll Situationen."
msgstr ""

#: Game.Levels.Logos.L06_Not
msgid "Not"
msgstr ""

#: Game.Levels.Logos.L06_Not
msgid "Der Schelm hat noch eine Schwester dabei."
msgstr ""

#: Game.Levels.Logos.L06_Not
msgid "**Robo**: Dieses Zeichen `Â¬` bedeutet Negation. Also wenn eine Aussage `(A : Prop)`\n"
"wahr ist, dann ist `Â¬A` falsch, und umgekehrt.\n"
"\n"
"**Du**: Und `False` ist wahrscheinlich die Aussage, die immer falsch ist?\n"
"\n"
"**Robo**: Ja, richtig.\n"
"\n"
"**Du**: Ist das jetzt nicht doch wieder trivial?\n"
"\n"
"**Robo**: Probier mal!"
msgstr ""

#: Game.Levels.Logos.L06_Not
msgid "Die Schwester lacht und eilt ihrem Bruder hinterher."
msgstr ""

#: Game.Levels.Logos.L07_Contradiction
msgid "Aus Falschem folgt vieles."
msgstr ""

#: Game.Levels.Logos.L07_Contradiction
msgid "Als nÃ¤chstes kommen drei Querulanten. Der erste hat folgendes Problem:"
msgstr ""

#: Game.Levels.Logos.L07_Contradiction
msgid "**Du** Wenn ich das jetzt richtig lese, ist `Â«{A}Â»` eine Aussage,\n"
"und wir haben auÃŸerdem eine Annahme names `Â«{h}Â»`, die besagt â€¦\n"
"\n"
"**Robo**: â€¦ die besagt, dass `False` gilt.\n"
"\n"
"**Du**: Ich dachte, `False` gilt nie?\n"
"\n"
"**Robo**: Ja, genau. Die Annahme ist `False`, also falsch.\n"
"Und aus einer falschen Annahme kann man bekanntlich alles beweisen!\n"
"Insbesondere die gesuchte Aussage `Â«{A}Â»`.\n"
"\n"
"**Du**: Und wie erklÃ¤re ich das jetzt diesem Formalosophen?\n"
"\n"
"**Robo**: Ich glaube, du musst ihn darauf hinweisen, dass zwischen der allgemeingÃ¼ltigen\n"
"Annahme `True` und seiner Annahme `False` ein Widerspruch besteht. Probier mal `contradiction`."
msgstr ""

#: Game.Levels.Logos.L07_Contradiction
msgid "Der erste Querulant ist offenbar zufrieden.\n"
"\n"
"**Du**: War das jetzt ein Widerspruchsbeweis?\n"
"\n"
"**Robo**: Nein, nein, ein Widerspruchsbeweis sieht anders aus. Das Argument hier war:\n"
" wir haben eine `contradiction` in unserem Annahmen, also folgt jede beliebige Aussage."
msgstr ""

#: Game.Levels.Logos.L08_Contradiction
msgid "Aus Falschem folgt vieles."
msgstr ""

#: Game.Levels.Logos.L08_Contradiction
msgid "Auftritt zweiter Querulant."
msgstr ""

#: Game.Levels.Logos.L08_Contradiction
msgid ""
msgstr ""

#: Game.Levels.Logos.L08_Contradiction
msgid "**Du** Ist `Â«{n}Â» â‰  Â«{n}Â»` nicht auch ein Widerspruch?\n"
"\n"
"**Robo**: Probiers mal!"
msgstr ""

#: Game.Levels.Logos.L08_Contradiction
msgid "**Du**: Ja, scheint funktioniert zu haben.\n"
"\n"
"**Du**: Aber irgendwie kommt mir das immer noch ein wenig suspekt vor.\n"
"Jetzt habe ich bewiesen, dass eine beliebige natÃ¼rliche Zahl gleich 37 ist?\n"
"\n"
"**Robo**: Nein, nicht doch. Nur eine beliebige Zahl, die ungleich sich selbst ist, ist gleich 37.\n"
"Und gleich 38, und gleich 39, â€¦\n"
"\n"
"**Du**: Okay, okay, verstehe."
msgstr ""

#: Game.Levels.Logos.L09_Contradiction
msgid "Aus Falschem folgt vieles."
msgstr ""

#: Game.Levels.Logos.L09_Contradiction
msgid "Auftritt dritter Querulant."
msgstr ""

#: Game.Levels.Logos.L09_Contradiction
msgid ""
msgstr ""

#: Game.Levels.Logos.L09_Contradiction
msgid "**Du** Wieder ein Widerspruch in den Annahmen?\n"
"\n"
"**Robo**: Ich sehe, du hast langsam den Dreh raus."
msgstr ""

#: Game.Levels.Logos.L09_Contradiction
msgid "**Robo**: Gut gemacht. Bei dieser Frage ist auch ein bisschen offensichtlicher,\n"
"worin der Widerspruch besteht: Die Annahme `n â‰  10` ist genau die Negation von `n = 10`.\n"
"Man muss `â‰ ` immer als `Â¬(Â· = Â·)` lesen."
msgstr ""

#: Game.Levels.Logos.L10_And
msgid "Und"
msgstr ""

#: Game.Levels.Logos.L10_And
msgid "Der nÃ¤chste Formalosoph in der Reihe hat seine Frage bereits mitgebracht.\n"
"Er legt sie uns vor, setzt sich hin und hÃ¤kelt."
msgstr ""

#: Game.Levels.Logos.L10_And
msgid ""
msgstr ""

#: Game.Levels.Logos.L10_And
msgid "**Du**: Also, wir haben zwei Annahmen: `Â«{A}Â»` gilt, und `Â«{B}Â»` gilt auch. Und beweisen sollen wir\n"
"dass `Â«{A}Â» und Â«{B}Â»` gilt. Ich glaube, diese Formalospinner treiben mich noch zur Verzweiflung.\n"
"Kann ich nicht wieder `trivial` sagen?\n"
"\n"
"**Robo**: Nee, diesmal wird das nicht funktionieren.\n"
"Du musst das Beweisziel einfach in zwei Teile zerlegen. Probier mal `constructor`.\n"
"\n"
"**Du**: Du meinst, `destructor`??\n"
"\n"
"**Robo**: Nein, `constructor`. Ich weiÃŸ, das ist verwirrend,\n"
"aber die nennen das hier so weil man die Aussage aus mehreren Teilen\n"
"konstruieren kann."
msgstr ""

#: Game.Levels.Logos.L10_And
msgid "**Robo**: Schau mal, das ist Zauberpapier.\n"
"Jetzt haben wir auf einmal zwei Beweisziele.\n"
"Hier ist dast Ziel `Â«{B}Â»`.\n"
"Ich glaube, du weiÃŸt schon, wie man die jeweils erreicht.\n"
"Die Ziele stehen ja jeweils in den *Annahmen*."
msgstr ""

#: Game.Levels.Logos.L10_And
msgid "**Robo**: Super!\n"
"\n"
"Ihm scheinen diese Fragen inzwischen SpaÃŸ zu machen.\n"
"\n"
"**Robo**: Meinst du, dieser Hebel, an dem \"Editor mode\" steht, ist echt?\n"
"Oder ist der nur gemalt? Probier mal!"
msgstr ""

#: Game.Levels.Logos.L11_And
msgid "Und"
msgstr ""

#: Game.Levels.Logos.L11_And
msgid "Langsam wird die Schlange kÃ¼rzer. Die nÃ¤chste Formalosophin, ebenfalls hÃ¤kelnd, hat folgendes Anliegen."
msgstr ""

#: Game.Levels.Logos.L11_And
msgid "**Du**: Jetzt mÃ¼ssen wir wohl die Annahme de-konstruieren.\n"
"\n"
"**Robo**: Ja, genau. Das geht am einfachsten mit `obtain âŸ¨hâ‚, hâ‚‚âŸ© := Â«{h}Â»`.\n"
"\n"
"**Du**: Moment, wie schreib ich *das* denn hier auf?\n"
"\n"
"**Robo**: Die bleiden Klammern schreibst du als `\\<` und `\\>`, oder gleichzeitig als `\\<>`.\n"
"Und hâ‚ schreibst du einfach als `h\\1`. Aber du kannst dir auch einfach andere Namen\n"
"fÃ¼r `hâ‚` und `hâ‚‚`, zum Beispiel `obtain âŸ¨hA, hBCâŸ© := Â«{h}Â»`."
msgstr ""

#: Game.Levels.Logos.L11_And
msgid "**Robo**: Das sieht doch schon besser aus! Gleich nochmal!"
msgstr ""

#: Game.Levels.Logos.L11_And
msgid "**Robo**: Du hast einen Beweis dafÃ¼r in den *Annahmen*."
msgstr ""

#: Game.Levels.Logos.L11_And
msgid "**Robo**: Du hÃ¤ttest das Ã¼brigens auch direkt verschachtelt schreiben kÃ¶nnen:\n"
"`obtain âŸ¨hâ‚, hâ‚‚ , hâ‚ƒâŸ© := {h}`."
msgstr ""

#: Game.Levels.Logos.L12_Or
msgid "Oder"
msgstr ""

#: Game.Levels.Logos.L12_Or
msgid "Der nÃ¤chste bitte â€¦"
msgstr ""

#: Game.Levels.Logos.L12_Or
msgid "**Du** Muss ich jetzt wieder das Beweisziel de-konstruieren?\n"
"\n"
"**Robo** Nein, viel einfacher. Wenn du eine Oder-Aussage beweisen sollst, musst du dich\n"
"einfach entscheiden, ob du die linke oder rechte Seite beweisen willst.\n"
"\n"
"**Du** Und wie erklÃ¤re ich meinem Formalosophen, welche Seite ich gern beweisen wÃ¼rde?\n"
"Ich will natÃ¼rlich `Â«{A}Â»` beweisen!\n"
"\n"
"**Robo** Mit `left` bzw. `right`. Ist doch logisch, oder?"
msgstr ""

#: Game.Levels.Logos.L12_Or
msgid "**Robo** Wusste gar nicht, dass du eine Links-Rechts-SchwÃ¤che hast. Probier's nochmal."
msgstr ""

#: Game.Levels.Logos.L12_Or
msgid "Auch dieser Formalosoph zieht zufrieden von dannen."
msgstr ""

#: Game.Levels.Logos.L13_Or
msgid "Oder"
msgstr ""

#: Game.Levels.Logos.L13_Or
msgid "Der nÃ¤chste bitte â€¦"
msgstr ""

#: Game.Levels.Logos.L13_Or
msgid ""
msgstr ""

#: Game.Levels.Logos.L13_Or
msgid "**Robo** Schau mal, wenn du mit dem Finger eine Annahme berÃ¼hrst, zeigt es dir,\n"
"wie die Klammern gesetzt sind. Irreâ€¦\n"
"\n"
"**Du** Ah ich sehe, also `(Â«{A}Â» âˆ§ Â«{B}Â») âˆ¨ Â«{A}Â»`!\n"
"\n"
"**Du** Ich glaube den ganzen Zircus hier langsam nicht mehr:\n"
"Zuerst ein \"Und\" im Ziel, dann \"Und\" in der Annahme, dann \"Oder\" im Ziel und jetzt\n"
"\"Oder\" in der Annahme, die haben sich doch abgesprochen!\n"
"\n"
"**Robo** Lass ihnen doch ihren SpaÃŸ.\n"
"Wir sind ja gleich hier fertig, und kÃ¶nnen zu einem interessanteren Planeten weiterfliegen.\n"
"\n"
"**Du** Also, wieder `obtain â€¦`?\n"
"\n"
"**Robo** Ja, aber diesmal nicht `obtain âŸ¨hâ‚, hâ‚‚âŸ© := Â«{h}Â»`, sondern `obtain h | h := Â«{h}Â»`."
msgstr ""

#: Game.Levels.Logos.L13_Or
msgid "**Robo**\n"
"Jetzt musst du dein Ziel zweimal beweisen:\n"
"Einmal unter Annahme der linken Seite `Â«{A}Â» âˆ§ Â«{B}Â»`,\n"
"und einmal unter Annahme der rechten Seite `Â«{A}Â»`.\n"
"Hier haben nehmen wir an, die linke Seite\n"
"sei wahr."
msgstr ""

#: Game.Levels.Logos.L13_Or
msgid "**Robo** Wie man mit einem Und in den Annahmen umgeht,\n"
"weiÃŸt du doch schon:\n"
"`obtain âŸ¨hâ‚, hâ‚‚âŸ© := Â«{h}Â»`. Zur Erinnerung: FÃ¼r die Klammern schreibst du `\\<>`."
msgstr ""

#: Game.Levels.Logos.L13_Or
msgid "**Robo** Jetzt musst du dein Ziel noch unter der rechten Annahme\n"
"von `(Â«{A}Â» âˆ§ Â«{B}Â») âˆ¨ Â«{A}Â»` zeigen, also angenommen, `Â«{A}Â»` sei wahr."
msgstr ""

#: Game.Levels.Logos.L13_Or
msgid "**Du** Okay, das scheint ihn zufriedenzustellen. Nur noch eine Seeleâ€¦\n"
"Kannst du mir vorher noch einmal kurz alles Leansch zusammenfassen,\n"
"das du mir bis hierher beigebracht hast?\n"
"\n"
"Robo strahlt Ã¼berglÃ¼cklich. Noch *nie* warst du so auf ihn angewiesen.\n"
"\n"
"**Robo** Na klar, schau her!\n"
"\n"
"## Notationen / Begriffe\n"
"\n"
"|               | Beschreibung                                                             |\n"
"|:--------------|:-------------------------------------------------------------------------|\n"
"| *Goal*        | Was aktuell zu beweisen ist.                                             |\n"
"| *Annahme*     | Objekte & Resultate, die man zur VerfÃ¼gung hat.                          |\n"
"| *Taktik*      | Befehl im Beweis. Entspricht einem Beweisschritt.                        |\n"
"| `â„•`           | Typ aller natÃ¼rlichen Zahlen.                                            |\n"
"| `0, 1, 2, â€¦`  | Explizite natÃ¼rliche Zahlen.                                             |\n"
"| `=`           | Gleichheit.                                                              |\n"
"| `â‰ `           | Ungleichheit. AbkÃ¼rzung fÃ¼r `Â¬(Â·=Â·)`.                                    |\n"
"| `Prop`        | Typ aller logischen Aussagen.                                            |\n"
"| `True`        | Die logische Aussage `(True : Prop)` ist bedingungslos wahr.             |\n"
"| `False`       | Die logische Aussage `(False : Prop)` ist bedingungslos falsch.          |\n"
"| `Â¬`           | Logische Negierung.                                                      |\n"
"| `âˆ§`           | Logisch UND.                                                             |\n"
"| `âˆ¨`           | Logisch ODER.                                                            |\n"
"| `(n : â„•)`     | Eine natÃ¼rliche Zahl.                                                    |\n"
"| `(A : Prop)`  | Eine logische Aussage.                                                   |\n"
"| `(ha : A)`    | Ein Beweis, dass die logische Aussage `(A : Prop)` wahr ist.             |\n"
"| `(h : A âˆ§ B)` | Eine Annahme, die den Namen `h` bekommen hat.                            |\n"
"\n"
"\n"
"## Taktiken\n"
"\n"
"Die Worte, die du aktiv gebrauchen musst, heiÃŸen zusammengefasst `Taktiken`.\n"
"Hier sind alle Taktiken, die wir auf diesem Planeten gebraucht haben:\n"
"\n"
"|    | Taktik                    | Beispiel                                          |\n"
"|:---|:--------------------------|:--------------------------------------------------|\n"
"| 1  | `rfl`                     | Beweist `A = A`.                                  |\n"
"| 2  | `assumption`              | Sucht das Goal in den Annahmen.                   |\n"
"| 3  | `contradiction`           | Sucht einen Widerspruch.                          |\n"
"| 4  | `trivial`                 | Kombiniert die obigen drei Taktiken (und mehr).   |\n"
"| 5  | `constructor`             | Teilt ein UND im Goal auf.                        |\n"
"| 6  | `left`/`right`            | Beweist eine Seite eines ODER im Goal.            |\n"
"| 7áµƒ | `obtain âŸ¨hâ‚, hâ‚‚âŸ© := h`    | Teilt ein UND in den Annahmen auf.                |\n"
"| 7áµ‡ | `obtain h := h \\| h`     | Teilt ein ODER in den Annahmen in zwei FÃ¤lle auf. |\n"
"\n"
"**Du** Woher weiÃŸt du das eigentlich alles?\n"
"\n"
"**Robo** Keine Ahnung. War, glaube ich, vorinstalliert."
msgstr ""

#: Game.Levels.Logos.L14_Summary
msgid "Zusammenfassung"
msgstr ""

#: Game.Levels.Logos.L14_Summary
msgid "Der letzte Untertan tritt vor. Ihr Anliegen ist etwas komplizierter als die vorherigen.\n"
"\n"
"**Robo** Wirf einfach alles drauf, was du gelernt hast.\n"
"Hier, ich bin sogar so nett und zeig dir noch einmal die vier\n"
"wichtigsten Taktiken fÃ¼r diese Situation an.\n"
"\n"
"| (Ãœbersicht) | Und (`âˆ§`)                | Oder (`âˆ¨`)              |\n"
"|:------------|:-------------------------|:------------------------|\n"
"| Annahme     | `obtain âŸ¨hâ‚, hâ‚‚âŸ© := h`   | `obtain h \\| h := h`   |\n"
"| Goal        | `constructor`            | `left`/`right`          |"
msgstr ""

#: Game.Levels.Logos.L14_Summary
msgid "**Robo**: Ich wÃ¼rd zuerst die Annahme Â«{h}Â» mit `obtain âŸ¨âŸ© := Â«{h}Â» aufteilen."
msgstr ""

#: Game.Levels.Logos.L14_Summary
msgid "**Robo**: Jetzt kannst du das `âˆ§` im Goal mit `constructor` angehen."
msgstr ""

#: Game.Levels.Logos.L14_Summary
msgid "**Robo**: Hier wÃ¼rde ich die Annahme Â«{h}Â» nochmals mit `obtain` aufteilen."
msgstr ""

#: Game.Levels.Logos.L14_Summary
msgid "**Robo**: Der Nachteil an der Reihenfolge ist, dass du jetzt in jedem Untergoal\n"
"`obtain âŸ¨âŸ© := h` aufrufen musst."
msgstr ""

#: Game.Levels.Logos.L14_Summary
msgid "**Robo** Bravo! Jetzt aber nichts wie weg hier, bevor sich eine neue Schlange bildet!\n"
"\n"
"KÃ¶nigin *Logisinde* ist in der Zwischenzeit eingeschlafen, und ihr stehlt euch heimlich davon."
msgstr ""

#: Game.Levels.Logos
msgid "Logos"
msgstr ""

#: Game.Levels.Logos
msgid "Durch eine unvorhergesehene und nicht-kanonische SingularitÃ¤t in der Raumzeit\n"
"bist du aus Versehen in ein Paralleluniversum gestolpert. Wie es aussieht, gibt es kein zurÃ¼ck.\n"
"Richte dich besser darauf ein, hier bleiben und dich zurechtzufinden zu mÃ¼ssen.\n"
"\n"
"Wie es aussieht, gibt es hier viele nette kleine Planeten. Alle bewohnbar, und bis zu\n"
"sieben SonnenuntergÃ¤nge tÃ¤glich inklusive. Nur werden sie allesamt von Formalosophen bewohnt,\n"
"seltsamen Wesen mit ausgefallenen mathematischen Obsessionen. Und dummerweise hat sich\n"
"herumgesprochen, dass du in deinem frÃ¼heren Universum Mathematiker warst. du wirst hier\n"
"keine Ruhe finden, solange du nicht lernst, ihren unablÃ¤ssigen Wissensdurst zu stillen.\n"
"\n"
"Es gibt nur zwei Schwierigkeiten: Erstens haben die Formalosophen allem Anschein nach\n"
"Ã¼berhaupt kein tieferes mathematisches VerstÃ¤ndnis, und zweitens kommunizieren Sie Ã¼ber Mathematik\n"
"exklusiv in einem dir fremden Dialekt, den sie Leansch [liËnÊƒ] nennen.\n"
"\n"
"Zum GlÃ¼ck hat Robo mit dir das Universum gewechselt.\n"
"Robo, das ist dein kleiner SmartElf. Robo ist zwar auch nicht die mathematische Leuchte, die du Dir\n"
"in dieser Situation gewÃ¼nscht hÃ¤ttest, aber es scheint, er hat irgendwo Leansch gelernt.\n"
"Und das ist Gold wert."
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "Intro"
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**Operationsleiter**: Hier, zum Beispiel:"
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**Operationsleiter**: Die Arbeiten meinen, das wÃ¤re so richtig und wir wÃ¼rden das dringend\n"
"brauchen. Aber keiner kann es mir beweisen.\n"
"\n"
"**Du**: Einen Moment. Das ist ja gerade so eine Implikation (`\\to`). Wir nehmen an,\n"
"dass `Â«{B}Â»` gilt, und wollen zeigen, dass dann gilt `Â«{A}Â»` impliziert `Â«{A}Â» und Â«{B}Â»`. Ja,\n"
"klar! NatÃ¼rlich stimmt das.\n"
"\n"
"Der Operationsleiter sieht dich erwartungsvoll an.\n"
"\n"
"**Du** *(leise zu Robo)*: Soll ich ihm `tauto` aufschreiben?\n"
"\n"
"**Robo** *(leise zurÃ¼ck)*: So wie der aussieht, fÃ¼rchte ich, das wird er auch nicht verstehen.\n"
"Schreib den Beweis lieber aus.\n"
"\n"
"**Du**: Aber wie denn? Ich glaube, ich wÃ¼rde als erstes gern so etwas sagen wie 'Nehmen wir\n"
"also an, `Â«{A}Â»` gilt â€¦'\n"
"\n"
"**Robo**: Ja, gute Idee. WÃ¤hle dazu fÃ¼r deine Annahme einfach einen Namen, zum Beispiel `h`,\n"
"und schreib `intro h`."
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**Du**: Okay. Jetzt habe ich also sowohl `Â«{A}Â»` als auch `Â«{B}Â»` in meinen Annahmen und\n"
"muss `Â«{A}Â» âˆ§ Â«{B}Â»` zeigen.\n"
"\n"
"**Robo**: Genau. Und wie das geht, weiÃŸt du ja schon."
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**Operationsleiter**: Perfekt! Danke schÃ¶n!\n"
"\n"
"Er geht zu einer Schalttafel und ein paar KnÃ¶pfe. Irgendwo setzt sich lautstark ein\n"
"FÃ¶rderband in Bewegung.\n"
"\n"
"**Operationsleiter**: Habt Ihr vielleicht noch ein paar Minuten?"
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "Revert"
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "Der Operationsleiter holt aus einem Container einen Stapel Papier hervor.\n"
"\n"
"**Operationsleiter**: Hier hat sich echt einiges angesammelt. WÃ¤re echt super, wenn Ihr mir\n"
"noch ein bisschen helfen kÃ¶nntet.\n"
"\n"
"Er Ã¼bergibt Euch das oberste Blatt."
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "**Operationsleiter**: Das ist von einem Kollegen.\n"
"\n"
"**Robo**: Oh, das hab ich schon einmal irgendwo gelesen. Warte mal â€¦ Richtig! Das war\n"
"damals, als ich Wikipedia gecrawlt habe: `Der Modus ponens ist eine schon in der antiken\n"
"Logik gelÃ¤ufige Schlussfigur, die in vielen logischen â€¦`\n"
"\n"
"**Du**: Robo! Gefragt ist ein Beweis und kein historischer Aufsatz! Oder komme ich hier\n"
"etwa mit `mopo` oder so etwas weiter?\n"
"\n"
"**Robo**: Okay, nein, sorry. `mopo` gibt es nicht. Probier lieber `revert Â«{hA}Â»`."
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "**Du**: Aha. `revert` ist quasi `intro` rÃ¼ckwÃ¤rts.\n"
"\n"
"**Robo**: Genau. `intro` nimmt die PrÃ¤misse aus einer Implikation `Â«{A}Â» \\to Â«{B}Â»` im\n"
"Beweisziel und macht daraus eine Annahme. `revert` nimmt umgekehrt eine Annahme und\n"
"setzt sie als ImplikationsprÃ¤misse vor das Beweisziel. Aber nun mach schon fertig."
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "Der Operationsleiter nimmt erfreut Eure LÃ¶sung entgegen, und greift zum Telefon."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "Apply"
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "Leider lÃ¤uft das Telefonat nicht so gut. Er legt wieder auf und schÃ¼ttelt mit dem Kopf.\n"
"\n"
"**Operationsleiter**: Der Kollege auf der anderen Seite des Mondes versteht kein `revert`. Oder\n"
"er tut zumindest so. Habt Ihr noch eine andere Idee?\n"
"\n"
"Er zieht eine Linie unter Euren Beweis, ergÃ¤nzt ein durchgestrichenes ~`revert`~, und legt Euch\n"
"das Blatt ein zweites Mal vor."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "**Robo**: Vielleicht wÃ¤re es ohnehin eleganter gewesen, die gegebene Implikation anzuwenden.\n"
"Probier doch mal `apply hAB at h`."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "**Robo**: Ich sagte `â€¦ at h`. Aber einfach nur `apply hAB` funktioniert offenbar auch.\n"
"Jetzt hast Du sozusagen `hAB` auf das Beweisziel `B` angewendet, und musst nur\n"
"noch `A` beweisen."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "**Du**: Ja, das kommt mir jetzt auch natÃ¼rlich vor."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "Diesmal scheint das Telefonat erfolgreich zu verlaufen."
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "Implikation"
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**Operationsleiter**: Das hier ist jetzt wieder ein lokales Problem."
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**Du**: Ich soll Implikationen $A \\Rightarrow B \\Rightarrow C$ zu $A \\Rightarrow C$\n"
"kombinieren?\n"
"\n"
"**Robo**: Vielleicht fÃ¤ngst du wieder mit `intro` an?"
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**Robo**: Das ist wieder eine Anwendung von `apply`."
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**Operationsleiter**: Ihr seid echt super!"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "Implikation"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "Die nÃ¤chste Seite sieht ein bisschen komplizierter aus. Damit Ihr nicht die Ãœbersicht verliert, fasst Robo sofort die verschiedenen Implikationen in einem Diagramm zusammen.\n"
"  $$\n"
"  \\begin{CD}\n"
"       A  @>{f}>> B @<{g}<< C    \\\\\n"
"    @V{h}VV    @V{i}VV   @V{j}VV \\\\\n"
"       D  @<{k}<< E @>{l}>> F    \\\\\n"
"    @A{m}AA    @A{n}AA   @V{p}VV \\\\\n"
"       G  @<{q}<< H @>{r}>> I\n"
"  \\end{CD}\n"
"  $$"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Du**: Also ich muss einen Pfad von Implikationen $A \\Rightarrow I$ finden.\n"
"\n"
"**Robo**: Lass mich mal raten, wie wir anfangen â€¦ Wieder `intro`?"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Na wieder `apply`, was sonst."
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Das sieht nach einer Sackgasse aus â€¦"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Das sieht nicht gut aus."
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Nah, da stimmt doch was nicht â€¦"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Halt! Falsch abgebogen."
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Bist du dir sicher?"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Ehm â€¦"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "Der Operationsleiter bedankt sich wieder artig. Er drÃ¼ckt wieder auf ein paar KnÃ¶pfe,\n"
"und mit einem lauten Ratteln springen mehrere FÃ¶rderbÃ¤nder gleichzeitig wieder an."
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "Genau dann, wenn"
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**Operationsleiter**: Wir hatten auch mal ein paar FÃ¶rderbÃ¤nder, die in beide Richtungen laufen\n"
"konnten. Die hatte ich vorsichtshalber alle abgestellt, weil in den neusten HandbÃ¼chern von\n"
"solchen DoppelbÃ¤ndern abgeraten wird. Aber vielleicht sind sie ja unter bestimmten\n"
"Voraussetzungen doch sicher? Was meint Ihr zu diesem Fall?"
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**Robo**: `A â†” B` ist natÃ¼rlich Leansch fÃ¼r $A \\iff B$, also genau-dann-wenn.\n"
"Die Aussage `A â†” B` besteht also aus zwei Teilen; sie ist als `âŸ¨A â†’ B, B â†’ AâŸ©` definiert.\n"
"\n"
"**Du**: Also ganz Ã¤hnlich wie das UND, `A âˆ§ B`?\n"
"\n"
"**Robo**: Genau. Entsprechend kannst du auch hier mit `constructor` anfangen."
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**Du**: Ah, und die beiden Teile habe ich schon in den Annahmen."
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**Operationsleiter**: Okay, das leuchtet mir ein.\n"
"\n"
"**Robo** *(zu dir)*: Ãœbrigens, so wie bei `(h : A âˆ§ B)` die beiden\n"
"Teile `h.left` und `h.right` heiÃŸen,\n"
"heiÃŸen bei `(h : A â†” B)` die beiden Teile `h.mp` und `h.mpr`.\n"
"\n"
"**Du**: Also `h.mp` ist `A â†’ B`? Wieso `mp`?\n"
"\n"
"**Robo**: `mp` steht fÃ¼r Modus Ponens`. Der Modus ponens ist eine schon in der antiken\n"
"Logik gelÃ¤ufige Schlussfigur, die in vielen logischen Systemen â€¦ Ach nee, das wolltest\n"
"du ja nicht hÃ¶ren. Das \"r\" in `mpr` steht fÃ¼r \"reverse\", weil's die RÃ¼ckrichtung ist."
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid "Genau dann, wenn"
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid "**Operationsleiter**: Hier ist noch so etwas."
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid "**Du**: Das ist ja nur verdreht.\n"
"\n"
"**Robo**: Ich kenne ein Werkzeug dafÃ¼r. Mit `symm` oder `symm at Â«{h}Â»` kannst du eines\n"
"der beiden umdrehen."
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid "**Operationsleiter**: Das war ja symmpel. Das nÃ¤chste Problem sieht aber schwieriger aus."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "Genau dann, wenn"
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**Operationsleiter**: Hier, kÃ¶nnt ihr dazu auch was sagen?"
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**Du**: $B \\iff A \\iff D \\iff C$, die sind doch alle Ã¤quivalentâ€¦\n"
"\n"
"**Robo**: Ja, aber du musst ihm helfen, die Ã„quivalenzen umzuschreiben. Mit `rw [hâ‚]` kannst\n"
"du `C` durch `D` ersetzen."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**Du** Und wenn ich in die andere Richtung umschreiben mÃ¶chte?\n"
"\n"
"**Robo**: Dann schreibst du ein `â†` (`\\l`, also klein \"L\") vor den Namen, also `rw [â† hâ‚“]`."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**Du**: Ehm, das war verkehrt.\n"
"\n"
"**Robo**: Ja, anders herum wÃ¤r's besser gewesen. Aber wenn du jetzt einfach weitermachst,\n"
"bis Du sowas wie `A â†” A` erhÃ¤ltst, kann `rfl` das beweisen.\n"
"\n"
"**Robo: Da fÃ¤llt mir ein, `rw` wendet ohnehin auch versuchsweise `rfl` an.\n"
"Das heiÃŸt, du musst `rfl` nicht einmal ausschreiben."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**Operationsleiter**: Wenn Ihr so weitermacht, dann kommen wir ja durch den ganzen Packen durch!"
msgstr ""

#: Game.Levels.Implis.L09_Trans
msgid "Genau dann, wenn"
msgstr ""

#: Game.Levels.Implis.L09_Trans
msgid "**Du**: Irgendwie fÃ¼hlen sich diese `rw` an, als wÃ¼rde man von hinten durch den Bauch argumentieren.  Geht das nicht auch irgendwie geradeaus, oder denken alle hier um die Ecke?\n"
"\n"
"**Robo**:  Vielleicht wÃ¼rde dir `trans' besser gefallen.  Damit kÃ¶nntest du deine Kette von Ã„quivalenzen  $B \\iff A \\iff D \\iff C$ Schritt fÃ¼r Schritt abarbeiten: als erstes fÃ¼hrst Du mit `trans A` den Zwischenschritt `B \\iff A` ein, dann mit `trans D` den nÃ¤chsten Zwischenschritt."
msgstr ""

#: Game.Levels.Implis.L09_Trans
msgid "**Robo**: Und, war das besser?\n"
"\n"
"**Du**:  WeiÃŸ nicht.  Wir kÃ¶nnen jedenfalls weitermachen."
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "Genau dann wenn"
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Operationsleiter**: Das hier ist wieder fÃ¼r meinen beschrÃ¤nkten Kollegen. Ich glaube,\n"
"`rw` mag der auch nicht. Geht das trotzdem?"
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Du**: Naja ich kann wohl immerhin mal mit `intro` anfangen â€¦\n"
"\n"
"**Robo**: â€¦ und dann schauen wir weiter!"
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Robo**: Also eine Implikation wendet man mit `apply` an â€¦\n"
"\n"
"**Du**: WeiÃŸ ich doch! Aber `Â«{h}Â»` ist keine Implikation, sondern eine Ã„quivalenz.\n"
"Da wÃ¼rde ich doch eigentlich `rw [â† Â«{h}Â»]` sagen wollen.\n"
"\n"
"**Robo**: Die Richtung `Â«{A}Â» â†’ Â«{B}Â»` von `Â«{h}Â»` heiÃŸt `Â«{h}Â».mp`. Du kannst sie\n"
"mit `apply (Â«{h}Â».mp) at â€¦` anwenden."
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Robo**: So kannst Du natÃ¼rlich auch anfangen."
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Operationsleiter**: Okay, super. Das mÃ¼sste passen.\n"
"\n"
"Er telefoniert wieder.\n"
"\n"
"**Operationsleiter**: Bingo!"
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "Genau dann wenn"
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Operationsleiter**: Ah, die nÃ¤chste Seite ist auch von diesem Kollegen.\n"
"Aber da ist noch eine Notiz bei. Wir hatten hierfÃ¼r schon einmal einen Beweis,\n"
"aber den mochte er nicht. Er wollte einen Beweis, der weder `rw` noch `apply` verwendet!!\n"
"\n"
"Er holt tief Luft und seuft.\n"
"\n"
"**Operationsleiter**: Ich glaube, der stellt sich immer viel dÃ¼mmer, als er ist.\n"
"Aber meint Ihr, Ihr schafft das?"
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Du**: Hmm, mindestens mit der Implikation kann ich anfangen."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Robo**: Genau, das war `intro`."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Du**: Also, ich kenne `rw [Â«{h}Â»]` und `apply (Â«{h}Â».mp)`, aber das wollten wir ja\n"
"diesmal vermeiden.\n"
"\n"
"**Robo**: Was du machen kÃ¶nntest, ist, mit `obtain âŸ¨mp, mprâŸ© := Â«{h}Â»` die Annahme\n"
"in zwei Teile aufteilen."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Robo**: Hier mÃ¼sstest du jetzt `rw [â†Â«{h}Â»]` oder `apply Â«{h}Â».mp` benutzen.\n"
"Geh lieber einen Schritt zurÃ¼ck, sodass das Goal `A â†’ B` ist."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Du**: Ah, und jetzt ist das Beweisziel in den Annahmen."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Operationsleiter**: Perfekt, das sollte reichen!"
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "by_cases"
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "Beim nÃ¤chsten Problem stutzt der Operationsleiter.\n"
"\n"
"**Operationsleiter**: Ehrlich gesagt weiÃŸ ich gar nicht, wo dieses Blatt herkommt. Das ist\n"
"gar nicht von mir. Sieht aber irgendwie interessant aus."
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "**Du**: Naja, eine der beiden Aussagen `A` oder `Â¬A` wird schon wahr sein.\n"
"\n"
"**Robo**: Klarer Fall fÃ¼r eine Fallunterscheidung, wÃ¼rde ich sagen. Probier\n"
"mal `by_cases h : A`."
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "**Robo**: Siehst du, jetzt hat der Beweis zwei Teile. Im ersten Teil nimmst\n"
"du an, dass `A` wahr ist. Im zweiten nimmst du an, dass `A` falsch ist."
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "Der Operationsleiter nickt zustimmend."
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "Lemmas"
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**Operationsleiter**: Wieder etwas fÃ¼r den Kollegen â€¦. Und er wollte wieder einen\n"
"Beweise ohne `apply`. Ich sehe hier auch, dass ich mir schon einmal etwas\n"
"hierzu notiert hatte. Richtig, es gibt da dieses Lemma:\n"
"```\n"
"lemma not_not (A : Prop) : Â¬Â¬A â†” A\n"
"```\n"
"\n"
"**Operationsleiter**: Schafft Ihr das damit?"
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**Robo**: Ein Lemma, das wie `not_not` ein `â†”` oder `=` im Statement hat, kann\n"
"auch mit `rw [not_not]` verwendet werden."
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**Du**: HÃ¤h, wieso hat das jetzt 2 von 3 der `Â¬Â¬` umgeschrieben?\n"
"\n"
"**Robo**: `rw` schreibt nur das erste um, das es findet, also `Â¬Â¬C`. Aber weil dieses\n"
"mehrmals vorkommt, werden die alle ersetzt â€¦\n"
"\n"
"**Du**: Ah, und `Â¬Â¬B` ist etwas anderes, also brauche ich das Lemma nochmals."
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**Du**: Wir sind schon fertig â€¦?\n"
"\n"
"**Robo**: Ja, `rw` versucht immer anschlieÃŸend `rfl` aufzurufen, und das hat hier funktioniert."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "Zusammenfassung"
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Operationsleiter**: Ihr habt mir wirklich so geholfen! Hier ist das letzte Problem.\n"
"Das habe ich von meinem VorgÃ¤nger geerbt. Er hat behauptet, wenn wir das lÃ¶sen kÃ¶nnen,\n"
"dann lÃ¤uft hier wieder alles. Aber es sah mir immer viel zu schwierig aus, um es Ã¼berhaupt\n"
"zu versuchen. Wollt Ihr es einmal probieren?\n"
"\n"
"**Du**: Klar, zeig her! Robo, kannst du mir vielleicht auch noch einmal so eine nette\n"
"Zusammenfassung anzeigen, was ich theoretisch in den letzten fÃ¼nf Minuten gelernt habe?\n"
"\n"
"**Robo**: Hier ist die Ãœbersicht:\n"
"\n"
"## Notationen / Begriffe\n"
"\n"
"|               | Beschreibung                                             |\n"
"|:--------------|:---------------------------------------------------------|\n"
"| â†’             | Eine Implikation.                                        |\n"
"| â†”             | Genau-dann-wenn / Ã„quivalenz.                            |\n"
"\n"
"## Taktiken\n"
"\n"
"|     | Taktik                    | Beispiel                                                   |\n"
"|:----|:--------------------------|:-----------------------------------------------------------|\n"
"| 8   | `intro`                   | FÃ¼r eine Implikation im Goal.                              |\n"
"| 9   | `revert`                  | Umkehrung von `intro`.                                     |\n"
"| 10  | `apply`                   | Wendet Implikation/Theorem (rÃ¼ckwÃ¤rts) auf das Goal an.    |\n"
"| 10áµ‡ | `apply at`                | Wendet Implikation/Theorem (forwÃ¤rts) auf eine Annahme an. |\n"
"| 11  | `symm`                    | Tauscht `A â†” B` zu `B â†” A`.                                |\n"
"| 12  | `trans`                   | Ã„ndert `A â†” C` zu `A â†” B` und `B â†” C`                      |\n"
"| 13  | `rw`                      | Umschreiben zweier Ã¤quivalenter Aussagen.                  |\n"
"| 13áµ‡ | `rw`                      | Benutzt ein Lemma, dessen Aussage eine Ã„quivalenz ist.     |\n"
"| 14  | `by_cases`                | Fallunterscheidung `P` und `Â¬P`                            |"
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Du** *(flÃ¼sternd)*: Ist das nicht die Definition von `â†’`?\n"
"\n"
"**Robo** *(flÃ¼sternd)*: KÃ¶nnte man so sehen. Aber auf Leansch ist das bloÃŸ eine Ã„quivalenz."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Robo**: Vielleicht kannst du wieder `by_cases` benutzen."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Robo**: Na Implikationen gehst du immer mit `intro` an."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Robo**: Ich wÃ¼rde mal die Annahme `h` mit `obtian` aufteilen."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Operationsleiter**: Das ist ja fantastisch! Tausend Dank! Dann will ich Euch auch gar\n"
"nicht lÃ¤nger aufhalten.\n"
"Ihr wollt bestimmt weiter zum Planeten Quantus, oder?\n"
"\n"
"**Du**: Ehm, vielleicht â€¦\n"
"\n"
"**Operationsleiter**: Dann habe ich noch eine letzte Bitte. Ich habe hier noch ein PÃ¤ckchen\n"
"fÃ¼r die KÃ¶nigin von Quantus! Auch schon von meinem VorgÃ¤nger geerbt. Die Post will es\n"
"nicht annehmen, weil ich die Adresse nicht weiÃŸ. KÃ¶nntet Ihr es vielleicht zu ihr mitnehmen?\n"
"\n"
"**Du**: Klar! Robo, halt mal.\n"
"\n"
"Robo nimmt das PÃ¤ckchen und lÃ¤sst es irgendwo in seinem Innern verschwinden.\n"
"Der Operationsleiter sieht ihn entgeistert an.\n"
"\n"
"**Robo**: Keine Angst, ich verdaue nichts!"
msgstr ""

#: Game.Levels.Implis
msgid "Implis"
msgstr ""

#: Game.Levels.Implis
msgid "ZurÃ¼ck im Raumschiff macht ihr euch auf den Weg zu einem benachbarten Planeten, der ebenfalls\n"
"bewohnt zu sein scheinen.\n"
"\n"
"**Du**: Ich habe immer noch das GefÃ¼hl, dass ich die Aufgabe von KÃ¶nigin *Logisinde*\n"
"ohne `tauto` nicht hÃ¤tte lÃ¶sen kÃ¶nnen.\n"
"Kamen in der Aufgabe nicht auch Implikationen vor?\n"
"\n"
"**Robo**: Vielleicht haben wir ja auf dem Planeten *Implis*, den wir gerade ansteuern,\n"
"Gelegenheit, noch etwas dazuzulernen. Festhalten bitte â€¦\n"
"\n"
"Und damit leitet Robo den Landeanflug ein.\n"
"\n"
"Implis scheint ein riesiger Tagebau zu sein.\n"
"Ãœberall verlaufen FÃ¶rderbÃ¤nder, kreuz und quer, aber die meisten stehen still.\n"
"Ein schÃ¼chterner Operationsleiter erwartet Euch bereits.\n"
"\n"
"**Operationsleiter**: Ihr kommt mir gerade recht! Ich habe schon gehÃ¶rt. Echte Mathematiker!\n"
"Wisst Ihr, wir fÃ¶rdern hier Wahrheitswerte. Und dabei muss man hÃ¶llisch aufpassen.\n"
"Ein Fehler, und alles bricht zusammen. Aber ich bin sehr vorsichtig. Ich sage immer:\n"
"Lieber Stillstand als Untergang!"
msgstr ""

#: Game
msgid "Robo"
msgstr ""

#: Game
msgid "# Game Over oder QED?\n"
"\n"
"Willkommen zu unserem Prototyp eines Lean4-Lernspiels. Hier lernst du computer-gestÃ¼tzte\n"
"BeweisfÃ¼hrung. Das Interface ist etwas vereinfacht, aber wenn du den *Editor Mode* aktivierst, fÃ¼hlt es sich\n"
"fast genauso an wie in VSCode, der Standard-IDE fÃ¼r Lean.\n"
"\n"
"Rechts siehst du eine Ãœbersicht. Das Spiel besteht aus mehreren Planeten, und jeder Planet hat mehrere Levels,\n"
"die in Form von grauen Punkten dargestellt sind. GelÃ¶ste Levels werden grÃ¼n.\n"
"\n"
"Klicke auf den ersten Planeten *Logo*, um deine Reise zu starten.\n"
"\n"
"\n"
"### More\n"
"Schau im MenÃ¼ unter \"Game Info\" fÃ¼r mehr Informationen zum Spiel."
msgstr ""

#: Game
msgid "## Spielstand\n"
"\n"
"Dein Spielstand wird lokal in deinem Browser als *site data* gespeichert.\n"
"Solltest du diese lÃ¶schen, verlierst du deinen Spielstand!\n"
"Viele Browser lÃ¶schen *site data* und *cookies* zusammen.\n"
"Wenn du \"Game rules: lax\" auswÃ¤hlst kannst aber jederzeit jedes Level spielen,\n"
"auch wenn du vorhergende Levels noch nicht gelÃ¶st hast.\n"
"\n"
"## Funding\n"
"\n"
"Dieses Lernspiel wurde und wird im Rahmen des Projekts\n"
"[ADAM: Anticipating the Digital Age of Mathematics](https://hhu-adam.github.io/)\n"
"an der Heinrich-Heine-UniversitÃ¤t DÃ¼sseldorf entwickelt.\n"
"Es wird finanziert durch das Programm *Freiraum 2022* der\n"
"*Stiftung Innovation in der Hochschullehre*.\n"
"\n"
"## Credits\n"
"\n"
"* **Creators:** Jon Eugster, Alexander Bentkamp, Marcus Zibrowius, Sina Hazratpour\n"
"* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"* **Illustrationen:** DuÅ¡an PavliÄ‡\n"
"\n"
"## Kontakt\n"
"\n"
"Das Spiel befindet sich noch in der Entwicklung.\n"
"Wenn du Anregungen hast oder Bugs findest, schreib doch ein Email oder erstelle einen\n"
"Issue auf Github:\n"
"\n"
"* zum Spielinhalt im [Robo repo](https://github.com/hhu-adam/Robo/issues).\n"
"* zum Spielserver im [lean4game repo](https://github.com/leanprover-community/lean4game/issues).\n"
"\n"
"Kontakt: [Jon Eugster](https://www.math.hhu.de/lehrstuehle-/-personen-/-ansprechpartner/innen/lehrstuehle-des-mathematischen-instituts/lehrstuhl-fuer-algebraische-geometrie/team/jon-eugster)"
msgstr ""

#: Game
msgid "Fertig!"
msgstr ""

#: Game
msgid "Erkunde das Leansche Universum mit deinem Robo, welcher dir bei der VerstÃ¤ndigung mit den Formalosophen zur Seite steht."
msgstr ""

#: Game
msgid "Dieses Spiel fÃ¼hrt die Grundlagen zur BeweisfÃ¼hrung in Lean ein und schneidet danach verschiedene Bereiche des Bachelorstudiums an.\n"
"\n"
"(Das Spiel befindet sich noch in der Entstehungsphase.)"
msgstr ""
