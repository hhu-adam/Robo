msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Fri May  3 23:56:32 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: de\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! ğŸ‰"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsâ€¦ ğŸ­"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ğŸ‰"
msgstr ""

#: Game.Doc.Definition
msgid "Eine Funktion `f` is injektiv wenn:\n"
"\n"
"```\n"
"âˆ€ a b, f a = f b â†’ a = b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "Eine Funktion `f` is surjektiv wenn:\n"
"\n"
"```\n"
"âˆ€ a, âˆƒ b, f a = b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "Eine Funktion `f` is bijectiv wenn sie injektiv und surjektiv ist."
msgstr ""

#: Game.Doc.Definition
msgid "`f` ist strikt monoton wenn\n"
"\n"
"```\n"
"âˆ€ a b, a < b â†’ f a < f b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "Anonyme Funktionen kann man mit `fun (x : â„¤) => 2 * x` definieren und\n"
"wie andere Objekte verwenden.\n"
"\n"
"Note: `=>` wird in mathlib oft auch `â†¦` (`\\\\maps`) geschrieben."
msgstr ""

#: Game.Doc.Tactic
msgid "Sind eine Annahme `h : A` und eine Implikation `hAB : A â†’ B` gegeben, so\n"
"verwandelt `apply hAB at h` die gegebene Annahme in die Annahme `h : B`.\n"
"Ist `B` unser Beweisziel, kÃ¶nnen wir mit `apply hAB` auch rÃ¼ckwÃ¤rts argumentieren und\n"
"erhalten `A` als neues Beweisziel.   In beiden FÃ¤llen kann die Implikation `hAB` wahlweise\n"
"als Annahme gegeben oder ein bereits bekanntes Lemma sein.\n"
"\n"
"\n"
"## Beispiel\n"
"\n"
"Gegeben sei fÃ¼r `n : â„•` folgendes Lemma:\n"
"```\n"
"lemma lem (h : n â‰¤ 0) : n = 0\n"
"```\n"
"\n"
"Finden wir nun als Beweisziel\n"
"\n"
"```\n"
"Goal\n"
"  n = 0\n"
"```\n"
"\n"
"vor, so Ã¤ndert `apply lem` das Beweisziel zu `n â‰¤ 0`.\n"
"\n"
"Anders herum, falls wir eine Annahme `g : m â‰¤ 0` in unseren Annahmen finden, kÃ¶nnen wir\n"
"diese mit `apply lem at g` zu `g : m = 0` umwandeln.\n"
"\n"
"(Das Lemma ist gemeinhin als `Nat.eq_zero_of_le_zero` bekannt.)"
msgstr ""

#: Game.Doc.Tactic
msgid "`assumption` sucht nach einer Annahme, die genau dem Goal entspricht.\n"
"\n"
"## Beispiel\n"
"\n"
"`assumption` sucht durch die Annahmen und merkt dass `h` genau mit dem Goal Ã¼bereinstimmt.\n"
"\n"
"```\n"
"Objekte\n"
"  a b c d : â„•\n"
"  h : a + b = c\n"
"  g : a * b = 16\n"
"  t : c = 12\n"
"Goal\n"
"  a + b = c\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`by_cases h : P` macht eine Fallunterscheidung. Im ersten Goal wird eine Annahme\n"
"`(h : P)` hinzugefÃ¼gt, im zweiten `(h : Â¬P)`.\n"
"\n"
"## Details\n"
"\n"
"`P` kann eine beliegige Aussage sein, die als entweder wahr oder falsch angenommen wird.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"example (A : Prop) : A âˆ¨ Â¬ A := by\n"
"  by_cases h : A\n"
"  Â· left\n"
"    assumption\n"
"  Â· right\n"
"    assumption\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`by_contra h` startet einen Widerspruchsbeweis.\n"
"\n"
"## Details\n"
"Sei `P` das aktuelle Goal. `by_contra h` fÃ¼gt eine neue Annahme `(h : Â¬P)` hinzu\n"
"und setzt das Goal auf `False`.\n"
"\n"
"Oft will man `by_contra` nutzen wenn das Goal von der Form `Â¬ P` ist.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `contradiction` schliesst den Widerspruchsbeweis wenn sich (zwei) Annahmen\n"
"widersprechen.\n"
"* `contrapose` fÃ¼hrt einen Beweis durch Kontraposition und ist entsprechend\n"
"in Ã¤hnlichen Situationen nutzbar wie `by_contra`"
msgstr ""

#: Game.Doc.Tactic
msgid "`change t` Ã¤ndert das Goal zu `t`. Voraussetzung ist, dass `t` und das alte Goal defEq sind.\n"
"\n"
"## Details\n"
"\n"
"Dies ist insbesonder hilfreich wenn eine Taktik nicht merkt, dass das Goal defEq ist zu einem\n"
"Term, der eigentlich gebraucht wÃ¼rde.\n"
"\n"
"## Beispiel\n"
"\n"
"Aktuelles Goal:\n"
"\n"
"```\n"
"b: â„\n"
"âŠ¢ 1 â€¢ b = b\n"
"```\n"
"Wobei die Skalarmultiplikation als `fun (a : â„š) (r : â„) => â†‘a * r` definiert war. Dann\n"
"kann man mit `change (1 : â„š) * b = b` das Goal umschreiben und anschliessend mit Lemmas\n"
"Ã¼ber die Multiplikation beweisen."
msgstr ""

#: Game.Doc.Tactic
msgid "`constructor` teilt ein Goal auf, wenn das Goal eine Struktur ist\n"
"\n"
"## Detail\n"
"Wenn das Goal eine Struktur ist, wie z.B. `A âˆ§ B` welches zwei Felder hat `âŸ¨A, BâŸ©`, dann\n"
"erzeugt `constructor` ein Goal pro Feld der Struktur.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* Das Gegenteil von `constructor` ist `âŸ¨_, _âŸ©` (`\\\\<>`), der *anonyme Konstruktor*.\n"
"Dieser enspricht ungefÃ¤hr der Tupel-Notation in\n"
"\\\"eine Gruppe ist ein Tupel $(G, 0, +)$, sodass â€¦\\\".\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"example {A B : Prop} (h : A) (g : B) : A âˆ§ B := by\n"
"  constructor\n"
"  Â· assumption\n"
"  Â· assumption\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`contradiction` schliesst den Beweis wenn es einen Widerspruch in den Annahmen findet.\n"
"\n"
"## Details\n"
"Ein Widerspruch in den Annahmen kann unter anderem folgendermassen aussehen:\n"
"\n"
"* `(h : n â‰  n)`\n"
"* `(h : A)` und `(h' : Â¬A)`\n"
"* `(h : False)` (i.e. ein Beweis von `False`)\n"
"\n"
"## Beispiel\n"
"\n"
"Folgenes Goal wird von `contradiction` bewiesen\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* Normalerweise wird `contradiction` gebraucht um einen Widerspruchsbeweis zu\n"
"  schliessen, der mit `by_contra` erÃ¶ffnet wurde.\n"
"* Ein Beweis von `False` representiert in Lean einen Widerspruch.\n"
"\n"
"```\n"
"Objekte:\n"
"  (n m : â„•)\n"
"  (h : n = m)\n"
"  (g : n â‰  m)\n"
"Goal\n"
"  37 = 60\n"
"```\n"
"nach dem Motto \\\"ein Widerspruch beweist alles.\\\""
msgstr ""

#: Game.Doc.Tactic
msgid "`contrapose` Ã¤ndert ein Goal der Form `A â†’ B` zu `Â¬B â†’ Â¬A` und fÃ¼hrt damit\n"
"eine Beweis durch Kontraposition.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `revert h` kann nÃ¼tzlich sein um eine Annahme als ImplikationsprÃ¤misse zu schreiben bevor man\n"
"  `contrapose` verwendet."
msgstr ""

#: Game.Doc.Tactic
msgid "`exact h` schliesst das Goal wenn der Term `h` mit dem Goal Ã¼bereinstimmt."
msgstr ""

#: Game.Doc.Tactic
msgid "`fin_cases i` fÃ¼hrt eine Fallunterscheidung wenn `i` ein endlicher Typ ist.\n"
"\n"
"## Details\n"
"`fin_cases i` ist insbesondere nÃ¼tzlich fÃ¼r `(i : Fin n)`, zum Beispiel als Index in\n"
"endlich dimensionalen VektorrÃ¤umen.\n"
"\n"
"In diesem Fall bewirkt `fin_cases i` dass man Komponentenweise arbeitet."
msgstr ""

#: Game.Doc.Tactic
msgid "`funext x` wird bei Gleichungen von Funktionen `f = g` gebraucht. Das Goal wird zu\n"
"`f x = g x`.\n"
"\n"
"## Details\n"
"Nach dem Motto `f = g â†” âˆ€ x, f x = g x` sind zwei Funktionen dann identisch, wenn sie\n"
"angewendet auf jedes Element identisch sind. `funext x` benutzt dieses Argument."
msgstr ""

#: Game.Doc.Tactic
msgid "`have h : P` fÃ¼hrt ein Zwischenresultat ein.\n"
"\n"
"## Details\n"
"Anschliessend muss man zuerst dieses Zwischenresultat beweisen bevor man mit dem Beweis\n"
"weitermachen und das Zwischenresultat verwenden kann.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `suffices h : P` funktioniert genau gleich, auÃŸer dass die beiden entstehenden Beweise\n"
"  vertauscht sind.\n"
"* `let h : Prop := A âˆ§ B` ist verwandt mit `have`, mit Unterschied, dass man mit `let`\n"
"  eine temporÃ¤re Definition einfÃ¼hrt."
msgstr ""

#: Game.Doc.Tactic
msgid "`induction n` fÃ¼hrt einen Induktionsbeweis Ã¼ber `n`.\n"
"\n"
"## Detail\n"
"\n"
"Diese Taktik erstellt zwei Goals:\n"
"* Induktionsanfang, wo `n = 0` ersetzt wird.\n"
"* Induktionsschritt, in dem man die Induktionshypothese `n_ih` zur VerfÃ¼gung hat.\n"
"\n"
"## Modifikationen in diesem Spiel\n"
"\n"
"* `induction n with d hd` benennt Induktionsvariable und -hypothese. (das ist Lean3-Syntax)\n"
"und funktioniert auÃŸerhalb vom Spiel nicht genau so.\n"
"* AuÃŸerhalb des Spiels kriegst du `Nat.zero` und `Nat.succ n` anstatt `0` und `n + 1`\n"
"als FÃ¤lle. Diese\n"
"Terme sind DefEq, aber manchmal benÃ¶tigt man die lemmas `zero_eq` und `Nat.succ_eq_add_one`\n"
"um zwischen den schreibweisen zu wechseln\n"
"\n"
"Der richtige Lean4-Syntax fÃ¼r `with` streckt sich Ã¼ber mehrere Zeilen und ist:\n"
"\n"
"```\n"
"induction n with\n"
"| zero =>\n"
"  sorry\n"
"| succ m m_ih =>\n"
"  sorry\n"
"```\n"
"\n"
"da dieser sich Ã¼ber mehrere Zeilen erstreckt wird er im Spiel nicht eingefÃ¼hrt.\n"
"\n"
"## Hifreiche Resultate\n"
"\n"
"* `Nat.succ_eq_add_one`: schreibt `n.succ = n + 1` um.\n"
"* `Nat.zero_eq`: schreibt `Nat.zero = 0` um.\n"
"\n"
"Beide sind DefEq, aber manche Taktiken kÃ¶nnen nicht damit umgehen\n"
"\n"
"* Siehe Definition `âˆ‘` fÃ¼r Hilfe mit Induktion Ã¼ber Summen.\n"
"* `rcases n` ist sehr Ã¤hnlich zu `induction n`. Der Unterschied ist, dass bei\n"
"`rcases` keine Induktionshypothese im Fall `n + 1` zur VerfÃ¼gung steht.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"example (n : â„•) : 4 âˆ£ 5^n + 7 := by\n"
"  induction n\n"
"  sorry      -- Fall `n = 0`\n"
"  sorry      -- Fall `n + 1`\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`intro x` wird fÃ¼r Goals der Form `A â†’ B` oder `âˆ€ x, P x` verwendet.\n"
"Dadurch wird die ImplikationsprÃ¤misse (oder das Objekt `x`) den Annahmen hinzugefÃ¼gt.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `revert h` macht das Gegenteil von `intro`."
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn das Goal von der Form `A âˆ¨ B` ist, enscheidet man mit `left` die linke Seite zu zeigen.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `right` entscheidet sich fÃ¼r die linke Seite."
msgstr ""

#: Game.Doc.Tactic
msgid "`let x : â„• := 5 ^ 2` fÃ¼hrt eine neue temporÃ¤re Definition ein.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `have x : â„• := 5 ^ 2` fÃ¼hrt ebenfalls eine neue natÃ¼rliche Zahle `x` ein, aber\n"
"  Lean vergisst sofort, wie die Zahl definiert war. D.h. `x = 25` wÃ¤re dann nicht\n"
"  beweisbar. Mit `let x : â„• := 5 ^ 2` ist `x = 25` durch `rfl` beweisbar."
msgstr ""

#: Game.Doc.Tactic
msgid "`linarith` lÃ¶st Systeme linearer (Un-)Gleichungen.\n"
"\n"
"## Detail\n"
"`linarith` kann lineare Gleichungen und Ungleichungen beweisen indem\n"
"es das Gegenteil vom Goal annimmt und versucht einen Widerspruch in den\n"
"Annahmen zu erzeugen (Widerspruchsbeweis). Es braucht ein `â‰¤` definiert um\n"
"zu funktionieren.\n"
"\n"
"## Beispiel\n"
"\n"
"Folgendes kann `linarith` beweisen.\n"
"```\n"
"Objekte\n"
"  x y : â„¤\n"
"  hâ‚ : 5 * y â‰¤ 35 - 2 * x\n"
"  hâ‚‚ : 2 * y â‰¤ x + 3\n"
"Goal\n"
"  y â‰¤ 5\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`push_neg` schreibt `Â¬âˆ€ x, _` zu `âˆƒ x, Â¬ _` und `Â¬âˆƒ x, _` zu `âˆ€x, Â¬ _` um.\n"
"\n"
"## Details\n"
"\n"
"`push_neg` schiebt das `Â¬` soweit nach innen wie mÃ¶glich.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* Die beiden Lemmas heissen `not_forall` und `not_exists` und kÃ¶nnen mit `rw` einzeln angewendet\n"
"  werden."
msgstr ""

#: Game.Doc.Tactic
msgid "`rcases h` teilt eine Annahme `h` in ihre Einzelteile auf.\n"
"\n"
"## Details\n"
"FÃ¼r Annahmen die Strukturen sind, wie z.B. `h : A âˆ§ B` (oder `âˆƒx, P x`) kann man die\n"
"Einzelteile mit  `rcases h with âŸ¨a, bâŸ©` (oder `rcases h with âŸ¨x, hxâŸ©`) benennen.\n"
"\n"
"FÃ¼r eine Annahme der Form `h : A âˆ¨ B` kann man mit `rcases h with ha | hb` zwei Goals\n"
"erzeugen, einmal unter Annahme der linken Seite, einmal unter Annahme der Rechten.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* FÃ¼r `n : â„•` hat `rcases n` einen Ã¤hnlichen Effekt wie `induction n` mit dem Unterschied,\n"
"  dass im Fall `n + 1` keine Induktionshypothese zur VerfÃ¼gung steht.\n"
"* In Lean gibt es auch die Taktik `cases`, die gleich funktioniert wie `rcases` aber\n"
"  einen mehrzeiligen Syntax hat:\n"
"  ```\n"
"  cases h with\n"
"  | inl ha =>\n"
"    sorry\n"
"  | inr hb =>\n"
"    sorry\n"
"  ```\n"
"  Hier sind `inl`/`inr` die Namen der FÃ¤lle und `ha`/`hb` sind frei gewÃ¤hlte Namen fÃ¼r die\n"
"  freien Variablen"
msgstr ""

#: Game.Doc.Tactic
msgid "`refine { ?..! }` wird benÃ¶tigt um eine Struktur (z.B. ein $R$-Modul) im Taktikmodus in einzelne\n"
"Goals aufzuteilen. Danach hat man ein Goal pro Strukturfeld.\n"
"\n"
"(*Bemerkung*: Es gibt in Lean verschiedenste bessere Varianten dies zu erreichen,\n"
"z.B. \\\"Term Modus\\\" oder \\\"anonyme Konstruktoren\\\", aber fÃ¼r den Zweck des Spieles bleiben wir\n"
"bei diesem Syntax.)"
msgstr ""

#: Game.Doc.Tactic
msgid "`revert h` fÃ¼gt die Annahme `h` als ImplikationsprÃ¤misse vorne ans Goal an.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `revert` ist das Gegenteil von `intro`.\n"
"* `revert` kann insbesondere nÃ¼tzlich sein, um anschliessend `contrapose` zu verwenden.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Objekte\n"
"  A P : Prop\n"
"  h : P\n"
"Goal\n"
"  A\n"
"```\n"
"\n"
"hier Ã¤ndert `revert h` den Status zu\n"
"\n"
"```\n"
"Objekte\n"
"  A P : Prop\n"
"Goal\n"
"  P â†’ A\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`rfl` beweist ein Goal der Form `X = X`.\n"
"\n"
"## Detail\n"
"\n"
"`rfl` beweist jedes Goal `A = B` wenn `A` und `B` per Definition das gleiche sind (DefEq).\n"
"Andere Taktiken rufen `rfl` oft am Ende versteckt\n"
"automatisch auf um zu versuchen, den Beweis zu schliessen.\n"
"\n"
"\n"
"## Beispiel\n"
"`rfl` kann folgende Goals beweisen:\n"
"\n"
"```\n"
"Objekte\n"
"  a b c : â„•\n"
"Goal:\n"
"  (a + b) * c = (a + b) * c\n"
"```\n"
"\n"
"```\n"
"Objekte\n"
"  n : â„•\n"
"Goal\n"
"  1 + 1 = 2\n"
"```\n"
"denn Lean liest dies intern als `0.succ.succ = 0.succ.succ`."
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn das Goal von der Form `A âˆ¨ B` ist, enscheidet man mit `right` die rechte Seite zu zeigen.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `left` entscheidet sich fÃ¼r die linke Seite."
msgstr ""

#: Game.Doc.Tactic
msgid "LÃ¶st Gleichungen mit den Operationen `+, -, *, ^`.\n"
"\n"
"## Details\n"
"Insbesondere funktioniert `ring` in Ringen/Semiringen wie z.B. `â„•, â„¤, â„š, â€¦`\n"
"(i.e. Typen `R` mit Instanzen `Ring R` oder `Semiring R`).\n"
"Die Taktik ist besonders auf kommutative Ringe (`CommRing R`) ausgelegt.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `ring` kann nicht wirklich mit Division (`/`) oder Inversen (`â»Â¹`) umgehen. DafÃ¼r ist die\n"
"  Taktik `field_simp` gedacht, und die typische Sequenz ist\n"
"  ```\n"
"  field_simp\n"
"  ring\n"
"  ```"
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn man eine Annahme `(h : X = Y)` hat, kann man mit\n"
"`rw [h]` alle `X` im Goal durch `Y` ersetzen.\n"
"\n"
"## Details\n"
"\n"
"* `rw [â†h]` wendet `h` rÃ¼ckwÃ¤rts an und ersetzt alle `Y` durch `X`.\n"
"* `rw [h, g, â†f]`: Man kann auch mehrere `rw` zusammenfassen.\n"
"* `rw [h] at hâ‚‚` ersetzt alle `X` in `hâ‚‚` zu `Y` (anstatt im Goal).\n"
"\n"
"`rw` funktioniert gleichermassen mit Annahmen `(h : X = Y)` also auch\n"
"mit Theoremen/Lemmas der Form `X = Y`"
msgstr ""

#: Game.Doc.Tactic
msgid "`simp` versucht alle Vereinfachungslemmas anzuwenden, die in der `mathlib` mit `@[simp]`\n"
"gekennzeichnet sind.\n"
"\n"
"## Details\n"
"\n"
"* `simp?` zeigt welche Lemmas verwendet wurden.\n"
"* `simp [my_lemma]` fÃ¼gt zudem `my_lemma` temporÃ¤r zur Menge der `simp`-Lemmas hinzu.\n"
"* ein `simp`, das nicht am Ende des Beweis steht sollte durch eine entsprechende\n"
"  `simp only [...]` Aussage ersetzt werden, um den Beweis stabiler zu machen."
msgstr ""

#: Game.Doc.Tactic
msgid "`simp_rw [hâ‚, hâ‚‚, hâ‚ƒ]` versucht wie `rw` jedes Lemma der Reihe nach zu Umschreiben zu verwenden,\n"
"verwendet aber jedes Lemma so oft es kann.\n"
"\n"
"## Details\n"
"\n"
"Es bestehen aber drei grosse Unterschiede zu `rw`:\n"
"\n"
"* `simp_rw` wendet jedes Lemma so oft an wie es nur kann.\n"
"* `simp_rw` kann besser unter Quantifiern umschreiben als `rw`.\n"
"* `simp_rw` fÃ¼hrt nach jedem Schritt ein `simp only []` aus und vereinfacht dadurch grundlegenste\n"
"  Sachen."
msgstr ""

#: Game.Doc.Tactic
msgid "`suffices h : P` fÃ¼hrt ein neues Zwischenresultat ein, aus dem das Goal direkt folgen soll.\n"
"\n"
"## Details\n"
"\n"
"Der einzige Unterschied zu `have h : P` ist, dass die beiden resultierenden Goals vertauscht sind.\n"
"\n"
"Mathematisch braucht man diese in ein bisschen unterschiedlichen FÃ¤llen:\n"
"\n"
"* `suffices h : P` : \\\"Es genÃ¼gt zu zeigen, dass â€¦\\\". Als erstes folgt die ErklÃ¤rung wieso\n"
"  das genÃ¼gt, danach muss man nur noch `P` beweisen.\n"
"* `have h : P` : Ein (kleines) Zwischenresultat. Als erstes folgt dann der Beweis dieses\n"
"Resultats, anschliessend setzt man den Beweis mit Hilfe des Zwischenresultats fort."
msgstr ""

#: Game.Doc.Tactic
msgid "`symm` (fÃ¼r \"symmetry\") kann Gleichheiten oder `â†”` umdrehen. `symm at h` dreht eine Gleichheit\n"
"(oder `â†”`) in der Annahme `h`.\n"
"\n"
"## Details\n"
"\n"
"Man kann auch `h.symm` fÃ¼r die gedrehte Annahme schreiben, wenn man diese irgendwo\n"
"verwendet. Das verwendet intern die Lemmata\n"
"`Eq.symm` oder `Iff.symm`.\n"
"\n"
"## Beispiel\n"
"\n"
"ist das Goal `x = y`, dann wandelt es `symm` in `y = x` um. Analog, wandelt `symm at h` die Annahme\n"
"`(h : z = w)` in `(h : w = z)` um."
msgstr ""

#: Game.Doc.Tactic
msgid "`trivial` versucht durch Kombination von wenigen simplen Taktiken das Goal zu schliessen.\n"
"\n"
"## Details\n"
"Die Taktiken, die verwendet werden sind:\n"
"\n"
"* `assumption`\n"
"* `rfl`\n"
"* `contradiction`\n"
"* und noch 3 andere, die hier nicht behandelt werden\n"
"  (`decide`, `apply True.intro`, `apply And.intro`)."
msgstr ""

#: Game.Doc.Tactic
msgid "`unfold myDef` Ã¶ffnet eine Definition im Goal.\n"
"\n"
"## Details\n"
"Bis auf DefEq (definitinal equality) Ã¤ndert `unfold` nichts, manche Taktiken\n"
"(z.B. `push_neg`, `rw`) brauchen aber manchmal die Hilfe.\n"
"\n"
"`unfold myDef at h` kann auch Definitionen in Annahmen Ã¶ffnen\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `change P` ist eine andere Taktik, die das aktuelle Goal in einen DefEq-Ausdruck umschreibt.\n"
"  Diese Taktik braucht man auch manchmal um zu hacken, wenn Lean MÃ¼he hat etwas zu verstehen."
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn das Goal von der Form `âˆƒx, P x` ist, kann man mit `use n` ein konkretes Element angeben\n"
"mit dem man das Goal beweisen mÃ¶chte.\n"
"\n"
"## Details\n"
"\n"
"`use n` versucht zudem anschliessend `rfl` aufzurufen, und kann das Goal damit manchmal direkt\n"
"schlieÃŸen."
msgstr ""

#: Game.Levels.Function.L01_Function
msgid "Anonyme Funktionen"
msgstr ""

#: Game.Levels.Function.L01_Function
msgid "Auf die Frage hin, ob sie von einer Bibliothek wisse, erzÃ¤hlt euch das kleine MÃ¤dchen,\n"
"dass es auf der Insel nur eine gÃ¤be, aber sie bedrÃ¤ngt euch so mit einer Frage,\n"
"dass sie euch gar nicht sagt, wo dieser zu finden sei."
msgstr ""

#: Game.Levels.Function.L01_Function
msgid "**Robo**: `f : â„¤ â†’ â„¤` ist die Notation fÃ¼r eine Funktion und `f x` ist diese Funktion\n"
"angewendet auf ein Element `(x : â„¤)`.\n"
"\n"
"**Du**: War `â†’` nicht eben noch eine Implikation?\n"
"\n"
"**Robo**: Doch, die brauchen das gleiche Zeichen fÃ¼r beides.\n"
"\n"
"**Du**: Dann ist `f : â„¤ â†’ â„¤` also einfach abstrakt irgendeine Funktion,\n"
"wie definiere ich aber jetzt konkret eine Abbildungsvorschrift?\n"
"\n"
"**Robo**: Man kennt hier eine Notation fÃ¼r eine anonyme Funktion:\n"
"`fun (x : â„¤) â†¦ x ^ 2` ist\n"
"\n"
"$$\n"
"\\begin{aligned}\n"
"f : \\mathbb{â„¤} &\\to \\mathbb{â„¤} \\\\\n"
"x &\\mapsto x ^ 2\n"
"\\end{aligned}\n"
"$$\n"
"\n"
"**Robo**: PS, `â†¦` ist `\\mapsto`. Aber man kann auch stattdessen `=>` benutzen."
msgstr ""

#: Game.Levels.Function.L01_Function
msgid "**Du**: Ja aber was mach ich damit?\n"
"\n"
"**Robo**: Wie immer gehst du ein `âˆƒ` mit `use â€¦` an."
msgstr ""

#: Game.Levels.Function.L01_Function
msgid "**Du**: Zu was sich das wohl vereinfacht?"
msgstr ""

#: Game.Levels.Function.L01_Function
msgid "**Du**: Zu was sich das wohl vereinfacht?"
msgstr ""

#: Game.Levels.Function.L01_Function
msgid "Das MÃ¤dchen wird kurz ruhig, dann beginnt es zu lÃ¤cheln und zeigt strahlend\n"
"in eine Richtung. Ihr folgt ihrem Finger und euch fÃ¤llt in weiter ferne eine pompÃ¶se Struktur\n"
"auf einem flachen HÃ¼gel auf."
msgstr ""

#: Game.Levels.Function.L02_Let
msgid "let"
msgstr ""

#: Game.Levels.Function.L02_Let
msgid "Ihr macht euch auf in Richtung Bibliothek entlang kleiner Pfade zwischen verschiedensten Behausungen.\n"
"\n"
"**Du**: Sag mal, ich weiÃŸ jetzt dass ich eine Funktion als `fun x â†¦ x - 1` definieren kann,\n"
"aber wie kann ich ihr einen Namen geben?\n"
"\n"
"**Robo**: Wenn jemand hier lokal eine Funktion definiert, werden die dir\n"
"`f : â„¤ â†’ â„¤ := fun x â†¦ x - 1; â€¦` als Objekt mitgeben.\n"
"\n"
"**Robo**: Im Beweis hingegen, kannst du dir mit `let f := fun (x : â„¤) â†¦ x - 1` selbst eine\n"
"temporÃ¤re Definition machen."
msgstr ""

#: Game.Levels.Function.L02_Let
msgid "**Du**: Ist `g âˆ˜ Â«{f}Â»` Komposition von Funktionen?\n"
"\n"
"**Robo**: Richtig! Das schreibt man mit `\\comp`.\n"
"\n"
"**Du** Und hier kÃ¶nnte ich also zuerst\n"
"`let g := fun (x : â„¤) â†¦ _` definieren, anstatt direkt\n"
"`use fun (x : â„¤) â†¦ _`?\n"
"\n"
"**Robo**: Genau! Das ist zwar praktisch das gleiche, aber kann manchmal nÃ¼tzlich sein."
msgstr ""

#: Game.Levels.Function.L02_Let
msgid "**Robo**: `((fun (x : â„¤) â†¦ x - 3) âˆ˜ f) x` ist per Definition `(fun (x : â„¤) â†¦ x - 3) (f x)`,\n"
"aber mit `rw [comp_apply]` kann man das explizit umschreiben, aber `simp` kennt das\n"
"Lemma auch."
msgstr ""

#: Game.Levels.Function.L02_Let
msgid "**Robo**: gute Wahl! Jetzt kannst du diese mit `use g` benutzen."
msgstr ""

#: Game.Levels.Function.L02_Let
msgid "**Robo**: `(Â«{g}Â» âˆ˜ f) x` ist per Definition `Â«{g}Â» (f x)`, aber mit\n"
"`rw [comp_apply]` kann man das explizit umschreiben, aber `simp` kennt das\n"
"Lemma auch."
msgstr ""

#: Game.Levels.Function.L02_Let
msgid "**Robo**: Das sieht nach einem Fall fÃ¼r `ring` aus."
msgstr ""

#: Game.Levels.Function.L02_Let
msgid "**Robo**: `ring` sieht durch lokale Definitionen wie\n"
"`Â«{f}Â»` und `Â«{g}Â»` hindurch,\n"
"du kannst es also direkt benutzen."
msgstr ""

#: Game.Levels.Function.L02_Let
msgid "Sagt dass `(f âˆ˜ g) x` das gleiche ist wie `f (g x)`."
msgstr ""

#: Game.Levels.Function.L02_Let
msgid "**Du**: Dann verstehst du etwas Mathe?\n"
"\n"
"**Robo**: Ich hatte ja keine Ahnung ob die generierte Aufgabe beweisbar istâ€¦ aber offenbar\n"
"hatte ich GlÃ¼ck.\n"
"\n"
"Und damit erreicht ihr den HÃ¼gel mit der Bibliothek."
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "StÃ¼ckweise Definition"
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "Endlich kommt ihr zur Bibliothek. Komischerweise stehen an der TÃ¼r\n"
"zwei WÃ¤chtern. Der eine hat ein `f` auf seiner Brustplatte, der andere\n"
"ein `g` eingraviert. dieser gibt dir ein Blatt mit einer langen Zeilen am oberen Ende."
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "**Robo**: Schau mal, die beiden haben zwei Funktionen, eine davon mit stÃ¼ckweiser Definition.\n"
"\n"
"**Du**: Also, ich soll zeigen, dass die beiden vertauschbar sind?\n"
"\n"
"**Robo**: Genau, am besten wÃ¤hlst du mit `funext x` ein beliebiges Element aus, und zeigst das\n"
"dann fÃ¼r dieses."
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "**Du**: Ah und jetzt kann ich erst einmal `(g âˆ˜ f) Â«{x}Â»` zu `g (f Â«{x}Â»)` umschreiben?\n"
"\n"
"**Robo**: Mit `simp` klappt das."
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "**Robo**: Jetzt kannst du nÃ¤mlich eine Fallunterscheidung\n"
"machen, `by_cases h : 0 â‰¤ Â«{x}Â»`.\n"
"\n"
"**Du**: Damit krieg ich die FÃ¤lle `0 â‰¤ Â«{x}Â»` und `Â«{x}Â» < 0`?\n"
"\n"
"**Robo**: Genau! Oder prÃ¤ziser `0 â‰¤ Â«{x}Â»` und `Â¬(0 â‰¤ Â«{x}Â»)`. Das ist nicht ganz das gleiche,\n"
"und man kÃ¶nnte mit dem Lemma `not_le` zwischen `Â¬(0 â‰¤ Â«{x}Â»)` und `0 > Â«{x}Â»` wechseln."
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "**Du**: Jetzt muss ich wohl doch mal die Definitionen brauchen.\n"
"\n"
"**Robo**: Dann brauch mal `simp [f, g]`!"
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "**Robo**: Jetzt hast du `rw [if_pos Â«{h}Â»]` zur VerfÃ¼gung um das if-then-else zu\n"
"reduzieren."
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "**Robo**: Nochmals `simp [f, g]`."
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "**Du**: Ah und die Verneinung von `if_pos` ist sicher â€¦"
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "**Robo**: `if_neg`, genau!"
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "Zufrieden tauschen die beiden WÃ¤chter ihren Platz und geben so dabei den\n"
"Durchgang frei."
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "Wenn `h : A` ein beweis der Aussage `A` ist, dann reduziert\n"
"`rw [if_pos h]` reduziert eine Aussage `if A then B else C` zu `B`.\n"
"\n"
"Umgekehrt kann man `if_neg` verwenden wenn `h : Â¬ A`."
msgstr ""

#: Game.Levels.Function.L03_Piecewise
msgid "Wenn `h : Â¬ A` ein Beweis ist, dass Aussage `A` falsch ist, dann reduziert\n"
"`rw [if_neg h]` eine Aussage `if A then B else C` zu `C`.\n"
"\n"
"Umgekehrt kann man `if_pos` verwenden wenn `h : A`."
msgstr ""

#: Game.Levels.Function.L04_Surjective
msgid "Surjektive"
msgstr ""

#: Game.Levels.Function.L04_Surjective
msgid "Endlich kommt ihr in einen groÃŸe, beleuchteten zentralen Raum.\n"
"Alle WÃ¤nde sind voll mit BÃ¼chern und\n"
"in der Mitte sitzt an einem einsamen\n"
"Tisch ein Gelehrter, der tatsÃ¤chlich das gesuchte Buch zeigen kann.\n"
"\n"
"Bevor er dieses aushÃ¤ndigt, will er aber folgendes wissen:"
msgstr ""

#: Game.Levels.Function.L04_Surjective
msgid "**Robo**: Die Definition von `Surjective f` ist `âˆ€ y, (âˆƒ x, f x = y)`.\n"
"\n"
"**Du**: Dann kann ich das auch einfach wie Quantifier behandeln?\n"
"\n"
"**Robo**: SchieÃŸ drauf los!"
msgstr ""

#: Game.Levels.Function.L04_Surjective
msgid "**Du**: das is doch eigentlich ganz einfachâ€¦ Kann man das denn\n"
"noch weiter vereinfachen?\n"
"\n"
"**Robo**: Wenn du `Â«{f}Â»` auch einsetzt vermutlich schon."
msgstr ""

#: Game.Levels.Function.L04_Surjective
msgid "Der Gelehrte hÃ¤ndigt euch schmunzelnd das Buch aus."
msgstr ""

#: Game.Levels.Function.L05_Surjective
msgid "Semiconjugate"
msgstr ""

#: Game.Levels.Function.L05_Surjective
msgid ""
msgstr ""

#: Game.Levels.Function.L05_Surjective
msgid "Induktion Ã¼ber `Â«{n}Â»`"
msgstr ""

#: Game.Levels.Function.L05_Surjective
msgid "**Robo**: Siehst du die Annahme `Â«{hs}Â» : f âˆ˜ g = succ âˆ˜ f`?\n"
"\n"
"**Du**: Ja.\n"
"\n"
"**Robo**: Um eine Gleichheit von Funktionen zu verwenden, willst du\n"
"oft `apply congr_fun at Â«{hs}Â»` sagen! Das wandelt die Gleichung\n"
"`fâ‚ = fâ‚‚` in `âˆ€ x, fâ‚ x = fâ‚‚ x` um."
msgstr ""

#: Game.Levels.Function.L05_Surjective
msgid "`simp_rw [comp_apply] at Â«{hs}Â»` hilft damit du `Â«{hs}Â»` mit `rw`\n"
"verwenden kannst."
msgstr ""

#: Game.Levels.Function.L06_SurjectiveRange
msgid "Range of Surjection"
msgstr ""

#: Game.Levels.Function.L06_SurjectiveRange
msgid "The range of a function is the set of all outputs.\n"
"\n"
"In this level you show that a function is surjective if and only if the range of\n"
"the function is equal to the universal subset of the codomain. For `f : A â†’ B`,\n"
"the range of `f` is defined as\n"
"\n"
"```\n"
"range f : Set B := {b | âˆƒ a, f a = b}\n"
"```"
msgstr ""

#: Game.Levels.Function.L06_SurjectiveRange
msgid "**Du**: Wie zeigt man denn schon wieder Gleichheit von Mengen?"
msgstr ""

#: Game.Levels.Function.L06_SurjectiveRange
msgid "**Robo**: Ich habe ein relevantes Resultat gefunden: `Set.mem_range`.\n"
"Such das mal in denem Inventar!"
msgstr ""

#: Game.Levels.Function.L07_Section
msgid "Section"
msgstr ""

#: Game.Levels.Function.L07_Section
msgid "A function `g : B â†’ A` is a right inverse of a function `f : A â†’ B` if for all `a : A`, `f (g a) = a`.\n"
"\n"
"In this level, you will prove that if `g` is a right inverse of `f`, then the composition `f âˆ˜ g` is the identity function on `B`."
msgstr ""

#: Game.Levels.Function.L08_Section
msgid "Section"
msgstr ""

#: Game.Levels.Function.L08_Section
msgid "A function `g : B â†’ A` is a right inverse of a function `f : A â†’ B` if `f âˆ˜ g = id`."
msgstr ""

#: Game.Levels.Function.L09_Section
msgid "Section"
msgstr ""

#: Game.Levels.Function.L09_Section
msgid "We say `f : A â†’ B` has a right inverse if there exists a function `g : B â†’ A` such that `f âˆ˜ g = id`."
msgstr ""

#: Game.Levels.Function.L10_Section
msgid "Range of Surjection"
msgstr ""

#: Game.Levels.Function.L10_Section
msgid "The preimage of set `S` under a function `f`, denoted by `f â»Â¹' S` is the set of all elements\n"
"`x` in the domain of `f` such that `f x` is in `S`.\n"
"\n"
"```\n"
"f â»Â¹' S = {x | f x âˆˆ S}\n"
"```\n"
"\n"
"We call the preimage `f â»Â¹' { b }` of the singleton `{ b }` the fiber of `b`.\n"
"\n"
"The theorem `surjective_iff_hasRightInverse` says that a function `f : A â†’ B` is\n"
"surjective if and only if it has a right inverse. In this level, you will prove\n"
"a closely related statement: that a function with nonempty fibers has a right inverse."
msgstr ""

#: Game.Levels.Function.L10_Section
msgid "..."
msgstr ""

#: Game.Levels.Function.L10_Section
msgid "..."
msgstr ""

#: Game.Levels.Function.L10_Section
msgid "Since we know that for each `b : B`, the fiber is nonempty, we can choose some element of that fibre using the axiom of choice.\n"
"The tactic `choose g hg using nonempty_fibre` creates a function which chooses an `a : A` and `hg` witnesses that `a` is in the fiber of `b`."
msgstr ""

#: Game.Levels.Function.L11_SurjectiveTFAE
msgid "Range of Surjection"
msgstr ""

#: Game.Levels.Function.L11_SurjectiveTFAE
msgid "The preimage of set `S` under a function `f`, denoted by `f â»Â¹' S` is the set of all elements\n"
"`x` in the domain of `f` such that `f x` is in `S`.\n"
"\n"
"```\n"
"f â»Â¹' S = {x | f x âˆˆ S}\n"
"```\n"
"\n"
"`HasRightInverse.surjective`"
msgstr ""

#: Game.Levels.Function.L12_Injective
msgid "InjektivitÃ¤t"
msgstr ""

#: Game.Levels.Function.L12_Injective
msgid "Ihr lÃ¤uft durch verschiedenste GÃ¤nge der Bibliothek, allesamt mit BÃ¼chern entlang der WÃ¤nde.\n"
"\n"
"**Du**: Wenn wir wÃ¼ssten, dass nur ein mÃ¶glicher Weg hierhin fÃ¼hrt, kÃ¶nnten wir\n"
"ausschliessen, dass wir im Kreis laufen.\n"
"\n"
"PlÃ¶tzlich begegnet ihr einem Ã¤lteren Wesen mit Fakel. Auf die Frage antwortet es mit folgendem:"
msgstr ""

#: Game.Levels.Function.L12_Injective
msgid "**Robo**: `Injective` ist als `âˆ€ {a b : U}, f a = f b â†’ a = b`\n"
"definiert, also kannst du mit `intro` anfangen.\n"
"\n"
"**Du**: Und wenn ich das nicht weiss?\n"
"\n"
"**Robo**: Dann schaust du mit `unfold Injective` in die Definition rein."
msgstr ""

#: Game.Levels.Function.L12_Injective
msgid "**Du**: Jetzt will ich wohl mit der Definition von `Â«{f}Â»` die\n"
"Annahme `Â«{ha}Â»` vereinfachen."
msgstr ""

#: Game.Levels.Function.L12_Injective
msgid "**Du** Woa das war ja einfach!"
msgstr ""

#: Game.Levels.Function.L13_Injective
msgid "Nicht Injektiv"
msgstr ""

#: Game.Levels.Function.L13_Injective
msgid "Weiterirrend kommt ihr an eine Verzweigung.\n"
"\n"
"**Robo**: Sieht beides gleich aus.\n"
"\n"
"Ein paar Schritte in den linken Korridor hinein seht ihr auf dem Boden ein Blatt mit Gekritzel.\n"
"\n"
"\n"
"**Du**: Hier haben wir wieder eine stÃ¼ckweise Funktion\n"
"\n"
"$$\n"
"f(n) = \\begin{cases}\n"
"    n^2 & \\text{falls } n \\text{ gerade} \\\\\n"
"    n+1 & \\text{andernfalls.}\n"
"\\end{cases}\n"
"$$\n"
"\n"
"Darunter steht in leicht leuchtender Schrift:"
msgstr ""

#: Game.Levels.Function.L13_Injective
msgid "**Robo**: Das ist sicher ein Hinweis.\n"
"\n"
"**Du**: Aber `Â¬ Injective` sagt mir nichtsâ€¦\n"
"\n"
"**Robo**: KÃ¶nntest du etwas mit `Â¬ âˆ€` anfangen? Dann kÃ¶nntest du ja `Injektive` zuerst Ã¶ffnen.\n"
"\n"
"**Du**: DarÃ¼ber haben wir doch mal was gelerntâ€¦"
msgstr ""

#: Game.Levels.Function.L13_Injective
msgid "**Robo**: Das war `push_neg`."
msgstr ""

#: Game.Levels.Function.L13_Injective
msgid "**Robo**: Das war `push_neg`."
msgstr ""

#: Game.Levels.Function.L13_Injective
msgid "**Du** Jetzt muss ich einfach ein Gegenbeispiel nennen, oder?\n"
"\n"
"**Robo** Genau! Welche beiden Zahlen mÃ¶chtest du denn verwenden?"
msgstr ""

#: Game.Levels.Function.L13_Injective
msgid "Als ihr das Problem gelÃ¶st habt, erschleicht euch ein starkes\n"
"GefÃ¼hl, dass dies der falsche Weg ist.\n"
"Also geht ihr zurÃ¼ck und nehmt die rechte Gabelung."
msgstr ""

#: Game.Levels.Function.L14_InjectiveRange
msgid "Range of Injective"
msgstr ""

#: Game.Levels.Function.L14_InjectiveRange
msgid "For an injective function `f : A â†’ B` the fibres of the elements in the range\n"
"are singletons."
msgstr ""

#: Game.Levels.Function.L15_Injective
msgid "Monotone Funktionen"
msgstr ""

#: Game.Levels.Function.L15_Injective
msgid "A function `f : A â†’ B` between preorders `A` and `B` is strictly monotone\n"
"if `a < b` implies `f a < f b`."
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "Monotone Funktionen"
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "Sofort hakt die Ã¤ltere Gestalt nach:"
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "**Du**: Hmm, das ist etwas schwierigerâ€¦\n"
"\n"
"**Robo**: Aber ich hab einen Trick auf Lager:\n"
"Das Lemma `StrictMono.injective` sagt, dass jede strikt monotone Funktion injektive ist,\n"
"und ich habe das GefÃ¼hl Monotonie ist hier einfacher zu zeigen."
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "**Robo**: `apply` ist wonach du suchst."
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "**Robo**: Ich glaube, dieser Weg ist zu steinig. Fang doch nochmals von vorne an!"
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "**Robo**: Ich glaube, dieser Weg ist zu steinig. Fang doch nochmals von vorne an!"
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "**Du**: Jetzt mÃ¶chte ich strikte Monotonie von `n ^ 3` und `n + 3` separat zeigen,\n"
"schliesslich scheint es mir als wÃ¤r das zweite wieder einfach.\n"
"\n"
"**Robo**: DafÃ¼r hab ich `StrictMono.add` bereit!"
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "**Du**: Hmm, darauf hab ich jetzt wenig Lust. Gibt's dafÃ¼r auch was? Das gilt ja nur\n"
"wenn der Exponent ungerade ist.\n"
"\n"
"**Robo**: Du kÃ¶nntest mal `Odd.strictMono_pow` versuchenâ€¦"
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "**Du**: Ist das nicht ne TrivialitÃ¤t? Warte mal!"
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "**Du**: Ha! Und dieser Teil funktioniert sicher gleich wie InjektivitÃ¤t vorhin!"
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "**Du**: oder â€¦?\n"
"\n"
"**Robo**: Doch, doch. Schau mal mit `unfold` hinein in die Definition."
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "Dieses Lemma sagt `StrictMono f â†’ Injective f`."
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "FÃ¼r ungerades `n` is `x â†¦ x ^ n` strikt monoton.\n"
"\n"
"*Bemerkung*: Das Lemma ist im namespace `Odd`, damit man `hn.strictMono_pow` fÃ¼r den\n"
"Beweis `hn : Odd n` schreiben kÃ¶nnte."
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "Wenn `f,g` beide strikt monoton sind, dann ist es `f + g` auch."
msgstr ""

#: Game.Levels.Function.L16_Injective
msgid "**Du**: Danke vielmals!\n"
"\n"
"Und damit lÃ¤sst das Wesen mitten im Gang stehen, wo es weiter Ã¼ber InjektivitÃ¤t nachdenkt."
msgstr ""

#: Game.Levels.Function.L17_Retract
msgid "Left Inverse"
msgstr ""

#: Game.Levels.Function.L17_Retract
msgid "A function `f : A â†’ B` has a left inverse if there exists a function\n"
"  `g : B â†’ A` such that `g âˆ˜ f = id`.\n"
"\n"
"  In this level, you will prove that the successor function on the natural numbers has a left inverse."
msgstr ""

#: Game.Levels.Function.L18_Extend
msgid "Choosing an arbitrary element of a nonempty type."
msgstr ""

#: Game.Levels.Function.L18_Extend
msgid "In this level you show that an injective function with a nonempty domain has a left inverse."
msgstr ""

#: Game.Levels.Function.L19_HasRetract
msgid "Functions with left inverses are injective."
msgstr ""

#: Game.Levels.Function.L19_HasRetract
msgid "In this level you show that a function which has a left inverse is injective."
msgstr ""

#: Game.Levels.Function.L20_HasRetract
msgid "Injections with nonempty domain have retract."
msgstr ""

#: Game.Levels.Function.L20_HasRetract
msgid "In this level you show that an injective function with a nonempty domain has a left inverse."
msgstr ""

#: Game.Levels.Function.L21_Bijective
msgid "BijektivitÃ¤t"
msgstr ""

#: Game.Levels.Function.L21_Bijective
msgid "**Du**: Ehm, und wie kommen wir da wieder raus?\n"
"\n"
"**Gelehrter**: Gerne zeige ich euch den Weg, nachdem ihr mir auch noch folgendes erklÃ¤rt:"
msgstr ""

#: Game.Levels.Function.L21_Bijective
msgid "**Robo** *(flÃ¼sternd)*: `Bijectve f` ist als `Injective f âˆ§ Surjective f` definiert.\n"
"\n"
"**Du**: Dann ist das ja ganz simpel!"
msgstr ""

#: Game.Levels.Function.L21_Bijective
msgid "Zufrieden drÃ¼ckt euch der Gelehrte eine neue Fackel in die Hand und\n"
"zeigt euch den Weg nach drauÃŸen."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "Inverse"
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "Eigentlich hast du nur beilÃ¤ufig Robo gefragt, ob bijektiv nicht auch bedeute, dass\n"
"eine Inverse Funktion existiere. Jetzt steht ihr aber schon seit einer halben Stunde rum\n"
"und der Gelehrte mÃ¶chte wissen, wie das den genau ginge.\n"
"\n"
"Offensichtlich kennt er diese Aussage als `Function.bijective_iff_has_inverse` aus seinen BÃ¼chern,\n"
"aber er mÃ¶chte, dass du ihm das hier und jetzt nochmals von Grund auf zeigst."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Du**: Nah da sagt mir so manches nichts, aber ich kann ja mal mit dem `â†”` anfangen,\n"
"das kenn ich ja schon."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: Tipp. Teil doch `Bijective` mit `rcases Â«{h}Â» with âŸ¨hI, hSâŸ©` in\n"
"`Injective` und `Surjective` auf!"
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Du**: Ja was ist eigentlich die Inverse von `Â«{f}Â»`â€¦?\n"
"\n"
"**Robo**: Hast du eine Idee?\n"
"\n"
"**Du**: Also von der SurjektivitÃ¤t weiss ich, dass fÃ¼r alle `y` ein Urbild existiert\n"
"und mit der InjektivitÃ¤t kÃ¶nnte ich dann zeigen, dass dieses eindeutig ist.\n"
"\n"
"**Robo**: Also Schritt fÃ¼r Schritt: Mit `fun y â†¦ (Â«{hS}Â» y).choose ` kannst du eine Funktion\n"
"definieren, die `y` irgendein Urbild zuweist.\n"
"\n"
"**Du**: Die ist aber nicht wohldefiniert, oder?\n"
"\n"
"**Robo**: In der Mathe nicht. In Lean geht das ganz gut, aber es ist dann unmÃ¶glich etwas\n"
"darÃ¼ber zu beweisen, wenn es mehrere MÃ¶glichkeiten gÃ¤be."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: fang mal mit `intro` an."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: Gut! Auf zum Rechtsinversen! Fang auch hier wieder mit `intro` an."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: fang mal mit `intro` an."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Du**: kompliziert.\n"
"\n"
"**Robo**: Aber mit `simp` kannst du es ja etwas vereinfachen."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Du**: Das kann ich jetzt nicht zeigen solange ich nicht weiss, dass nur genau ein\n"
"Urbild besteht.\n"
"\n"
"**Robo**: Dann wende doch mit `apply Â«{hI}Â»` die InjektivitÃ¤t an!"
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: Dies ist jetzt eine etwas tautologische Aussage. In Lean ist das\n"
"`Exists.choose_spec`. Konkret `apply Exists.choose_spec (Â«{hS}Â» (f x))`."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: Gut! Auf zum Rechtsinversen! Fang auch hier wieder mit `intro` an."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Du**: Kann ich das vereinfachen?"
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Du**: Also wieder `Exists.choose_spec`?\n"
"\n"
"**Robo**: Genau! Diesmal mit dem Argument `(Â«{hS}Â» x)`."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: Die eine Richtung ist gezeigt. Jetzt auf zur RÃ¼ckrichtung!"
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: Zerlege `Â«{h}Â»` noch soweit du kannst!"
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: Das UND auch noch!"
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: Das `Bijective` kannst du auch aufteilen."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: InjektivitÃ¤t ist der schwierige Teil. Fang mal an mit `intro`."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: Im nÃ¤chsten Schritt must du `LeftInverse` brauchen um das Goal\n"
"zu `g (f a) = g (f b)` zu wechseln: schau mal was du mit\n"
"`have w := Â«{hL}Â» Â«{a}Â»` kriegst und ob du das mit `rw` benutzen kannst."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Du**: Wenn die Argumente `f a = f b` gleich sind, ist dann auch `g (f a) = g (f b)`,\n"
"wie sag ich das?\n"
"\n"
"**Robo**: Also wenn du `f a = f b` hast, kannst du ja auch einfach damit umschreiben."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "Die SurjektivitÃ¤t sollte einfacher sein."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: Psst, mit `RightInverse g f` weisst du, dass `f (g x) = x`.\n"
"Hilft das rauszufinden was du hier brauchen musst?"
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "**Robo**: Du kannst die `RightInverse`-Annahme einfach mit `rw`\n"
"benutzen."
msgstr ""

#: Game.Levels.Function.L22_Inverse
msgid "Endlich entkommt ihr der Bibliothek.\n"
"\n"
"**Robo**: Da wÃ¼rden mich keine zehn Pferde nochmals hineinbringen!\n"
"\n"
"**Du**: Von wegen Pferden, wie viele PS hat eigentlich unser Raumschiff?"
msgstr ""

#: Game.Levels.Function.L23_Equivalence
msgid "Triple"
msgstr ""

#: Game.Levels.Function.L23_Equivalence
msgid "An equivalence `Î± : A â‰ƒ B` between `A` and `B` consists of a pair of functions `f : A â†’ B` and `g : B â†’ A` such that `f âˆ˜ g = id` and `g âˆ˜ f = id`.\n"
"\n"
"`finTwoArrowEquiv` constructs an equivalence between functions from `Fin 2` to `A` and pairs of elements of `A`, that is an equivalence\n"
"  ```\n"
"  (Fin 2 â†’ A) â‰ƒ A Ã— A\n"
"\n"
"  ```\n"
"In this level you construct an equivalence between functions from `Fin 3` to `A` and triples of elements of `A`."
msgstr ""

#: Game.Levels.Function.L24_EquivalenceBijection
msgid "Bijection of Equivalence"
msgstr ""

#: Game.Levels.Function.L24_EquivalenceBijection
msgid "In this level you show that there every bijection gives rise to an equivalence."
msgstr ""

#: Game.Levels.Function.L25_CurryEquiv
msgid "Curry"
msgstr ""

#: Game.Levels.Function.L25_CurryEquiv
msgid "In this level, you will learn about currying. Currying is the process of transforming a function that takes multiple arguments into a function that takes one argument and returns another function that takes the next argument, and so on, until all arguments have been supplied. This is useful because it allows you to partially apply a function, which means you can supply some of the arguments now and the rest later.\n"
"\n"
"This insight was first made explicit separately by Moses Ilyich SchÃ¶nfinkel in the 19th century and later in the 20th century by Haskell Curry."
msgstr ""

#: Game.Levels.Function.L26_Diagonal
msgid "Diagonal"
msgstr ""

#: Game.Levels.Function.L26_Diagonal
msgid "In this level, you will prove that the the diagonal function is injective."
msgstr ""

#: Game.Levels.Function.L27_CurrySurjective
msgid "Not exhausted by naturals."
msgstr ""

#: Game.Levels.Function.L27_CurrySurjective
msgid ""
msgstr ""

#: Game.Levels.Function
msgid "Abbildungen"
msgstr ""

#: Game.Levels.Function
msgid "Auf der Suche nach dem Buch der Urbilder landet ihr auf einem kleinen Mond, der bis auf\n"
"eine Insel komplett mit Wasser bedeckt zu sein scheint.\n"
"\n"
"Auf der Insel seht ihr verschiedene groÃŸe und kleine Behausungen, manche aus Stroh und Holz,\n"
"vereinzelte aus Lehm.\n"
"\n"
"Planlos geht ihr zum ersten Haus bei dem jemand vorne auÃŸen sitzt."
msgstr ""

#: Game.Levels.Quotient.L01_Classes
msgid "Classes"
msgstr ""

#: Game.Levels.Quotient.L01_Classes
msgid "A setoid structure on a type `A` provides a congruence (aka equivalence relation)\n"
"`r : A â†’ A â†’ Prop`.\n"
"Given a setoind `s` on `A` and the congruence `s.Rel` tells us which elements of `A` are related\n"
"to each other by the relation `s.Rel`.\n"
"\n"
"Given a setoid structure `s` on `A` and an element `a : A` the equivalence class of `a`\n"
"is the set of all elements of `A` that are congruent to `a`, namely `{x : A | s.Rel x a}`.\n"
"\n"
"In this level you shall prove that the equivalence class of `a` is the same as the equivalence class of `b` iff `a` and `b` are related by the relation `s.Rel`."
msgstr ""

#: Game.Levels.Quotient.L02_Kernel
msgid "Kernel"
msgstr ""

#: Game.Levels.Quotient.L02_Kernel
msgid "A setoid structure on a type `A` provides a relation `r : A â†’ A â†’ Prop` which is congruence (aka equivalence relation). The congruence `r` tell us which elements of `A` are congruent to other elements of `A`.\n"
"\n"
"\n"
"We show that every function `f : A â†’ B` induces a congruence on `A`. We say elements `x`\n"
"and `y` of `A` are kernel-congruent if `f x = f y`.\n"
"This is the equivalence relation `ker f` on `A` denoted by `ker f`.\n"
"```\n"
"x â‰ˆ y â†” f x = f y\n"
"```\n"
"\n"
"You might be familiar with the kernel of a group homomorphism which the set of elements\n"
"that are sent to the identity element of the codomain. The kernel of a group\n"
"homomorphism is a subgroup of the domain.\n"
"\n"
"In this level you show that these two notions of kernel coincide: Two elements `x` and `y` of `A` are kernel congruent if and only if their difference is in the kernel of `f`."
msgstr ""

#: Game.Levels.Quotient
msgid "Quotient"
msgstr ""

#: Game.Levels.Quotient
msgid ""
msgstr ""

#: Game.Levels.NewStuff.RealUncountable_01
msgid "Ã¼berabzÃ¤hlbare reele Zahlen"
msgstr ""

#: Game.Levels.NewStuff.RealUncountable_01
msgid "Zuerst zeigen wir ein Hilfslemma."
msgstr ""

#: Game.Levels.NewStuff.RealUncountable_01
msgid "Sei $K$ ein KÃ¶rper mit KardinalitÃ¤t $\\aleph_0$ und sei $V$ ein $K$-Vektorraum.\n"
"\n"
"Zeige, dass die KardinalitÃ¤t von $V \\le \\aleph_0$."
msgstr ""

#: Game.Levels.NewStuff.RealUncountable_01
msgid "Als Beweisstrategie mÃ¶chtest du wie `#K ^ #Î¹ â‰¤ â„µâ‚€` gehen. Also zuerst sagen,\n"
"dass die KardinalitÃ¤t von $V$ genau die KardinalitÃ¤t von $K$ hoch $\\mathrm{dim}(V)$ ist."
msgstr ""

#: Game.Levels.NewStuff.RealUncountable_01
msgid "Schau mal `have h := Â«{h_basis}Â».equivFun.toEquiv` an"
msgstr ""

#: Game.Levels.NewStuff.RealUncountable_02
msgid "Ã¼berabzÃ¤hlbare reele Zahlen"
msgstr ""

#: Game.Levels.NewStuff.RealUncountable_02
msgid "Wir zeigen dass â„ ein nicht-endlicher â„š-Vektorraum ist."
msgstr ""

#: Game.Levels.NewStuff.RealUncountable_02
msgid "Zeige dass â„ kein endlich dimensionaler â„š-Vektorraum ist."
msgstr ""

#: Game.Levels.NewStuff.RealUncountable_02
msgid "`let B := Basis.ofVectorSpace â„š â„` gibt dir eine Basis von $\\mathbb{R}$ Ã¼ber $\\mathbb{Q}$.\n"
"Mache dann einen Widerspruchsbeweis und brauche folgende Resultate:\n"
"\n"
"* `Cardinal.not_countable_real`: Das Hilfslemma von vorhin.\n"
"* `Cardinal.not_countable_real` : $\\mathbb{R}$ ist Ã¼berabzÃ¤hlbar.\n"
"\n"
"Fange vielleicht auch damit an, `#â„š = â„µâ‚€` zu zeigen."
msgstr ""

#: Game.Levels.NewStuff
msgid "Reals Are Uncountable"
msgstr ""

#: Game.Levels.NewStuff
msgid "Dieser Planet ist kahl un leer und noch unentdeckt. Zeit und Geschichte scheint es\n"
"hier nicht zu geben."
msgstr ""

#: Game.Levels.Contradiction.L01_Have
msgid "Was wir haben, haben wir."
msgstr ""

#: Game.Levels.Contradiction.L01_Have
msgid "**Benedictus**: Hier, schaut mal. Das habe ich fÃ¼r Euch vorbereitet."
msgstr ""

#: Game.Levels.Contradiction.L01_Have
msgid "**Du**: Also als erstes teile ich wohl mal das Und (`âˆ§`) auf."
msgstr ""

#: Game.Levels.Contradiction.L01_Have
msgid "**Du**: Und jetzt â€¦\n"
"\n"
"**Benedictus**: â€¦ solltest du dir ein passendes Zwischenresultat zurechtlegen.\n"
"\n"
"**Robo**: Ja! Probier mal `have g : Â¬ B`!"
msgstr ""

#: Game.Levels.Contradiction.L01_Have
msgid "**Du**: Was? Jetzt hab ich einfach angenommen, dass sei richtig?\n"
"\n"
"**Robo**: Nee, jetzt musst du das erst noch beweisen, bevor du es dann benutzen kannst."
msgstr ""

#: Game.Levels.Contradiction.L01_Have
msgid "**Robo**: `apply` sollte helfen"
msgstr ""

#: Game.Levels.Contradiction.L01_Have
msgid "**Du**: Und wie war das nochmals wenn zwei Annahmen sich widersprechen?\n"
"\n"
"**Robo**: `contradiction`."
msgstr ""

#: Game.Levels.Contradiction.L01_Have
msgid "**Benedictus**: Das sieht gut aus!"
msgstr ""

#: Game.Levels.Contradiction.L02_Suffices
msgid "Es reicht!"
msgstr ""

#: Game.Levels.Contradiction.L02_Suffices
msgid "**Benedictus**: Ihr hÃ¤ttet natÃ¼rlich auch erst das Hauptresultat und dann das\n"
"Zwischenresultat beweisen kÃ¶nnen. Das kÃ¶nnt Ihr ja mal an dieser Aufgabe probieren, die ist\n"
"ganz Ã¤hnlich."
msgstr ""

#: Game.Levels.Contradiction.L02_Suffices
msgid "**Robo**: Ich weiÃŸ was er meint! Anstatt `have` kannst du auch `suffices`\n"
"verwenden. Das funktioniert genau gleich, auÃŸer, dass dann die beiden Beweisziele vertauscht sind.\n"
"\n"
"**Du**: Also nach `suffices g : Â¬B` muss ich dann zuerst zeigen, wie man mit `g` den Beweis\n"
"abschliesst, bevor ich `g` beweise?\n"
"\n"
"**Robo**: Genau!"
msgstr ""

#: Game.Levels.Contradiction.L02_Suffices
msgid "**Robo**: Also hier beendest du den Beweis unter der Annahme `Â«{g}Â»` sei wahr."
msgstr ""

#: Game.Levels.Contradiction.L02_Suffices
msgid "**Robo**: Und hier beweist du das Zwischenresultat."
msgstr ""

#: Game.Levels.Contradiction.L02_Suffices
msgid "**Benedictus**: Genau so meinte ich das. Ob Ihr nun in Zukunft `have` und\n"
"`suffices` verwendet, ist reine Geschmacksfrage. Hauptsache, Ihr wisst, wie Ihr\n"
"entfernte Ziele in kleinen Schritte erreicht."
msgstr ""

#: Game.Levels.Contradiction.L03_ByContra
msgid "Widerspruch"
msgstr ""

#: Game.Levels.Contradiction.L03_ByContra
msgid "**Benedictus**: Hier ist noch eine Variante."
msgstr ""

#: Game.Levels.Contradiction.L03_ByContra
msgid "**Robo**: Ein `Â¬` im Goal heiÃŸt hÃ¤ufig, dass du einen Widerspruchsbeweis fÃ¼hren\n"
"mÃ¶chtest.\n"
"\n"
"**Du**: Und wie mache ich das? Mit `contradiction`?\n"
"\n"
"**Robo**: Mit `by_contra h` fÃ¤ngst du einen Widerspruchsbeweis an. Und mit `contradiction`\n"
"schlieÃŸt du ihn ab."
msgstr ""

#: Game.Levels.Contradiction.L03_ByContra
msgid "**Robo**: Jetzt hast du also eine Annahme `Â«{h}Â» : Â«{A}Â»`, und damit musst du einen\n"
"Widerspruch herleiten.\n"
"\n"
"Du kÃ¶nntest zum Beispiel jetzt mit `suffices` sagten, welchen Widerspruch du gern herleiten\n"
"mÃ¶chtest, etwa `suffices k : B`"
msgstr ""

#: Game.Levels.Contradiction.L03_ByContra
msgid "**Du**: Ah, und jetzt kann ich einfach sagen dass sich die Annahmen `Â«{B}Â»` und `Â¬Â«{B}Â»` sich\n"
"widersprechen."
msgstr ""

#: Game.Levels.Contradiction.L03_ByContra
msgid "**Robo**: Und jetzt musst du nur noch das Zwischenresultat herleiten, dass zu diesem\n"
"Widerspruch gefÃ¼hrt hat."
msgstr ""

#: Game.Levels.Contradiction.L03_ByContra
msgid "**Benedictus**: Ich sehe schon, Ihr lernt schnell!"
msgstr ""

#: Game.Levels.Implication.L01_Intro
msgid "Intro"
msgstr ""

#: Game.Levels.Implication.L01_Intro
msgid "**Operationsleiter**: Hier, zum Beispiel:"
msgstr ""

#: Game.Levels.Implication.L01_Intro
msgid "**Operationsleiter**: Die Arbeiten meinen, das wÃ¤re so richtig und wir wÃ¼rden das dringend\n"
"brauchen. Aber keiner kann es mir beweisen.\n"
"\n"
"**Du**: Einen Moment. Das ist ja gerade so eine Implikation (`\\to`). Wir nehmen an,\n"
"dass `Â«{B}Â»` gilt, und wollen zeigen, dass dann gilt `Â«{A}Â»` impliziert `Â«{A}Â» und Â«{B}Â»`. Ja,\n"
"klar! NatÃ¼rlich stimmt das.\n"
"\n"
"Der Operationsleiter sieht dich erwartungsvoll an.\n"
"\n"
"**Du** *(leise zu Robo)*: Soll ich ihm `tauto` aufschreiben?\n"
"\n"
"**Robo** *(leise zurÃ¼ck)*: So wie der aussieht, fÃ¼rchte ich, das wird er auch nicht verstehen.\n"
"Schreib den Beweis lieber aus.\n"
"\n"
"**Du**: Aber wie denn? Ich glaube, ich wÃ¼rde als erstes gern so etwas sagen wie 'Nehmen wir\n"
"also an, `Â«{A}Â»` gilt â€¦'\n"
"\n"
"**Robo**: Ja, gute Idee. WÃ¤hle dazu fÃ¼r deine Annahme einfach einen Namen, zum Beispiel `h`,\n"
"und schreib `intro h`."
msgstr ""

#: Game.Levels.Implication.L01_Intro
msgid "**Du**: Okay. Jetzt habe ich also sowohl `Â«{A}Â»` als auch `Â«{B}Â»` in meinen Annahmen und\n"
"muss `Â«{A}Â» âˆ§ Â«{B}Â»` zeigen.\n"
"\n"
"**Robo**: Genau. Und wie das geht, weiÃŸt du ja schon."
msgstr ""

#: Game.Levels.Implication.L01_Intro
msgid "**Operationsleiter**: Perfekt! Danke schÃ¶n!\n"
"\n"
"Er geht zu einer Schalttafel und ein paar KnÃ¶pfe. Irgendwo setzt sich lautstark ein\n"
"FÃ¶rderband in Bewegung.\n"
"\n"
"**Operationsleiter**: Habt Ihr vielleicht noch ein paar Minuten?"
msgstr ""

#: Game.Levels.Implication.L02_Revert
msgid "Revert"
msgstr ""

#: Game.Levels.Implication.L02_Revert
msgid "Der Operationsleiter holt aus einem Container einen Stapel Papier hervor.\n"
"\n"
"**Operationsleiter**: Hier hat sich echt einiges angesammelt. WÃ¤re echt super, wenn Ihr mir\n"
"noch ein bisschen helfen kÃ¶nntet.\n"
"\n"
"Er Ã¼bergibt Euch das oberste Blatt."
msgstr ""

#: Game.Levels.Implication.L02_Revert
msgid "**Operationsleiter**: Das ist von einem Kollegen.\n"
"\n"
"**Robo**: Oh, das hab ich schon einmal irgendwo gelesen. Warte mal â€¦ Richtig! Das war\n"
"damals, als ich Wikipedia gecrawlt habe: `Der Modus ponens ist eine schon in der antiken\n"
"Logik gelÃ¤ufige Schlussfigur, die in vielen logischen â€¦`\n"
"\n"
"**Du**: Robo! Gefragt ist ein Beweis und kein historischer Aufsatz! Oder komme ich hier\n"
"etwa mit `mopo` oder so etwas weiter?\n"
"\n"
"**Robo**: Okay, nein, sorry. `mopo` gibt es nicht. Probier lieber `revert Â«{hA}Â»`."
msgstr ""

#: Game.Levels.Implication.L02_Revert
msgid "**Du**: Aha. `revert` ist quasi `intro` rÃ¼ckwÃ¤rts.\n"
"\n"
"**Robo**: Genau. `intro` nimmt die PrÃ¤misse aus einer Implikation `Â«{A}Â» \\to Â«{B}Â»` im\n"
"Beweisziel und macht daraus eine Annahme. `revert` nimmt umgekehrt eine Annahme und\n"
"setzt sie als ImplikationsprÃ¤misse vor das Beweisziel. Aber nun mach schon fertig."
msgstr ""

#: Game.Levels.Implication.L02_Revert
msgid "Der Operationsleiter nimmt erfreut Eure LÃ¶sung entgegen, und greift zum Telefon."
msgstr ""

#: Game.Levels.Implication.L03_Apply
msgid "Apply"
msgstr ""

#: Game.Levels.Implication.L03_Apply
msgid "Leider lÃ¤uft das Telefonat nicht so gut. Er legt wieder auf und schÃ¼ttelt mit dem Kopf.\n"
"\n"
"**Operationsleiter**: Der Kollege auf der anderen Seite des Mondes versteht kein `revert`. Oder\n"
"er tut zumindest so. Habt Ihr noch eine andere Idee?\n"
"\n"
"Er zieht eine Linie unter Euren Beweis, ergÃ¤nzt ein durchgestrichenes ~`revert`~, und legt Euch\n"
"das Blatt ein zweites Mal vor."
msgstr ""

#: Game.Levels.Implication.L03_Apply
msgid "**Robo**: Vielleicht wÃ¤re es ohnehin eleganter gewesen, die gegebene Implikation anzuwenden.\n"
"Probier doch mal `apply hAB at h`."
msgstr ""

#: Game.Levels.Implication.L03_Apply
msgid "**Robo**: Ich sagte `â€¦ at h`. Aber einfach nur `apply hAB` funktioniert offenbar auch.\n"
"Jetzt hast Du sozusagen `hAB` auf das Beweisziel `B` angewendet, und musst nur\n"
"noch `A` beweisen."
msgstr ""

#: Game.Levels.Implication.L03_Apply
msgid "**Du**: Ja, das kommt mir jetzt auch natÃ¼rlich vor."
msgstr ""

#: Game.Levels.Implication.L03_Apply
msgid "Diesmal scheint das Telefonat erfolgreich zu verlaufen."
msgstr ""

#: Game.Levels.Implication.L04_Apply
msgid "Implikation"
msgstr ""

#: Game.Levels.Implication.L04_Apply
msgid "**Operationsleiter**: Das hier ist jetzt wieder ein lokales Problem."
msgstr ""

#: Game.Levels.Implication.L04_Apply
msgid "**Du**: Ich soll Implikationen $A \\Rightarrow B \\Rightarrow C$ zu $A \\Rightarrow C$\n"
"kombinieren?\n"
"\n"
"**Robo**: Vielleicht fÃ¤ngst du wieder mit `intro` an?"
msgstr ""

#: Game.Levels.Implication.L04_Apply
msgid "**Robo**: Das ist wieder eine Anwendung von `apply`."
msgstr ""

#: Game.Levels.Implication.L04_Apply
msgid "**Operationsleiter**: Ihr seid echt super!"
msgstr ""

#: Game.Levels.Implication.L05_Apply
msgid "Implikation"
msgstr ""

#: Game.Levels.Implication.L05_Apply
msgid "Die nÃ¤chste Seite sieht ein bisschen komplizierter aus. Damit Ihr nicht die Ãœbersicht verliert, fasst Robo sofort die verschiedenen Implikationen in einem Diagramm zusammen.\n"
"  $$\n"
"  \\begin{CD}\n"
"       A  @>{f}>> B @<{g}<< C    \\\\\n"
"    @V{h}VV    @V{i}VV   @V{j}VV \\\\\n"
"       D  @<{k}<< E @>{l}>> F    \\\\\n"
"    @A{m}AA    @A{n}AA   @V{p}VV \\\\\n"
"       G  @<{q}<< H @>{r}>> I\n"
"  \\end{CD}\n"
"  $$"
msgstr ""

#: Game.Levels.Implication.L05_Apply
msgid "**Du**: Also ich muss einen Pfad von Implikationen $A \\Rightarrow I$ finden.\n"
"\n"
"**Robo**: Lass mich mal raten, wie wir anfangen â€¦ Wieder `intro`?"
msgstr ""

#: Game.Levels.Implication.L05_Apply
msgid "**Robo**: Na wieder `apply`, was sonst."
msgstr ""

#: Game.Levels.Implication.L05_Apply
msgid "**Robo**: Das sieht nach einer Sackgasse aus â€¦"
msgstr ""

#: Game.Levels.Implication.L05_Apply
msgid "**Robo**: Das sieht nicht gut aus."
msgstr ""

#: Game.Levels.Implication.L05_Apply
msgid "**Robo**: Nah, da stimmt doch was nicht â€¦"
msgstr ""

#: Game.Levels.Implication.L05_Apply
msgid "**Robo**: Halt! Falsch abgebogen."
msgstr ""

#: Game.Levels.Implication.L05_Apply
msgid "**Robo**: Bist du dir sicher?"
msgstr ""

#: Game.Levels.Implication.L05_Apply
msgid "**Robo**: Ehm â€¦"
msgstr ""

#: Game.Levels.Implication.L05_Apply
msgid "Der Operationsleiter bedankt sich wieder artig. Er drÃ¼ckt wieder auf ein paar KnÃ¶pfe,\n"
"und mit einem lauten Ratteln springen mehrere FÃ¶rderbÃ¤nder gleichzeitig wieder an."
msgstr ""

#: Game.Levels.Implication.L06_Iff
msgid "Genau dann, wenn"
msgstr ""

#: Game.Levels.Implication.L06_Iff
msgid "**Operationsleiter**: Wir hatten auch mal ein paar FÃ¶rderbÃ¤nder, die in beide Richtungen laufen\n"
"konnten. Die hatte ich vorsichtshalber alle abgestellt, weil in den neusten HandbÃ¼chern von\n"
"solchen DoppelbÃ¤ndern abgeraten wird. Aber vielleicht sind sie ja unter bestimmten\n"
"Voraussetzungen doch sicher? Was meint Ihr zu diesem Fall?"
msgstr ""

#: Game.Levels.Implication.L06_Iff
msgid "**Robo**: `A â†” B` ist natÃ¼rlich Leansch fÃ¼r $A \\iff B$, also genau-dann-wenn.\n"
"Die Aussage `A â†” B` besteht also aus zwei Teilen; sie ist als `âŸ¨A â†’ B, B â†’ AâŸ©` definiert.\n"
"\n"
"**Du**: Also ganz Ã¤hnlich wie das UND, `A âˆ§ B`?\n"
"\n"
"**Robo**: Genau. Entsprechend kannst du auch hier mit `constructor` anfangen."
msgstr ""

#: Game.Levels.Implication.L06_Iff
msgid "**Du**: Ah, und die beiden Teile habe ich schon in den Annahmen."
msgstr ""

#: Game.Levels.Implication.L06_Iff
msgid "**Operationsleiter**: Okay, das leuchtet mir ein.\n"
"\n"
"**Robo** *(zu dir)*: Ãœbrigens, so wie bei `(h : A âˆ§ B)` die beiden\n"
"Teile `h.left` und `h.right` heiÃŸen,\n"
"heiÃŸen bei `(h : A â†” B)` die beiden Teile `h.mp` und `h.mpr`.\n"
"\n"
"**Du**: Also `h.mp` ist `A â†’ B`? Wieso `mp`?\n"
"\n"
"**Robo**: `mp` steht fÃ¼r Modus Ponens`. Der Modus ponens ist eine schon in der antiken\n"
"Logik gelÃ¤ufige Schlussfigur, die in vielen logischen Systemen â€¦ Ach nee, das wolltest\n"
"du ja nicht hÃ¶ren. Das \"r\" in `mpr` steht fÃ¼r \"reverse\", weil's die RÃ¼ckrichtung ist."
msgstr ""

#: Game.Levels.Implication.L07_Symm
msgid "Genau dann, wenn"
msgstr ""

#: Game.Levels.Implication.L07_Symm
msgid "**Operationsleiter**: Hier ist noch so etwas."
msgstr ""

#: Game.Levels.Implication.L07_Symm
msgid "**Du**: Das ist ja nur verdreht.\n"
"\n"
"**Robo**: Ich kenne ein Werkzeug dafÃ¼r. Mit `symm` oder `symm at Â«{h}Â»` kannst du eines\n"
"der beiden umdrehen."
msgstr ""

#: Game.Levels.Implication.L07_Symm
msgid "**Operationsleiter**: Das war ja symmpel. Das nÃ¤chste Problem sieht aber schwieriger aus."
msgstr ""

#: Game.Levels.Implication.L08_Rw
msgid "Genau dann, wenn"
msgstr ""

#: Game.Levels.Implication.L08_Rw
msgid "**Operationsleiter**: Hier, kÃ¶nnt ihr dazu auch was sagen?"
msgstr ""

#: Game.Levels.Implication.L08_Rw
msgid "**Du**: $B \\iff A \\iff D \\iff C$, die sind doch alle Ã¤quivalentâ€¦\n"
"\n"
"**Robo**: Ja, aber du musst ihm helfen, die Ã„quivalenzen umzuschreiben. Mit `rw [hâ‚]` kannst\n"
"du `C` durch `D` ersetzen."
msgstr ""

#: Game.Levels.Implication.L08_Rw
msgid "**Du** Und wenn ich in die andere Richtung umschreiben mÃ¶chte?\n"
"\n"
"**Robo**: Dann schreibst du ein `â†` (`\\l`, also klein \"L\") vor den Namen, also `rw [â† hâ‚“]`."
msgstr ""

#: Game.Levels.Implication.L08_Rw
msgid "**Du**: Ehm, das war verkehrt.\n"
"\n"
"**Robo**: Ja, anders herum wÃ¤r's besser gewesen. Aber wenn du jetzt einfach weitermachst,\n"
"bis Du sowas wie `A â†” A` erhÃ¤ltst, kann `rfl` das beweisen.\n"
"\n"
"**Robo: Da fÃ¤llt mir ein, `rw` wendet ohnehin auch versuchsweise `rfl` an.\n"
"Das heiÃŸt, du musst `rfl` nicht einmal ausschreiben."
msgstr ""

#: Game.Levels.Implication.L08_Rw
msgid "**Operationsleiter**: Wenn Ihr so weitermacht, dann kommen wir ja durch den ganzen Packen durch!"
msgstr ""

#: Game.Levels.Implication.L09_Iff
msgid "Genau dann wenn"
msgstr ""

#: Game.Levels.Implication.L09_Iff
msgid "**Operationsleiter**: Das hier ist wieder fÃ¼r meinen beschrÃ¤nkten Kollegen. Ich glaube,\n"
"`rw` mag der auch nicht. Geht das trotzdem?"
msgstr ""

#: Game.Levels.Implication.L09_Iff
msgid "**Du**: Naja ich kann wohl immerhin mal mit `intro` anfangen â€¦\n"
"\n"
"**Robo**: â€¦ und dann schauen wir weiter!"
msgstr ""

#: Game.Levels.Implication.L09_Iff
msgid "**Robo**: Also eine Implikation wendet man mit `apply` an â€¦\n"
"\n"
"**Du**: WeiÃŸ ich doch! Aber `Â«{h}Â»` ist keine Implikation, sondern eine Ã„quivalenz.\n"
"Da wÃ¼rde ich doch eigentlich `rw [â† Â«{h}Â»]` sagen wollen.\n"
"\n"
"**Robo**: Die Richtung `Â«{A}Â» â†’ Â«{B}Â»` von `Â«{h}Â»` heiÃŸt `Â«{h}Â».mp`. Du kannst sie\n"
"mit `apply (Â«{h}Â».mp) at â€¦` anwenden."
msgstr ""

#: Game.Levels.Implication.L09_Iff
msgid "**Robo**: So kannst Du natÃ¼rlich auch anfangen."
msgstr ""

#: Game.Levels.Implication.L09_Iff
msgid "**Operationsleiter**: Okay, super. Das mÃ¼sste passen.\n"
"\n"
"Er telefoniert wieder.\n"
"\n"
"**Operationsleiter**: Bingo!"
msgstr ""

#: Game.Levels.Implication.L10_Iff
msgid "Genau dann wenn"
msgstr ""

#: Game.Levels.Implication.L10_Iff
msgid "**Operationsleiter**: Ah, die nÃ¤chste Seite ist auch von diesem Kollegen.\n"
"Aber da ist noch eine Notiz bei. Wir hatten hierfÃ¼r schon einmal einen Beweis,\n"
"aber den mochte er nicht. Er wollte einen Beweis, der weder `rw` noch `apply` verwendet!!\n"
"\n"
"Er holt tief Luft und seuft.\n"
"\n"
"**Operationsleiter**: Ich glaube, der stellt sich immer viel dÃ¼mmer, als er ist.\n"
"Aber meint Ihr, Ihr schafft das?"
msgstr ""

#: Game.Levels.Implication.L10_Iff
msgid "**Du**: Hmm, mindestens mit der Implikation kann ich anfangen."
msgstr ""

#: Game.Levels.Implication.L10_Iff
msgid "**Robo**: Genau, das war `intro`."
msgstr ""

#: Game.Levels.Implication.L10_Iff
msgid "**Du**: Also, ich kenne `rw [Â«{h}Â»]` und `apply (Â«{h}Â».mp)`, aber das wollten wir ja\n"
"diesmal vermeiden.\n"
"\n"
"**Robo**: Was du machen kÃ¶nntest, ist, mit `rcases Â«{h}Â» with âŸ¨mp, mprâŸ©` die Annahme\n"
"in zwei Teile aufteilen."
msgstr ""

#: Game.Levels.Implication.L10_Iff
msgid "**Robo**: Hier mÃ¼sstest du jetzt `rw [â†Â«{h}Â»]` oder `apply Â«{h}Â».mp` benutzen.\n"
"Geh lieber einen Schritt zurÃ¼ck, sodass das Goal `A â†’ B` ist."
msgstr ""

#: Game.Levels.Implication.L10_Iff
msgid "**Du**: Ah, und jetzt ist das Beweisziel in den Annahmen."
msgstr ""

#: Game.Levels.Implication.L10_Iff
msgid "**Operationsleiter**: Perfekt, das sollte reichen!"
msgstr ""

#: Game.Levels.Implication.L11_ByCases
msgid "by_cases"
msgstr ""

#: Game.Levels.Implication.L11_ByCases
msgid "Beim nÃ¤chsten Problem stutzt der Operationsleiter.\n"
"\n"
"**Operationsleiter**: Ehrlich gesagt weiÃŸ ich gar nicht, wo dieses Blatt herkommt. Das ist\n"
"gar nicht von mir. Sieht aber irgendwie interessant aus."
msgstr ""

#: Game.Levels.Implication.L11_ByCases
msgid "**Du**: Naja, eine der beiden Aussagen `A` oder `Â¬A` wird schon wahr sein.\n"
"\n"
"**Robo**: Klarer Fall fÃ¼r eine Fallunterscheidung, wÃ¼rde ich sagen. Probier\n"
"mal `by_cases h : A`."
msgstr ""

#: Game.Levels.Implication.L11_ByCases
msgid "**Robo**: Siehst du, jetzt hat der Beweis zwei Teile. Im ersten Teil nimmst\n"
"du an, dass `A` wahr ist. Im zweiten nimmst du an, dass `A` falsch ist."
msgstr ""

#: Game.Levels.Implication.L11_ByCases
msgid "Der Operationsleiter nickt zustimmend."
msgstr ""

#: Game.Levels.Implication.L12_Rw
msgid "Lemmas"
msgstr ""

#: Game.Levels.Implication.L12_Rw
msgid "**Operationsleiter**: Wieder etwas fÃ¼r den Kollegen â€¦. Und er wollte wieder einen\n"
"Beweise ohne `apply`. Ich sehe hier auch, dass ich mir schon einmal etwas\n"
"hierzu notiert hatte. Richtig, es gibt da dieses Lemma:\n"
"```\n"
"lemma not_not (A : Prop) : Â¬Â¬A â†” A\n"
"```\n"
"\n"
"**Operationsleiter**: Schafft Ihr das damit?"
msgstr ""

#: Game.Levels.Implication.L12_Rw
msgid "**Robo**: Ein Lemma, das wie `not_not` ein `â†”` oder `=` im Statement hat, kann\n"
"auch mit `rw [not_not]` verwendet werden."
msgstr ""

#: Game.Levels.Implication.L12_Rw
msgid "**Du**: HÃ¤h, wieso hat das jetzt 2 von 3 der `Â¬Â¬` umgeschrieben?\n"
"\n"
"**Robo**: `rw` schreibt nur das erste um, das es findet, also `Â¬Â¬C`. Aber weil dieses\n"
"mehrmals vorkommt, werden die alle ersetzt â€¦\n"
"\n"
"**Du**: Ah, und `Â¬Â¬B` ist etwas anderes, also brauche ich das Lemma nochmals."
msgstr ""

#: Game.Levels.Implication.L12_Rw
msgid "**Du**: Wir sind schon fertig â€¦?\n"
"\n"
"**Robo**: Ja, `rw` versucht immer anschlieÃŸend `rfl` aufzurufen, und das hat hier funktioniert."
msgstr ""

#: Game.Levels.Implication.L13_Summary
msgid "Zusammenfassung"
msgstr ""

#: Game.Levels.Implication.L13_Summary
msgid "**Operationsleiter**: Ihr habt mir wirklich so geholfen! Hier ist das letzte Problem.\n"
"Das habe ich von meinem VorgÃ¤nger geerbt. Er hat behauptet, wenn wir das lÃ¶sen kÃ¶nnen,\n"
"dann lÃ¤uft hier wieder alles. Aber es sah mir immer viel zu schwierig aus, um es Ã¼berhaupt\n"
"zu versuchen. Wollt Ihr es einmal probieren?\n"
"\n"
"**Du**: Klar, zeig her! Robo, kannst du mir vielleicht auch noch einmal so eine nette\n"
"Zusammenfassung anzeigen, was ich theoretisch in den letzten fÃ¼nf Minuten gelernt habe?\n"
"\n"
"**Robo**: Hier ist die Ãœbersicht:\n"
"\n"
"## Notationen / Begriffe\n"
"\n"
"|               | Beschreibung                                             |\n"
"|:--------------|:---------------------------------------------------------|\n"
"| â†’             | Eine Implikation.                                        |\n"
"| â†”             | Genau-dann-wenn / Ã„quivalenz.                            |\n"
"\n"
"## Taktiken\n"
"\n"
"|     | Taktik                    | Beispiel                                               |\n"
"|:----|:--------------------------|:-------------------------------------------------------|\n"
"| 8   | `intro`                   | FÃ¼r eine Implikation im Goal.                          |\n"
"| 9   | `revert`                  | Umkehrung von `intro`.                                 |\n"
"| 10  | `apply`                   | Wendet eine Implikation auf das Goal an.               |\n"
"| 10áµ‡ | `apply`                   | Wendet ein Lemma an.                                   |\n"
"| 11  | `by_cases`                | Fallunterscheidung `P` und `Â¬P`                        |\n"
"| 12  | `rw`                      | Umschreiben zweier Ã¤quivalenter Aussagen.              |\n"
"| 12áµ‡ | `rw`                      | Benutzt ein Lemma, dessen Aussage eine Ã„quivalenz ist. |\n"
"| 13  | `symm`                    | Tauscht `A â†” B` zu `B â†” A`.                            |"
msgstr ""

#: Game.Levels.Implication.L13_Summary
msgid "**Du** *(flÃ¼sternd)*: Ist das nicht die Definition von `â†’`?\n"
"\n"
"**Robo** *(flÃ¼sternd)*: KÃ¶nnte man so sehen. Aber auf Leansch ist das bloÃŸ eine Ã„quivalenz."
msgstr ""

#: Game.Levels.Implication.L13_Summary
msgid "**Robo**: Vielleicht kannst du wieder `by_cases` benutzen."
msgstr ""

#: Game.Levels.Implication.L13_Summary
msgid "**Robo**: Na Implikationen gehst du immer mit `intro` an."
msgstr ""

#: Game.Levels.Implication.L13_Summary
msgid "**Robo**: Ich wÃ¼rde mal die Annahme `h` mit `rcases` aufteilen."
msgstr ""

#: Game.Levels.Implication.L13_Summary
msgid "**Operationsleiter**: Das ist ja fantastisch! Tausend Dank! Dann will ich Euch auch gar\n"
"nicht lÃ¤nger aufhalten.\n"
"Ihr wollt bestimmt weiter zum Planeten Quantus, oder?\n"
"\n"
"**Du**: Ehm, vielleicht â€¦\n"
"\n"
"**Operationsleiter**: Dann habe ich noch eine letzte Bitte. Ich habe hier noch ein PÃ¤ckchen\n"
"fÃ¼r die KÃ¶nigin von Quantus! Auch schon von meinem VorgÃ¤nger geerbt. Die Post will es\n"
"nicht annehmen, weil ich die Adresse nicht weiÃŸ. KÃ¶nntet Ihr es vielleicht zu ihr mitnehmen?\n"
"\n"
"**Du**: Klar! Robo, halt mal.\n"
"\n"
"Robo nimmt das PÃ¤ckchen und lÃ¤sst es irgendwo in seinem Innern verschwinden.\n"
"Der Operationsleiter sieht ihn entgeistert an.\n"
"\n"
"**Robo**: Keine Angst, ich verdaue nichts!"
msgstr ""

#: Game.Levels.Implication
msgid "Implis"
msgstr ""

#: Game.Levels.Implication
msgid "ZurÃ¼ck im Raumschiff macht ihr euch auf den Weg zu einem benachbarten Planeten, der ebenfalls\n"
"bewohnt zu sein scheinen.\n"
"\n"
"**Du**: Ich habe immer noch das GefÃ¼hl, dass ich die Aufgabe von KÃ¶nigin *Logisinde*\n"
"ohne `tauto` nicht hÃ¤tte lÃ¶sen kÃ¶nnen.\n"
"Kamen in der Aufgabe nicht auch Implikationen vor?\n"
"\n"
"**Robo**: Vielleicht haben wir ja auf dem Planeten *Implis*, den wir gerade ansteuern,\n"
"Gelegenheit, noch etwas dazuzulernen. Festhalten bitte â€¦\n"
"\n"
"Und damit leitet Robo den Landeanflug ein.\n"
"\n"
"Implis scheint ein riesiger Tagebau zu sein.\n"
"Ãœberall verlaufen FÃ¶rderbÃ¤nder, kreuz und quer, aber die meisten stehen still.\n"
"Ein schÃ¼chterner Operationsleiter erwartet Euch bereits.\n"
"\n"
"**Operationsleiter**: Ihr kommt mir gerade recht! Ich habe schon gehÃ¶rt. Echte Mathematiker!\n"
"Wisst Ihr, wir fÃ¶rdern hier Wahrheitswerte. Und dabei muss man hÃ¶llisch aufpassen.\n"
"Ein Fehler, und alles bricht zusammen. Aber ich bin sehr vorsichtig. Ich sage immer:\n"
"Lieber Stillstand als Untergang!"
msgstr ""

#: Game.Levels.Contradiction.L04_ByContra
msgid "Kontraposition"
msgstr ""

#: Game.Levels.Contradiction.L04_ByContra
msgid "**Benedictus**: Ich habe noch eine schÃ¶ne Frage zu ungeraden Quadraten fÃ¼r Euch.\n"
"Aber vorher beweist Ihr besser noch diese Ã„quivalenz hier. Ich gaube, die hat sogar\n"
"bei Euch einen Namen: *KontrapositionsÃ¤quivalenz*, oder so etwas. Auf Leansch nennen wir\n"
"die Ã„quivalenz einfach `not_imp_not`. Ist doch viel einleuchtender, oder?"
msgstr ""

#: Game.Levels.Contradiction.L04_ByContra
msgid "**Du**: Ja, das habe ich tatsÃ¤chlich schon einmal gesehen.\n"
"\n"
"**Robo**: Ja, klar hast du das schon einmal gesehen. Das benutzen Mathematiker doch stÃ¤ndig.\n"
"Wenn ihnen zu $A â‡’ B$ nichts einfÃ¤llt, zeigen sie stattdessen $Â¬B â‡’ Â¬A$. Ich wÃ¼rde das ja\n"
"statt *Kontraposition* oder `not_imp_not` eher *von_hinten_durch_die_Brust_ins_Auge* nennen.\n"
"Aber gut, ich will mich nicht einmischen."
msgstr ""

#: Game.Levels.Contradiction.L04_ByContra
msgid "**Robo**: Fang doch mal mit `constructor` an."
msgstr ""

#: Game.Levels.Contradiction.L04_ByContra
msgid "**Robo**: Ich wÃ¼rde wieder mit `suffices g : B` einen Widerspruch herbeifÃ¼hren."
msgstr ""

#: Game.Levels.Contradiction.L04_ByContra
msgid "**Robo**: Hier wÃ¼rde ich ebenfalls einen Widerspruchsbeweis anfangen."
msgstr ""

#: Game.Levels.Contradiction.L04_ByContra
msgid "**Robo**: `suffices g : Â¬ A` sieht nach einer guten Option aus."
msgstr ""

#: Game.Levels.Contradiction.L04_ByContra
msgid ""
msgstr ""

#: Game.Levels.Predicate.L01_Ring
msgid "NatÃ¼rliche Zahlen"
msgstr ""

#: Game.Levels.Predicate.L01_Ring
msgid "Du schaust dir die erste Seite an."
msgstr ""

#: Game.Levels.Predicate.L01_Ring
msgid "**Du**: Das ist doch Schulmathematik! Man rechnet das einfach aus,\n"
"indem man die Terme umsortiert.\n"
"\n"
"**Robo**: Wenn die Gleichung stimmt, kannst du auf Leansch sogar einfach\n"
"mit `ring` beweisen, dass das so ist.\n"
"\n"
"**Du**: Aber `â„•` ist doch gar kein Ring?\n"
"\n"
"**Robo**: `ring` funktioniert sogar fÃ¼r sogenannte Halbringe. Ich glaube,\n"
"man sagt `ring`, weil es in (kommutativen) Ringen am besten funktioniert."
msgstr ""

#: Game.Levels.Predicate.L01_Ring
msgid ""
msgstr ""

#: Game.Levels.Predicate.L02_Rewrite
msgid "Rewrite"
msgstr ""

#: Game.Levels.Predicate.L02_Rewrite
msgid ""
msgstr ""

#: Game.Levels.Predicate.L02_Rewrite
msgid "**Du**: Schau mal, dieses Problem sieht so Ã¤hnlich aus wie eines, das wir auf *Implis*\n"
"schon gelÃ¶st hatten.\n"
"Nur, das hier jetzt Gleichheiten von Zahlen statt Genau-Dann-Wenn-Aussagen stehen!\n"
"\n"
"**Robo**: Richtig. Und im Grunde macht das gar keinen Unterscheid.\n"
"Du kannst `=` und `â†”` praktisch mit `rw` praktisch gleich behandeln."
msgstr ""

#: Game.Levels.Predicate.L02_Rewrite
msgid "**Du**: Also auch `rw [hâ‚“]` und `rw [â† hâ‚“]`?\n"
"\n"
"**Robo**: Probiers doch einfach."
msgstr ""

#: Game.Levels.Predicate.L02_Rewrite
msgid "**Du**: Wie war das nochmals mit rÃ¼ckwÃ¤rts umschreiben?\n"
"\n"
"**Robo**: `â†` ist `\\l`. Und dann `rw [â† hâ‚“]`"
msgstr ""

#: Game.Levels.Predicate.L02_Rewrite
msgid ""
msgstr ""

#: Game.Levels.Predicate.L03_Rewrite
msgid "Rewrite"
msgstr ""

#: Game.Levels.Predicate.L03_Rewrite
msgid ""
msgstr ""

#: Game.Levels.Predicate.L03_Rewrite
msgid "$$\n"
"\\begin{aligned}\n"
"  a &= b \\\\\n"
"  a + a ^ 2 &= b + 1 \\\\\n"
"  \\vdash b + b ^ 2 &= b + 1\n"
"\\end{aligned}\n"
"$$"
msgstr ""

#: Game.Levels.Predicate.L03_Rewrite
msgid "**Du**: Hier muss man, glaube ich, einfach in Annahme `Â«{g}Â»` die\n"
"Variable `Â«{a}Â»` durch `Â«{b}Â»` ersetzen.\n"
"\n"
"**Robo**: Genau! Das machst du mit `rw [Â«{h}Â»] at Â«{g}Â»`."
msgstr ""

#: Game.Levels.Predicate.L03_Rewrite
msgid "**Robo**: Schau mal durch die Annahmen."
msgstr ""

#: Game.Levels.Predicate.L03_Rewrite
msgid "**Robo**: Noch ein Trick: Mit `rw [h] at *` kann man gleichzeitig mittels `h` **alle**\n"
"Annahmen und das Goal umschreiben."
msgstr ""

#: Game.Levels.Predicate.L04_Ring
msgid "NatÃ¼rliche Zahlen"
msgstr ""

#: Game.Levels.Predicate.L04_Ring
msgid ""
msgstr ""

#: Game.Levels.Predicate.L04_Ring
msgid "**Du**: Ich vermute, wenn ich zuerst alles so umschreibe, dass\n"
"das Beweisziel nur noch rechnen und umsortieren zu beweisen ist, erledigt `ring` den Rest!\n"
"\n"
"**Robo**: Genau. Und noch ein Trick: Zwei Schritte `rw [hâ‚]` und `rw [hâ‚‚]` kann man zu\n"
"einem einzigen Schritt zusammenfassen: `rw [hâ‚, hâ‚‚]`."
msgstr ""

#: Game.Levels.Predicate.L04_Ring
msgid ""
msgstr ""

#: Game.Levels.Predicate.L05_Rfl
msgid "Definitionally equal"
msgstr ""

#: Game.Levels.Predicate.L05_Rfl
msgid "Beim nÃ¤chsten Problem bekommt ihr ausnahmsweise Hilfe vom Publikum.\n"
"\n"
"**Alle**: `rfl`, `rfl`, â€¦"
msgstr ""

#: Game.Levels.Predicate.L05_Rfl
msgid "**Du**: Wieso nicht `ring`?\n"
"\n"
"**Robo**: Klar, `ring` wÃ¼rde normalerweise auch funktioneren. Aber ich wÃ¼rde mich hier\n"
"dem Mehrheitswillen beugen â€¦"
msgstr ""

#: Game.Levels.Predicate.L05_Rfl
msgid "**Robo**: Der Grund, warum hier ausnahmsweise auch mal `rfl` funktioniert hat, ist, dass auf beiden Seiten tatsÃ¤chlich *per Definition* dasselbe steht. Das soll heiÃŸen, wenn man links in `1 + 1` die Definition von `1` und `+ 1` einsetzt, und rechts die Definition von `2`, dann erhÃ¤lt man *buchstÃ¤blich* dasselbe (nÃ¤mlich `(0.succ).succ`).\n"
"\n"
"**Du**: Na schÃ¶n. Muss ich mir jetzt diese Definition von `2` merken?\n"
"\n"
"**Robo**: Ich glaube eher nicht."
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "Gerade/Ungerade"
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "Ihr habt nun alle Fragen aus dem kÃ¶niglichen PÃ¤ckchen beantwortet, und die Formalosophinnen\n"
"applaudieren. Dann wollen Sie aber auch noch ein paar Fragen stellen, aber sie kÃ¶nnen sich\n"
"nicht einigen, welche.\n"
"Ihr hÃ¶rt abwechselnd die Rufe â€Evenâ€œ und â€Oddâ€œ aus der Menge heraus. Deshalb zeigt dir Robo\n"
"vorsichtshalber schon einmal die entsprechenden Definitionen an:\n"
"\n"
"```\n"
"def Even (n : â„•) : Prop := âˆƒ r, n = r + r\n"
"```\n"
"\n"
"und\n"
"\n"
"```\n"
"def Odd (n : â„•) : Prop := âˆƒ r, n = 2 * r + 1\n"
"```\n"
"\n"
"SchlieÃŸlich taucht von irgendwo aus der Menge folgendes Papier auf:"
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "**Robo**: Wie du oben siehst, ist `Even n` dadurch definiert,\n"
"dass ein `r` existiert so dass `r + r = n` ist. Am besten\n"
"Ã¶ffnest du diese Definition mit `unfold Even at *` einmal.\n"
"Dann siehst du besser, was los ist."
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "Robo**: Am besten machst du auch noch `unfold Even at h`, damit du verstehst, was los ist."
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "Ein verwirrtes murmeln geht durch die Menge.\n"
"\n"
"**Du**: Warte mal, wieso ist `n^2 / 2` Ã¼berhaupt wieder eine natÃ¼rliche Zahl?\n"
"\n"
"**Robo**: Division auf `â„•` wird in Lean immer abgerundet. FÃ¼r `n = 1` steht da also\n"
"\n"
"```\n"
"1^2 = (1^2) / 2 + (1^2)/2\n"
"```\n"
"\n"
"was ausgerechnet `1 = 1/2 + 1/2 = 0 + 0` ist, du bist also auf dem Holzweg!"
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "**Du**: Also von `Â«{h}Â»` weiÃŸ ich jetzt, dass ein `r` existiert, so dass `r + r = n` â€¦\n"
"\n"
"**Robo**: Mit `rcases h with âŸ¨r, hrâŸ©` kannst du dieses `r` tatsÃ¤chlich einfÃ¼hren."
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "**Du**: Und jetzt muss ich eine passende Zahl finden, so dass `x + x = n^2`?\n"
"\n"
"**Robo**: Genau. Und mit `use _` gibst du diese Zahl an."
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "**Robo**: Also sowas Ã¤hnliches wie `use 4 * r ^ 3`, aber ich kann\n"
"dir leider nicht sagen, welche Zahl passt."
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "**Robo**: Das geht auch, jetzt musst du aber wirklich `use` verwenden."
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "**Du**: Ah, und jetzt `ring`!"
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "**Du**: Ah, und jetzt `ring`!\n"
"\n"
"**Robo**: Aber zuerst musst du noch mit\n"
"`rw` `n` durch `r + r` ersetzen, da `ring` das sonst nicht weiÃŸ."
msgstr ""

#: Game.Levels.Predicate.L06_Exists
msgid "Applaus!"
msgstr ""

#: Game.Levels.Predicate.L07_Exists
msgid "Gerade/Ungerade"
msgstr ""

#: Game.Levels.Predicate.L07_Exists
msgid "Sofort taucht das nÃ¤chste Blatt auf. Anscheinend hatten sie sich auf einen Kompromiss geeinigt."
msgstr ""

#: Game.Levels.Predicate.L07_Exists
msgid "**Robo**: mit `rcases h with âŸ¨r, hrâŸ©` kannst du wieder\n"
"das `r` nehmen, das laut Annahme existieren muss.\n"
"\n"
"**Robo**: Oder aber, du fÃ¤ngst mit `unfold Odd at *` an."
msgstr ""

#: Game.Levels.Predicate.L07_Exists
msgid "**Robo**: Mit `unfold Odd at *` Ã¶ffnest du alle Definitionen von `Odd`."
msgstr ""

#: Game.Levels.Predicate.L07_Exists
msgid "**Robo**: mit `rcases h with âŸ¨r, hrâŸ©` kannst du wieder\n"
"das `r` nehmen, das laut Annahme existieren muss."
msgstr ""

#: Game.Levels.Predicate.L07_Exists
msgid "**Robo**: Ich hab noch einen Trick auf Lager:\n"
"Wenn du jetzt noch nicht weiÃŸt, welche Zahl du einsetzen musst, kÃ¶nntest\n"
"du schon jetzt mit `rw [Â«{hr}Â»]` weitermachen â€¦"
msgstr ""

#: Game.Levels.Predicate.L07_Exists
msgid "**Robo**: Wenn du jetzt `ring` brauchst, dann schreibt es einfach alles in\n"
"Normalform um, das hilft beim Vergleichen."
msgstr ""

#: Game.Levels.Predicate.L07_Exists
msgid "**Robo**: Ich hab noch einen Trick auf Lager:\n"
"Wenn du jetzt noch nicht weiÃŸt, welche Zahl du einsetzen musst, kÃ¶nntest\n"
"Du schon jetzt mit `rw [Â«{hr}Â»]` weitermachenâ€¦"
msgstr ""

#: Game.Levels.Predicate.L07_Exists
msgid "**Robo**: Wenn du jetzt `ring` brauchst, dann schreibt es einfach alles in\n"
"Normalform um, das hilft beim Vergleichen."
msgstr ""

#: Game.Levels.Predicate.L07_Exists
msgid "Applaus!"
msgstr ""

#: Game.Levels.Predicate.L08_Forall
msgid "FÃ¼r alle"
msgstr ""

#: Game.Levels.Predicate.L08_Forall
msgid "Nach lÃ¤ngerem Durcheinander findet ein weiteres Blatt aus der Menge zu Euch."
msgstr ""

#: Game.Levels.Predicate.L08_Forall
msgid "**Du**: Das `âˆ€` heisst sicher \"fÃ¼r alle\".\n"
"\n"
"**Robo**: Und man schreibt `\\forall`. Ein `âˆ€ x, â€¦` im Beweisziel kannst du wie eine\n"
"Implikation mit `intro x` angehen."
msgstr ""

#: Game.Levels.Predicate.L08_Forall
msgid "Wieder werdet Ihr mit einem Applaus belohnt, und die Formalosophinnen\n"
"beratschlagen sich, was sie Euch noch vorlegen wollen."
msgstr ""

#: Game.Levels.Predicate.L09_PushNeg
msgid "PushNeg"
msgstr ""

#: Game.Levels.Predicate.L09_PushNeg
msgid "**Robo**: WÃ¤hrend wir warten, zeig ich dir vielleicht kurz, wie sich Negation mit Quantoren vertrÃ¤gt. Ich habe so ein GefÃ¼hl, dass wir das gleich brauchen werden."
msgstr ""

#: Game.Levels.Predicate.L09_PushNeg
msgid "**Du**: Was ist denn jetzt dieses P?\n"
"\n"
"**Robo**: P ist wieder irgendeine Aussage; eine Aussage Ã¼ber Objekte vom Typ `X`.\n"
"Zum Beispiel kÃ¶nnte `X` wieder der Typ der natÃ¼rlichen Zahlen sein.\n"
"Und `P x` kÃ¶nnte die Aussage sein:\n"
"Die natÃ¼rliche Zahl `x` ist gerade. Oder: `x` hat sieben Primfaktoren. Oder: `x` ist Robo's Lieblingszahl. Oder â€¦\n"
"\n"
"**Du**: Schon gut, ich glaub ich habs verstanden. `P` ist sozusagen eine Abbildung, die ein Element `x : X` nimmt und auf eine Aussage wirft.\n"
"\n"
"**Robo**: Ja, sozusagen.\n"
"\n"
"**Du**: Gut. Dann ist auch ziemlich klar, was hier die Aussage ist.\n"
"Und du wolltest mir jetzt verraten, wie ich das auf Leansch zeige?\n"
"\n"
"**Robo**: Genau. Was du brauchst, ist `push_neg`."
msgstr ""

#: Game.Levels.Predicate.L09_PushNeg
msgid "**Robo**: Das ist jetzt trivial, oder?"
msgstr ""

#: Game.Levels.Predicate.L09_PushNeg
msgid "**Robo**: `push_neg` schiebt von links nach rechts. Du kannst es hier also nicht auf\n"
"das Beweisziel anwenden, wohl aber auf `Â«{h}Â»`."
msgstr ""

#: Game.Levels.Predicate.L09_PushNeg
msgid "**Robo**: Gut gemacht. Intern benutzt `push_neg` Ã¼bringens zwei Lemmas:\n"
"\n"
" - `not_exists (A : Prop) : Â¬ (âˆƒ x, A) â†” âˆ€x, (Â¬A)`\n"
" - `not_forall (A : Prop) : Â¬ (âˆ€ x, A) â†” âˆƒx, (Â¬A)`\n"
"\n"
"Das erste Lemma ist die Aussage, die du gerade gezeigt hast.\n"
"\n"
"**Du**: Na toll. Ich habe die Aussage also gezeigt, indem ich sie benutzt habe â€¦\n"
"\n"
"**Robo**: :-) Hauptsache, Du merkst dir `push_neg`."
msgstr ""

#: Game.Levels.Predicate.L10_PushNeg
msgid "PushNeg"
msgstr ""

#: Game.Levels.Predicate.L10_PushNeg
msgid "Nach langem Hin und Her haben sich die Formalosophinnen endlich auf folgende Frage geeignet."
msgstr ""

#: Game.Levels.Predicate.L10_PushNeg
msgid "**Du**: Oha. Ganz links ein `Â¬`. Was du nicht sagst â€¦"
msgstr ""

#: Game.Levels.Predicate.L10_PushNeg
msgid "**Robo**: Dieser LÃ¶sungsweg scheint mir etwas zu schwierig.\n"
"Ich wÃ¼rde nochmal zurÃ¼ckgehen und `Odd` behalten,\n"
"damit man schlussendlich `even_iff_not_odd` brauchen kann!"
msgstr ""

#: Game.Levels.Predicate.L10_PushNeg
msgid "**Robo**: Dieser LÃ¶sungsweg scheint mir etwas zu schwierig.\n"
"Ich wÃ¼rde nochmal zurÃ¼ckgehen und `Odd` behalten,\n"
"damit man schlussendlich `even_iff_not_odd` brauchen kann!"
msgstr ""

#: Game.Levels.Predicate.L10_PushNeg
msgid "**Robo**: Jetzt brauchst du eine Zahl mit `use`, und danach vermutlich das\n"
"Lemma `even_iff_not_odd` brauchen.\n"
"\n"
"**Du**: KÃ¶nnte ich jetzt schon `even_iff_not_odd` anwenden?\n"
"\n"
"**Robo**: Nein, `rw` kann nicht innerhalb von Quantoren umschreiben.\n"
"\n"
"**Du**: Aber wie wÃ¼rde ich das machen?\n"
"\n"
"**Robo**: Zeig ich dir spÃ¤ter, nicht hier vor groÃŸem Publikum.\n"
"Ich wÃ¼rde jetzt lieber mit `use` eine richtige Zahl angeben, und danach umschreiben."
msgstr ""

#: Game.Levels.Predicate.L10_PushNeg
msgid "**Robo**: Gute Wahl! Jetzt kannst du `even_iff_not_odd` verwenden."
msgstr ""

#: Game.Levels.Predicate.L10_PushNeg
msgid "**Robo**: Gute Wahl! Jetzt kannst du `even_iff_not_odd` verwenden."
msgstr ""

#: Game.Levels.Predicate.L10_PushNeg
msgid "**Robo**: Gute Wahl! Jetzt kannst du `even_iff_not_odd` verwenden."
msgstr ""

#: Game.Levels.Predicate.L10_PushNeg
msgid "Die Formalosophinnen sind ganz begeistert.\n"
"Nachdem sich der Beifall gelegt hat, hast du auch einmal eine Frage.\n"
"\n"
"**Du**: Kann uns hier irgendjemand vielleicht ein bisschen Orientierung im Formaloversum geben?\n"
"\n"
"**Alle**: Ja, ja.\n"
"\n"
"**Du**: Wer denn?\n"
"\n"
"Die Frage war wieder zu konkret. Betretenes Schweigen."
msgstr ""

#: Game.Levels.Predicate.L11_DrinkersParadox
msgid "Drinker's Paradox"
msgstr ""

#: Game.Levels.Predicate.L11_DrinkersParadox
msgid "**Du**: KÃ¶nnte ihr eigentlich immer nur im Chor oder durcheinander reden?\n"
"\n"
"Wieder herrscht lÃ¤ngeres Schweigen. Dann auf einmal:\n"
"\n"
"**Alle**: Es gibt unter uns eine Person, wenn die redet, dann reden alle!\n"
"\n"
"Du kratzt Dich am Kopf.\n"
"\n"
"**Robo**: Ist doch klar. Das ist auf jedem bewohnten Planeten so!\n"
"\n"
"**Du**: Was??\n"
"\n"
"**Robo**: Das ist eine Version vom Drinker's Paradox! Kennst du das nicht? Dann lies\n"
"das am besten Mal in deiner Handbibliothek nach! *In jeder Bar gibt es eine Person mit\n"
"der Eigenschaft, dass alle trinken, wenn sie trinkt.* Genauer gesagt: in jeder nicht-leeren Bar.\n"
"\n"
"**Du**: Glaube ich nicht.\n"
"\n"
"**Robo**: Glaube ich schon. Ich glaube sogar, du kannst das beweisen. Hier, probier mal!"
msgstr ""

#: Game.Levels.Predicate.L11_DrinkersParadox
msgid "**Du**: Also, `isDrinking` ist wieder so ein PrÃ¤dikat â€¦\n"
"Wenn `p` eine Person ist, ist `isDrinking p` eine Aussage,\n"
"die wahr oder falsch ist. Soweit so gut.\n"
"Und was bedeutet `Nonempty People`?\n"
"\n"
"**Robo**: Das ist Leansch fÃ¼r nicht-leer. Das heiÃŸt einfach, es gibt mindestens eine Person.\n"
"Mit `rcases Â«{h_nonempty}Â» with âŸ¨persâŸ©` kannst du dir eine `pers : Person` aussuchen,\n"
"die es per Annahme gibt.\n"
"\n"
"**Du**: Und wie fang ich jetzt an?\n"
"\n"
"**Robo**: Ich sagte doch, schau am besten Mal in deine Handbibliothek.\n"
"Wenn ich mich richtige erinnere, hilft eine Fallunterscheidung, ob die Aussage\n"
"`âˆ€ (y : People), isDrinking y` wahr oder falsch ist."
msgstr ""

#: Game.Levels.Predicate.L11_DrinkersParadox
msgid "**Robo**: Schau mal `by_cases` an."
msgstr ""

#: Game.Levels.Predicate.L11_DrinkersParadox
msgid "**Du**: Und wen nehm ich jetzt?\n"
"\n"
"**Robo**: Wie gesagt, `rcases h_nonempty with âŸ¨dâŸ©` gibt dir eine x-beliebige Person `d`."
msgstr ""

#: Game.Levels.Predicate.L11_DrinkersParadox
msgid "**Robo**: Du kÃ¶nntest hier mit `push_neg at Â«{h}Â»` weitermachen."
msgstr ""

#: Game.Levels.Predicate.L11_DrinkersParadox
msgid "**Du**: Also nach `Â«{h}Â»` existiert ja eine Person, die nicht trinkt. KÃ¶nnte ich diese brauchen damit die Aussage trivialerweise wahr wird?\n"
"\n"
"**Robo**: Schau dir mal an wie man `rcases` auf die Annahme `Â«{h}Â»` anwenden kÃ¶nnte."
msgstr ""

#: Game.Levels.Predicate.L11_DrinkersParadox
msgid "**Robo**: Was siehst du, wenn du `Â«{hp}Â»` und `Â«{hp'}Â»` anschaust?"
msgstr ""

#: Game.Levels.Predicate.L11_DrinkersParadox
msgid "`Nonempty U` ist eine Instanz, die aussagt, dass `U` mindestens ein Element\n"
"enthÃ¤lt.\n"
"\n"
"Wenn `h : Nonempty U`, dann kriegt man mit `rcases h with âŸ¨dâŸ©` eine solches Element `d : U`."
msgstr ""

#: Game.Levels.Predicate.L11_DrinkersParadox
msgid "**Du**: Verstehe. Aber jetzt habe ich auch wirklich genug von dieser PrÃ¤dikatenlogik!\n"
"\n"
"**Robo**: Dann fliegen wir am besten weiter! Aber bevor du fragst â€“ hier ist wieder ein Ãœberblick, was du auf diesem Planeten gelernt hast.\n"
"\n"
"\n"
"|               | Beschreibung                |\n"
"|:--------------|:----------------------------|\n"
"| `â„•`           | Die natÃ¼rlichen Zahlen.     |\n"
"| `âˆƒ`           | Existential-Quantifier      |\n"
"| `âˆ€`           | Forall-Quantifier           |\n"
"| `Even n`      | `n` ist gerade              |\n"
"| `Odd n`       | `n` ist ungerade            |\n"
"\n"
"|       | Taktik                    | Beispiel                                               |\n"
"|:------|:--------------------------|:-------------------------------------------------------|\n"
"| *12á¶œ* | `rw`                      | Umschreiben mit Gleichungen.                           |\n"
"| 13    | `ring`                    | LÃ¶st Gleichungen mit `+, -, *, ^`.                     |\n"
"| 14    | `unfold`                  | Setzt visuell die Bedeutung einer Definition ein.      |\n"
"| 15    | `use`                     | Um ein `âˆƒ` im Goal anzugehen.                          |\n"
"| *7á¶œ*  | `rcases h with âŸ¨x, hxâŸ©`   | Um ein `âˆƒ` in den Annahmen zu zerlegen.                |\n"
"| *8áµ‡*  | `intro`                   | Um ein `âˆ€` im Goal anzugehen.                          |\n"
"| 16    | `push_neg`                | FÃ¼r `Â¬âˆƒ` und `Â¬âˆ€` im Goal.                             |"
msgstr ""

#: Game.Levels.Predicate
msgid "Quantus"
msgstr ""

#: Game.Levels.Predicate
msgid "Auf Quantus erwartet Euch bereits eine groÃŸe Ansammlung von Formalosopheninnen.\n"
"Sie reden alle wild durcheinander und Ihr habt Probleme, Euch Ã¼berhaupt GehÃ¶r zu verschaffen.\n"
"Robo produziert schlieÃŸlich ein lautes Gong-GerÃ¤usch, das sie kurzzeitig zur Ruhe bringt.\n"
"\n"
"**Du**: Wir haben einen Brief fÃ¼r Eure KÃ¶nigin. KÃ¶nntet Ihr uns zu Eurer KÃ¶nigin fÃ¼hren?\n"
"\n"
"**Alle** *(im Chor)*: Wir sind schon alle hier!\n"
"\n"
"**Du**: Okay. Und wer von Euch ist die KÃ¶nigin?\n"
"\n"
"Nun herrscht betretenes Schweigen. Alle zucken mit den Schultern.\n"
"\n"
"**Du**: Habt Ihr Ã¼berhaupt eine KÃ¶nigin?\n"
"\n"
"**Alle** *(im Chor)*: Ja, ja. Wir haben eine KÃ¶nigin, wir haben eine KÃ¶nigin.\n"
"\n"
"**Robo** *(zu dir)*: Ich fasse mal zusammen. Es existiert eine KÃ¶nigin, aber keiner weiÃŸ, wer\n"
"sie ist â€¦\n"
"\n"
"**Du**: Ist das nicht ein Widerspruch?\n"
"\n"
"**Robo**: Fragst du, du als Mathematiker? Nein, das ist kein Widerspruch. Das ist einfach eine\n"
"â€reine Existenzaussageâ€œ.\n"
"\n"
"Du bist dir nicht ganz sicher, wie ernst er das meint.\n"
"\n"
"**Du**: Dann schlage ich vor, wir Ã¼bergeben das PÃ¤ckchen einfach an *alle* Bewohner. Dann haben\n"
"wir es ja insbesondere der KÃ¶nigin Ã¼bergeben.\n"
"\n"
"**Du** *(in die Menge)*: Wir haben Euch ein PÃ¤ckchen von Implis gebracht. Hier, das ist fÃ¼r Euch.\n"
"\n"
"Robo spuckt es aus, wirft es in die Menge, und die Formalosophinnen reiÃŸen es auf. Darin befinden\n"
"sich ein paar lose Seiten, die sie sofort eingehend studieren.\n"
"\n"
"Zwei Minuten spÃ¤ter liegen die Seiten wieder bei Euch. Es sind wieder mathematische Probleme.\n"
"Und die Formalosophinnen wollen sehen, wie Ihr sie lÃ¶st."
msgstr ""

#: Game.Levels.Contradiction.L05_Contrapose
msgid "Kontraposition"
msgstr ""

#: Game.Levels.Contradiction.L05_Contrapose
msgid "**Benedictus**: Gut, hier ist die angekÃ¼ndigte Frage. Versucht mal einen *direkten*\n"
"Beweis, ohne `by_contra`."
msgstr ""

#: Game.Levels.Contradiction.L05_Contrapose
msgid "**Robo**: Ich schlage vor, wir fÃ¼hren das auf das Lemma `even_square` zurÃ¼ck, das wir auf\n"
"Quantus schon gezeigt hatten. Hier steht ja im Grunde `Odd (n^2) â†’ Odd n`. Und unter\n"
"Kontraposition ist das Ã¤quivalent zu `Even n â†’ Even (n^2)`.\n"
"\n"
"**Du**: Richtig. Von hinten durch die Brust â€¦ Aber warte, im Moment steht da doch gar kein `â†’`.\n"
"\n"
"**Robo**: Erinner dich an `revert`. Mit `revert Â«{h}Â»` kannst du die Annahme `Â«{h}Â»` als\n"
"Implikationsannahme ins Beweissziel schieben."
msgstr ""

#: Game.Levels.Contradiction.L05_Contrapose
msgid "**Du**: Und jetzt kann ich dieses Kontrapositionslemma anwenden? Wie hieÃŸ das noch einmal?\n"
"\n"
"**Robo**: TatsÃ¤chlich kannst auch einfach `contrapose` schreiben."
msgstr ""

#: Game.Levels.Contradiction.L05_Contrapose
msgid "**Robo**: Vielleicht hilft jetzt `even_iff_not_odd` weiter?"
msgstr ""

#: Game.Levels.Contradiction.L05_Contrapose
msgid "**Du**: Das sieht schon ganz gut aus. Jetzt kann ich tatsÃ¤chlich das alte Lemma\n"
"`even_square` anwenden!"
msgstr ""

#: Game.Levels.Contradiction.L05_Contrapose
msgid "**Benedictus**: Hervorragend! Ich glaube, damit seid Ihr jetzt ganz gut gewappnet."
msgstr ""

#: Game.Levels.Contradiction.L06_Summary
msgid "Contradiction"
msgstr ""

#: Game.Levels.Contradiction.L06_Summary
msgid "**Du**: Aber hÃ¤tten wir die letzte Aufgabe nicht genauso gut per Widerspruch beweisen kÃ¶nnen?\n"
"\n"
"**Benedictus**: Klar. Ich dachte nur, ein zweiter Widerspruchsbeweis wÃ¤re langweilig. Aber Ihr kÃ¶nnt die Aufgabe gern noch einmal probieren. Hier, ich gebe Sie Euch mit auf die Reise. Aber nun seht zu, dass Ihr weiterkommt!"
msgstr ""

#: Game.Levels.Contradiction.L06_Summary
msgid "Sobald Ihr Euch sicher vom Gravitationsfeld des Asteroiden befreit habt, beugt Ihr\n"
"Euch wieder Ã¼ber die Aufgabe.\n"
"\n"
"**Robo**: Okay, also diesmal fangen wir mit `by_contra g` an!"
msgstr ""

#: Game.Levels.Contradiction.L06_Summary
msgid "**Robo**: Jetzt wÃ¼rde ich einen Widerspruch zu `Odd (n ^ 2)` fÃ¼hren."
msgstr ""

#: Game.Levels.Contradiction.L06_Summary
msgid "**Robo**: Also `suffices d : Â¬ Odd (n ^ 2)`."
msgstr ""

#: Game.Levels.Contradiction.L06_Summary
msgid "**Robo**: Bravo! Hier ein Ãœberblick, was uns Benediktus gezeigt hat.\n"
"\n"
"\n"
"|       | Taktik          | Beispiel                                               |\n"
"|:------|:----------------|:-------------------------------------------------------|\n"
"| 17    | `have`          | Zwischenresultat annehmen                              |\n"
"| 18    | `suffices`      | Zwischenresultat annehmen                              |\n"
"| 19    | `by_contra`     | Widerspruch *(startet einen Widerspruchsbeweis)*       |\n"
"| *3*   | `contradiction` | *(schliesst einen Widerspruchsbeweis)*                 |\n"
"| 20    | `contrapose`    | Kontraposition                                         |\n"
"| *9*   | `revert`        | nÃ¼tzlich, um danach `contrapose` anzuwenden            |"
msgstr ""

#: Game.Levels.Contradiction
msgid "Spinoza"
msgstr ""

#: Game.Levels.Contradiction
msgid "**Robo**: Ich glaube, das ist Spinoza, einer der ganz wenigen Asteroiden vom Type QED. Schnell. Wir mÃ¼ssen uns ein bisschen beeilen, sonst verpassen wir ihn.\n"
"\n"
"Eine halbe Stunde spÃ¤ter seid ihr gelandet. Sehr einladend wirkt Spinoza nicht. Seine gesamte OberflÃ¤che ist von feinem, rÃ¶tlichen Sand bedeckt.\n"
"Ein einziger, einsamer Formalosoph, der sich als Benedictus vorstellt, erwartet euch.\n"
"\n"
"**Benedictus**: SchÃ¶n, dass Ihr gekommen seid! Ich habe schon auf Euch gewartet!\n"
"\n"
"**Du**: Hast du auch ein paar dringende Fragen â€¦ ?\n"
"\n"
"**Benedictus**: Ach nein, aus dem Alter bin ich heraus. Aber ich kann mir denken, wie es Euch auf Implis und Quantus ergangen ist. Und glaubt, mir auf den anderen Planeten wird es nicht viel besser. Aber ich kann Euch vielleicht ein bisschen vorbereiten.\n"
"\n"
"**Du**: KÃ¶nnen wir nicht einfach hier bleiben und uns ein wenig ausruhen?\n"
"\n"
"Benedictus schÃ¼ttelt den Kopf.\n"
"\n"
"**Benedictus**: Nein. Spinoza vertrÃ¤gt keine drei Bewohner. Und Ihr mÃ¼sst bald wieder weiter, sonst wird der Weg zu weit. Wir kommen nur alle 400 Jahre bei den Planeten vorbei."
msgstr ""

#: Game.Levels.OLDFunction.L01_Function
msgid "Anonyme Funktionen"
msgstr ""

#: Game.Levels.OLDFunction.L01_Function
msgid "Auf die Frage hin, ob sie von einer Bibliothek wisse, erzÃ¤hlt euch das kleine MÃ¤dchen,\n"
"dass es auf der Insel nur einen gÃ¤be, aber sie bedrÃ¤ngt euch so mit einer Frage,\n"
"dass sie euch gar nicht sagt, wo dieser zu finden sei."
msgstr ""

#: Game.Levels.OLDFunction.L01_Function
msgid "**Robo**: `f : â„¤ â†’ â„¤` ist die Notation fÃ¼r eine Funktion und `f x` ist diese Funktion\n"
"angewendet auf ein Element `(x : â„¤)`.\n"
"\n"
"**Du**: War `â†’` nicht eben noch eine Implikation?\n"
"\n"
"**Robo**: Doch, die brauchen das gleiche Zeichen fÃ¼r beides.\n"
"\n"
"**Du**: Dann ist `f : â„¤ â†’ â„¤` also einfach abstrakt irgendeine Funktion,\n"
"wie definiere ich aber jetzt konkret eine Abbildungsvorschrift?\n"
"\n"
"**Robo**: Man kennt hier eine Notation fÃ¼r eine anonyme Funktion:\n"
"`fun (x : â„¤) â†¦ x ^ 2` ist\n"
"\n"
"$$\n"
"\\begin{aligned}\n"
"f : \\mathbb{â„¤} &\\to \\mathbb{â„¤} \\\\\n"
"x &\\mapsto x ^ 2\n"
"\\end{aligned}\n"
"$$\n"
"\n"
"**Robo**: PS, `â†¦` ist `\\mapsto`. Aber man kann auch stattdessen `=>` benutzen."
msgstr ""

#: Game.Levels.OLDFunction.L01_Function
msgid "**Du**: Ja aber was mach ich damit?\n"
"\n"
"**Robo**: Wie immer gehst du ein `âˆƒ` mit `use â€¦` an."
msgstr ""

#: Game.Levels.OLDFunction.L01_Function
msgid "**Du**: Zu was sich das wohl vereinfacht?"
msgstr ""

#: Game.Levels.OLDFunction.L01_Function
msgid "**Du**: Zu was sich das wohl vereinfacht?"
msgstr ""

#: Game.Levels.OLDFunction.L01_Function
msgid "Das MÃ¤dchen wird kurz ruhig, dann beginnt es zu lÃ¤cheln und zeigt strahlend\n"
"in eine Richtung. Ihr folgt ihrem Finger und euch fÃ¤llt in weiter ferne eine pompÃ¶se Struktur\n"
"auf einem flachen HÃ¼gel auf."
msgstr ""

#: Game.Levels.OLDFunction.L02_Let
msgid "let"
msgstr ""

#: Game.Levels.OLDFunction.L02_Let
msgid "Ihr macht euch auf in Richtung Bibliothek entlang kleiner Pfade zwischen verschiedensten Behausungen.\n"
"\n"
"**Du**: Sag mal, ich weiÃŸ jetzt dass ich eine Funktion als `fun x â†¦ x - 1` definieren kann,\n"
"aber wie kann ich ihr einen Namen geben?\n"
"\n"
"**Robo**: Wenn jemand hier lokal eine Funktion definiert, werden die dir\n"
"`f : â„¤ â†’ â„¤ := fun x â†¦ x - 1; â€¦` als Objekt mitgeben.\n"
"\n"
"**Robo**: Im Beweis hingegen, kannst du dir mit `let f := fun (x : â„¤) â†¦ x - 1` selbst eine\n"
"temporÃ¤re Definition machen."
msgstr ""

#: Game.Levels.OLDFunction.L02_Let
msgid "**Du**: Ist `g âˆ˜ Â«{f}Â»` Komposition von Funktionen?\n"
"\n"
"**Robo**: Richtig! Das schreibt man mit `\\comp`.\n"
"\n"
"**Du** Und hier kÃ¶nnte ich also zuerst\n"
"`let g := fun (x : â„¤) â†¦ _` definieren, anstatt direkt\n"
"`use fun (x : â„¤) â†¦ _`?\n"
"\n"
"**Robo**: Genau! Das ist zwar praktisch das gleiche, aber kann manchmal nÃ¼tzlich sein."
msgstr ""

#: Game.Levels.OLDFunction.L02_Let
msgid "**Robo**: `((fun (x : â„¤) â†¦ x - 3) âˆ˜ f) x` ist per Definition `(fun (x : â„¤) â†¦ x - 3) (f x)`,\n"
"aber mit `rw [comp_apply]` kann man das explizit umschreiben, aber `simp` kennt das\n"
"Lemma auch."
msgstr ""

#: Game.Levels.OLDFunction.L02_Let
msgid "**Robo**: gute Wahl! Jetzt kannst du diese mit `use g` benutzen."
msgstr ""

#: Game.Levels.OLDFunction.L02_Let
msgid "**Robo**: `(Â«{g}Â» âˆ˜ f) x` ist per Definition `Â«{g}Â» (f x)`, aber mit\n"
"`rw [comp_apply]` kann man das explizit umschreiben, aber `simp` kennt das\n"
"Lemma auch."
msgstr ""

#: Game.Levels.OLDFunction.L02_Let
msgid "**Robo**: Das sieht nach einem Fall fÃ¼r `ring` aus."
msgstr ""

#: Game.Levels.OLDFunction.L02_Let
msgid "**Robo**: `ring` sieht durch lokale Definitionen wie\n"
"`Â«{f}Â»` und `Â«{g}Â»` hindurch,\n"
"du kannst es also direkt benutzen."
msgstr ""

#: Game.Levels.OLDFunction.L02_Let
msgid "Sagt dass `(f âˆ˜ g) x` das gleiche ist wie `f (g x)`."
msgstr ""

#: Game.Levels.OLDFunction.L02_Let
msgid "**Du**: Dann verstehst du etwas Mathe?\n"
"\n"
"**Robo**: Ich hatte ja keine Ahnung ob die generierte Aufgabe beweisbar istâ€¦ aber offenbar\n"
"hatte ich GlÃ¼ck.\n"
"\n"
"Und damit erreicht ihr den HÃ¼gel mit der Bibliothek."
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "StÃ¼ckweise Definition"
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "Endlich kommt ihr zur Bibliothek. Komischerweise stehen an der TÃ¼r\n"
"zwei WÃ¤chtern. Der eine hat ein `f` auf seiner Brustplatte, der andere\n"
"ein `g` eingraviert. dieser gibt dir ein Blatt mit einer langen Zeilen am oberen Ende."
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "**Robo**: Schau mal, die beiden haben zwei Funktionen, eine davon mit stÃ¼ckweiser Definition.\n"
"\n"
"**Du**: Also, ich soll zeigen, dass die beiden vertauschbar sind?\n"
"\n"
"**Robo**: Genau, am besten wÃ¤hlst du mit `funext x` ein beliebiges Element aus, und zeigst das\n"
"dann fÃ¼r dieses."
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "**Du**: Ah und jetzt kann ich erst einmal `(g âˆ˜ f) Â«{x}Â»` zu `g (f Â«{x}Â»)` umschreiben?\n"
"\n"
"**Robo**: Mit `simp` klappt das."
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "**Robo**: Jetzt kannst du nÃ¤mlich eine Fallunterscheidung\n"
"machen, `by_cases h : 0 â‰¤ Â«{x}Â»`.\n"
"\n"
"**Du**: Damit krieg ich die FÃ¤lle `0 â‰¤ Â«{x}Â»` und `Â«{x}Â» < 0`?\n"
"\n"
"**Robo**: Genau! Oder prÃ¤ziser `0 â‰¤ Â«{x}Â»` und `Â¬(0 â‰¤ Â«{x}Â»)`. Das ist nicht ganz das gleiche,\n"
"und man kÃ¶nnte mit dem Lemma `not_le` zwischen `Â¬(0 â‰¤ Â«{x}Â»)` und `0 > Â«{x}Â»` wechseln."
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "**Du**: Jetzt muss ich wohl doch mal die Definitionen brauchen.\n"
"\n"
"**Robo**: Dann brauch mal `simp [f, g]`!"
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "**Robo**: Jetzt hast du `rw [if_pos Â«{h}Â»]` zur VerfÃ¼gung um das if-then-else zu\n"
"reduzieren."
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "**Robo**: Nochmals `simp [f, g]`."
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "**Du**: Ah und die Verneinung von `if_pos` ist sicher â€¦"
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "**Robo**: `if_neg`, genau!"
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "Zufrieden tauschen die beiden WÃ¤chter ihren Platz und geben so dabei den\n"
"Durchgang frei."
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "Wenn `h : A` ein beweis der Aussage `A` ist, dann reduziert\n"
"`rw [if_pos h]` reduziert eine Aussage `if A then B else C` zu `B`.\n"
"\n"
"Umgekehrt kann man `if_neg` verwenden wenn `h : Â¬ A`."
msgstr ""

#: Game.Levels.OLDFunction.L03_Piecewise
msgid "Wenn `h : Â¬ A` ein Beweis ist, dass Aussage `A` falsch ist, dann reduziert\n"
"`rw [if_neg h]` eine Aussage `if A then B else C` zu `C`.\n"
"\n"
"Umgekehrt kann man `if_pos` verwenden wenn `h : A`."
msgstr ""

#: Game.Levels.OLDFunction.L04_Injective
msgid "InjektivitÃ¤t"
msgstr ""

#: Game.Levels.OLDFunction.L04_Injective
msgid "Ihr lÃ¤uft durch verschiedenste GÃ¤nge der Bibliothek, allesamt mit BÃ¼chern entlang der WÃ¤nde.\n"
"\n"
"**Du**: Wenn wir wÃ¼ssten, dass nur ein mÃ¶glicher Weg hierhin fÃ¼hrt, kÃ¶nnten wir\n"
"ausschliessen, dass wir im Kreis laufen.\n"
"\n"
"PlÃ¶tzlich begegnet ihr einem Ã¤lteren Wesen mit Fakel. Auf die Frage antwortet es mit folgendem:"
msgstr ""

#: Game.Levels.OLDFunction.L04_Injective
msgid "**Robo**: `Injective` ist als `âˆ€ {a b : U}, f a = f b â†’ a = b`\n"
"definiert, also kannst du mit `intro` anfangen.\n"
"\n"
"**Du**: Und wenn ich das nicht weiss?\n"
"\n"
"**Robo**: Dann schaust du mit `unfold Injective` in die Definition rein."
msgstr ""

#: Game.Levels.OLDFunction.L04_Injective
msgid "**Du**: Jetzt will ich wohl mit der Definition von `Â«{f}Â»` die\n"
"Annahme `Â«{ha}Â»` vereinfachen."
msgstr ""

#: Game.Levels.OLDFunction.L04_Injective
msgid "**Du** Woa das war ja einfach!"
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "Monotone Funktionen"
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "Sofort hakt die Ã¤ltere Gestalt nach:"
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "**Du**: Hmm, das ist etwas schwierigerâ€¦\n"
"\n"
"**Robo**: Aber ich hab einen Trick auf Lager:\n"
"Das Lemma `StrictMono.injective` sagt, dass jede strikt monotone Funktion injektive ist,\n"
"und ich habe das GefÃ¼hl Monotonie ist hier einfacher zu zeigen."
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "**Robo**: `apply` ist wonach du suchst."
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "**Robo**: Ich glaube, dieser Weg ist zu steinig. Fang doch nochmals von vorne an!"
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "**Robo**: Ich glaube, dieser Weg ist zu steinig. Fang doch nochmals von vorne an!"
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "**Du**: Jetzt mÃ¶chte ich strikte Monotonie von `n ^ 3` und `n + 3` separat zeigen,\n"
"schliesslich scheint es mir als wÃ¤r das zweite wieder einfach.\n"
"\n"
"**Robo**: DafÃ¼r hab ich `StrictMono.add` bereit!"
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "**Du**: Hmm, darauf hab ich jetzt wenig Lust. Gibt's dafÃ¼r auch was? Das gilt ja nur\n"
"wenn der Exponent ungerade ist.\n"
"\n"
"**Robo**: Du kÃ¶nntest mal `Odd.strictMono_pow` versuchenâ€¦"
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "**Du**: Ist das nicht ne TrivialitÃ¤t? Warte mal!"
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "**Du**: Ha! Und dieser Teil funktioniert sicher gleich wie InjektivitÃ¤t vorhin!"
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "**Du**: oder â€¦?\n"
"\n"
"**Robo**: Doch, doch. Schau mal mit `unfold` hinein in die Definition."
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "Dieses Lemma sagt `StrictMono f â†’ Injective f`."
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "FÃ¼r ungerades `n` is `x â†¦ x ^ n` strikt monoton.\n"
"\n"
"*Bemerkung*: Das Lemma ist im namespace `Odd`, damit man `hn.strictMono_pow` fÃ¼r den\n"
"Beweis `hn : Odd n` schreiben kÃ¶nnte."
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "Wenn `f,g` beide strikt monoton sind, dann ist es `f + g` auch."
msgstr ""

#: Game.Levels.OLDFunction.L05_Injective
msgid "**Du**: Danke vielmals!\n"
"\n"
"Und damit lÃ¤sst das Wesen mitten im Gang stehen, wo es weiter Ã¼ber InjektivitÃ¤t nachdenkt."
msgstr ""

#: Game.Levels.OLDFunction.L06_Injective
msgid "Nicht Injektiv"
msgstr ""

#: Game.Levels.OLDFunction.L06_Injective
msgid "Weiterirrend kommt ihr an eine Verzweigung.\n"
"\n"
"**Robo**: Sieht beides gleich aus.\n"
"\n"
"Ein paar Schritte in den linken Korridor hinein seht ihr auf dem Boden ein Blatt mit Gekritzel.\n"
"\n"
"\n"
"**Du**: Hier haben wir wieder eine stÃ¼ckweise Funktion\n"
"\n"
"$$\n"
"f(n) = \\begin{cases}\n"
"    n^2 & \\text{falls } n \\text{ gerade} \\\\\n"
"    n+1 & \\text{andernfalls.}\n"
"\\end{cases}\n"
"$$\n"
"\n"
"Darunter steht in leicht leuchtender Schrift:"
msgstr ""

#: Game.Levels.OLDFunction.L06_Injective
msgid "**Robo**: Das ist sicher ein Hinweis.\n"
"\n"
"**Du**: Aber `Â¬ Injective` sagt mir nichtsâ€¦\n"
"\n"
"**Robo**: KÃ¶nntest du etwas mit `Â¬ âˆ€` anfangen? Dann kÃ¶nntest du ja `Injektive` zuerst Ã¶ffnen.\n"
"\n"
"**Du**: DarÃ¼ber haben wir doch mal was gelerntâ€¦"
msgstr ""

#: Game.Levels.OLDFunction.L06_Injective
msgid "**Robo**: Das war `push_neg`."
msgstr ""

#: Game.Levels.OLDFunction.L06_Injective
msgid "**Robo**: Das war `push_neg`."
msgstr ""

#: Game.Levels.OLDFunction.L06_Injective
msgid "**Du** Jetzt muss ich einfach ein Gegenbeispiel nennen, oder?\n"
"\n"
"**Robo** Genau! Welche beiden Zahlen mÃ¶chtest du denn verwenden?"
msgstr ""

#: Game.Levels.OLDFunction.L06_Injective
msgid "Als ihr das Problem gelÃ¶st habt, erschleicht euch ein starkes\n"
"GefÃ¼hl, dass dies der falsche Weg ist.\n"
"Also geht ihr zurÃ¼ck und nehmt die rechte Gabelung."
msgstr ""

#: Game.Levels.OLDFunction.L07_Surjective
msgid "Surjektive"
msgstr ""

#: Game.Levels.OLDFunction.L07_Surjective
msgid "Endlich kommt ihr in einen groÃŸe, beleuchteten zentralen Raum.\n"
"Alle WÃ¤nde sind voll mit BÃ¼chern und\n"
"in der Mitte sitzt an einem einsamen\n"
"Tisch ein Gelehrter, der tatsÃ¤chlich das gesuchte Buch zeigen kann.\n"
"\n"
"Bevor er dieses aushÃ¤ndigt, will er aber folgendes wissen:"
msgstr ""

#: Game.Levels.OLDFunction.L07_Surjective
msgid "**Robo**: Die Definition von `Surjective f` ist `âˆ€ y, (âˆƒ x, f x = y)`.\n"
"\n"
"**Du**: Dann kann ich das auch einfach wie Quantifier behandeln?\n"
"\n"
"**Robo**: SchieÃŸ drauf los!"
msgstr ""

#: Game.Levels.OLDFunction.L07_Surjective
msgid "**Du**: das is doch eigentlich ganz einfachâ€¦ Kann man das denn\n"
"noch weiter vereinfachen?\n"
"\n"
"**Robo**: Wenn du `Â«{f}Â»` auch einsetzt vermutlich schon."
msgstr ""

#: Game.Levels.OLDFunction.L07_Surjective
msgid "Der Gelehrte hÃ¤ndigt euch schmunzelnd das Buch aus."
msgstr ""

#: Game.Levels.OLDFunction.L08_Bijective
msgid "BijektivitÃ¤t"
msgstr ""

#: Game.Levels.OLDFunction.L08_Bijective
msgid "**Du**: Ehm, und wie kommen wir da wieder raus?\n"
"\n"
"**Gelehrter**: Gerne zeige ich euch den Weg, nachdem ihr mir auch noch folgendes erklÃ¤rt:"
msgstr ""

#: Game.Levels.OLDFunction.L08_Bijective
msgid "**Robo** *(flÃ¼sternd)*: `Bijectve f` ist als `Injective f âˆ§ Surjective f` definiert.\n"
"\n"
"**Du**: Dann ist das ja ganz simpel!"
msgstr ""

#: Game.Levels.OLDFunction.L08_Bijective
msgid "Zufrieden drÃ¼ckt euch der Gelehrte eine neue Fackel in die Hand und\n"
"zeigt euch den Weg nach drauÃŸen."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "Inverse"
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "Eigentlich hast du nur beilÃ¤ufig Robo gefragt, ob bijektiv nicht auch bedeute, dass\n"
"eine Inverse Funktion existiere. Jetzt steht ihr aber schon seit einer halben Stunde rum\n"
"und der Gelehrte mÃ¶chte wissen, wie das den genau ginge.\n"
"\n"
"Offensichtlich kennt er diese Aussage als `Function.bijective_iff_has_inverse` aus seinen BÃ¼chern,\n"
"aber er mÃ¶chte, dass du ihm das hier und jetzt nochmals von Grund auf zeigst."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Du**: Nah da sagt mir so manches nichts, aber ich kann ja mal mit dem `â†”` anfangen,\n"
"das kenn ich ja schon."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: Tipp. Teil doch `Bijective` mit `rcases Â«{h}Â» with âŸ¨hI, hSâŸ©` in\n"
"`Injective` und `Surjective` auf!"
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Du**: Ja was ist eigentlich die Inverse von `Â«{f}Â»`â€¦?\n"
"\n"
"**Robo**: Hast du eine Idee?\n"
"\n"
"**Du**: Also von der SurjektivitÃ¤t weiss ich, dass fÃ¼r alle `y` ein Urbild existiert\n"
"und mit der InjektivitÃ¤t kÃ¶nnte ich dann zeigen, dass dieses eindeutig ist.\n"
"\n"
"**Robo**: Also Schritt fÃ¼r Schritt: Mit `fun y â†¦ (Â«{hS}Â» y).choose ` kannst du eine Funktion\n"
"definieren, die `y` irgendein Urbild zuweist.\n"
"\n"
"**Du**: Die ist aber nicht wohldefiniert, oder?\n"
"\n"
"**Robo**: In der Mathe nicht. In Lean geht das ganz gut, aber es ist dann unmÃ¶glich etwas\n"
"darÃ¼ber zu beweisen, wenn es mehrere MÃ¶glichkeiten gÃ¤be."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: fang mal mit `intro` an."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: Gut! Auf zum Rechtsinversen! Fang auch hier wieder mit `intro` an."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: fang mal mit `intro` an."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Du**: kompliziert.\n"
"\n"
"**Robo**: Aber mit `simp` kannst du es ja etwas vereinfachen."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Du**: Das kann ich jetzt nicht zeigen solange ich nicht weiss, dass nur genau ein\n"
"Urbild besteht.\n"
"\n"
"**Robo**: Dann wende doch mit `apply Â«{hI}Â»` die InjektivitÃ¤t an!"
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: Dies ist jetzt eine etwas tautologische Aussage. In Lean ist das\n"
"`Exists.choose_spec`. Konkret `apply Exists.choose_spec (Â«{hS}Â» (f x))`."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: Gut! Auf zum Rechtsinversen! Fang auch hier wieder mit `intro` an."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Du**: Kann ich das vereinfachen?"
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Du**: Also wieder `Exists.choose_spec`?\n"
"\n"
"**Robo**: Genau! Diesmal mit dem Argument `(Â«{hS}Â» x)`."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: Die eine Richtung ist gezeigt. Jetzt auf zur RÃ¼ckrichtung!"
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: Zerlege `Â«{h}Â»` noch soweit du kannst!"
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: Das UND auch noch!"
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: Das `Bijective` kannst du auch aufteilen."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: InjektivitÃ¤t ist der schwierige Teil. Fang mal an mit `intro`."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: Im nÃ¤chsten Schritt must du `LeftInverse` brauchen um das Goal\n"
"zu `g (f a) = g (f b)` zu wechseln: schau mal was du mit\n"
"`have w := Â«{hL}Â» Â«{a}Â»` kriegst und ob du das mit `rw` benutzen kannst."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Du**: Wenn die Argumente `f a = f b` gleich sind, ist dann auch `g (f a) = g (f b)`,\n"
"wie sag ich das?\n"
"\n"
"**Robo**: Also wenn du `f a = f b` hast, kannst du ja auch einfach damit umschreiben."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "Die SurjektivitÃ¤t sollte einfacher sein."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: Psst, mit `RightInverse g f` weisst du, dass `f (g x) = x`.\n"
"Hilft das rauszufinden was du hier brauchen musst?"
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "**Robo**: Du kannst die `RightInverse`-Annahme einfach mit `rw`\n"
"benutzen."
msgstr ""

#: Game.Levels.OLDFunction.L09_Inverse
msgid "Endlich entkommt ihr der Bibliothek.\n"
"\n"
"**Robo**: Da wÃ¼rden mich keine zehn Pferde nochmals hineinbringen!\n"
"\n"
"**Du**: Von wegen Pferden, wie viele PS hat eigentlich unser Raumschiff?"
msgstr ""

#: Game.Levels.OLDFunction
msgid "Abbildungen"
msgstr ""

#: Game.Levels.OLDFunction
msgid "Auf der Suche nach dem Buch der Urbilder landet ihr auf einem kleinen Mond, der bis auf\n"
"eine Insel komplett mit Wasser bedeckt zu sein scheint.\n"
"\n"
"Auf der Insel seht ihr verschiedene groÃŸe und kleine Behausungen, manche aus Stroh und Holz,\n"
"vereinzelte aus Lehm.\n"
"\n"
"Planlos geht ihr zum ersten Haus bei dem jemand vorne auÃŸen sitzt."
msgstr ""

#: Game.Levels.Inequality.L01_LE
msgid "Kleinergleich"
msgstr ""

#: Game.Levels.Inequality.L01_LE
msgid "Du fÃ¼hlst dich ein wenig Ã¼berfahren, aber versuchst trotzdem, ein GesprÃ¤ch zu beginnen.\n"
"\n"
"**Du**: Ist gut, wir bemÃ¼hen uns, nichts durcheinander zu bringen. Ist es sehr schwer,\n"
"hier Ordnung zu halten.\n"
"\n"
"**Lina**: Nun, man muss schon das ein oder andere wissen â€¦ Zum GlÃ¼ck hilft mir Ritha.\n"
"Wenn Du mal probieren willst â€¦ hier ist mir gestern etwas verrutscht."
msgstr ""

#: Game.Levels.Inequality.L01_LE
msgid "**Robo**: Denk lieber nicht zu lange darÃ¼ber nach. Das ist eine KuriositÃ¤t,\n"
"dass `m < n` auf `â„•` per Definition als `m + 1 â‰¤ n` definiert ist!\n"
"\n"
"**Lina**: Du verdirbst den Witz! Ich wollte ihn doch nur testen."
msgstr ""

#: Game.Levels.Inequality.L01_LE
msgid "**Du**: Ha, ha â€¦ Und was muss man noch wissen?"
msgstr ""

#: Game.Levels.Inequality.L02_Pos
msgid "Kleinergleich"
msgstr ""

#: Game.Levels.Inequality.L02_Pos
msgid "**Lina**: Man muss zum Beispiel wissen, dass `n â‰  0` fÃ¼r natÃ¼rliche Zahlen nichts anderes\n"
"bedeutet als `0 < n`.\n"
"\n"
"**Robo**: Und da gibts leider keinen Standard zu â€¦\n"
"\n"
"**Ritha**: Man kann das einfach mit `Nat.pos_iff_ne_zero` umschreiben. Aber wenn man neu hier\n"
"ist, sollte man das vielleicht noch einmal selbst beweisen?"
msgstr ""

#: Game.Levels.Inequality.L02_Pos
msgid "**Robo** (*flÃ¼sternd*): Wenn du ein bisschen schwere Maschinerie auffahren willst,\n"
"um sie zu beeindrucken, hab ich was. Mach doch eine Fallunterscheidung ob `n` Null ist\n"
"oder nicht!\n"
"\n"
"**Du** (*flÃ¼sternd*): Wer will hier wen beeindrucken?\n"
"\n"
"**Robo** (*laut und selbstsicher*): Wir fangen mit `rcases n` an!"
msgstr ""

#: Game.Levels.Inequality.L02_Pos
msgid "**Du**: Hmm, das muss man doch vereinfachen kÃ¶nnen.\n"
"\n"
"**Robo** (*flÃ¼sternd*): Zweiter pompÃ¶ser Auftritt: sag einfach `simp` und lass das alles\n"
"automatisch geschehen."
msgstr ""

#: Game.Levels.Inequality.L02_Pos
msgid "**Du**: Ah und jetzt falls `n â‰  0`."
msgstr ""

#: Game.Levels.Inequality.L02_Pos
msgid "**Robo**: Warte! FÃ¼r den Rest zitieren wir einfach ein anderes Lemma: `Nat.suc_pos`."
msgstr ""

#: Game.Levels.Inequality.L02_Pos
msgid "**Robo**: Warte! FÃ¼r den Rest zitieren wir einfach ein anderes Lemma: `Nat.suc_pos`."
msgstr ""

#: Game.Levels.Inequality.L02_Pos
msgid "**Du**: `simp` ist ja echt nicht schlecht â€¦"
msgstr ""

#: Game.Levels.Inequality.L03_Linarith
msgid "Linarith"
msgstr ""

#: Game.Levels.Inequality.L03_Linarith
msgid "**Ritha**: Und wie wÃ¤r's hiermit?"
msgstr ""

#: Game.Levels.Inequality.L03_Linarith
msgid "**Du**: `simp` geht hier nicht vermutlich nicht â€¦\n"
"\n"
"**Robo**: Nein, ist ja auch keine Vereinfachung, die du machen willst.\n"
"\n"
"**Lina**: Hier brauchst Du unser absolutes Powertool!\n"
"\n"
"**Ritha**: `linarith`"
msgstr ""

#: Game.Levels.Inequality.L03_Linarith
msgid "**Du**: Naja, so beeindruckend war das jetzt auch noch nicht."
msgstr ""

#: Game.Levels.Inequality.L04_Linarith
msgid "Linarith"
msgstr ""

#: Game.Levels.Inequality.L04_Linarith
msgid "**Robo**: Dann versuchs mal hiermit!\n"
"\n"
"$$\n"
"\\begin{aligned}\n"
"  5 * y &\\le 35 - 2 * x \\\\\n"
"  2 * y &\\le x + 3\n"
"\\end{aligned}\n"
"$$"
msgstr ""

#: Game.Levels.Inequality.L04_Linarith
msgid "**Du**: Boah, nicht schlecht."
msgstr ""

#: Game.Levels.Inequality
msgid "Luna"
msgstr ""

#: Game.Levels.Inequality
msgid "Robo hat einen kleinen Mond entdeckt, auf den ihr jetzt zusteuert.\n"
"Er hat eine ganz glatte OberflÃ¤che, aber an einer Stelle hat die OberflÃ¤che eine kleine\n"
"Ã–ffnung, von der eine Treppe ins Innnere fÃ¼hrt. Ihr landet und steigt neugierig hinab.\n"
"\n"
"Unten angekommen findest du dich in der aufgerÃ¤umtesten Wohnung wieder, die du je gesehen hast.\n"
"Ein kleines MÃ¤dchen begrÃ¼ÃŸt Euch.\n"
"\n"
"**Lina**: Ich bin Lina, die einzige Bewohnerin von Luna.\n"
"\n"
"Dann sieht sie Robo.\n"
"\n"
"**Lina**: Naja, eigentlich sind wir hier auch zu zweit â€¦\n"
"\n"
"Sie dreht sich um und ruft etwas, da kommt ein Smart-Elf angefahren.\n"
"\n"
"**Lina**: Das ist Ritha!\n"
"\n"
"Robo findet sie offensichtlich sÃ¼ÃŸ.\n"
"\n"
"**Lina**: Aber jetzt steht mal hier nicht so unordentlich herum, bitte! Schuhe und Helme dort\n"
"und dort verstauen, und dann stellt Euch auf die markierten Besucher-Standpunkte. Sonst komme\n"
"ich hier noch ganz durcheinander."
msgstr ""

#: Game.Levels.Proposition.L00_Tauto
msgid "Automatisierung"
msgstr ""

#: Game.Levels.Proposition.L00_Tauto
msgid "Gerade seid Ihr auf KÃ¶nigin *Logisindes* Planeten. Sie kommt ohne Umschweife zum Punkt:\n"
"\n"
"**Logisinde**: Werte Wesen aus fremden Welten, gestatten Sie eine Frage. Warum gilt â€¦\n"
"\n"
"Und sie kritzelt etwas auf ein StÃ¼ck Papier: oben ein paar Annahmen, unten eine Schlussfolgerung.\n"
"Dazwischen sollst du offenbar einen Beweis eintragen.\n"
"Du siehst Robo hilflos an."
msgstr ""

#: Game.Levels.Proposition.L00_Tauto
msgid ""
msgstr ""

#: Game.Levels.Proposition.L00_Tauto
msgid "**Robo**: Das ist ganz einfach. Mit `Â«{A}Â» Â«{B}Â» Â«{C}Â» : Prop` meint sie:\n"
"`Â«{A}Â»`, `Â«{B}Â»` und `Â«{C}Â»` sind irgendwelche Aussagen (*propositions*).\n"
"Und mit `â†’` meint sie â‡’, also â€œimpliziertâ€. Die anderen Symbole kennst du, oder?\n"
"\n"
"**Du**: Ehhm, ja. Aber da muss ich jetzt trotzdem erst einmal Ã¼berlegen.\n"
"\n"
"**Robo**: (flÃ¼sternd) Behaupte doch einfach, dass sei eine Tautologie.\n"
"\n"
"**Du**: Ernsthaft?\n"
"\n"
"**Robo**: Ja. Schreib einfach `tauto`.\n"
"\n"
"**Robo**: Mach schon â€¦"
msgstr ""

#: Game.Levels.Proposition.L00_Tauto
msgid "**Logisinde**: (etwas konsterniert) Ja, das ist streng genommen richtig.\n"
"Aber glaubt bloÃŸ nicht, dass Ihr damit auf *diesem* Planeten viel weiterkommt!\n"
"Meine Untertanen verstehen `tauto` nicht. Da mÃ¼sst Ihr Euch schon etwas mehr anstrengen."
msgstr ""

#: Game.Levels.Proposition.L01_Rfl
msgid "Aller Anfang ist... ein Einzeiler?"
msgstr ""

#: Game.Levels.Proposition.L01_Rfl
msgid "In der Zwischenzeit hat bereits sich eine lange Schlange Untertanen gebildet, die gern ihren\n"
"Fragen stellen wÃ¼rden. Logisinde winkt den ersten nach vorn. Er rÃ¤uspert sich.\n"
"\n"
"**Untertan**: Warum ist $42 = 42$?\n"
"\n"
"Du schaust ihn fassungslos an.\n"
"Er schreibt es dir wieder auf."
msgstr ""

#: Game.Levels.Proposition.L01_Rfl
msgid "**Robo**: Ist doch klar. Du musst ihn einfach daran erinnern,\n"
"dass Gleichheit *reflexiv* ist. Probier mal `rfl`."
msgstr ""

#: Game.Levels.Proposition.L01_Rfl
msgid "**Untertan**: Ah, richtig. Ja, Sie haben ja so recht. Das vergesse ich immer. Rfl, rfl, rfl â€¦"
msgstr ""

#: Game.Levels.Proposition.L02_Assumption
msgid "Annahmen"
msgstr ""

#: Game.Levels.Proposition.L02_Assumption
msgid "WÃ¤hrend der erste Untertan noch rfl, rfl, rfl murmelt, tritt schon der nÃ¤chste nach vorne. Es ist schÃ¼chtern und schreibt bloÃŸ."
msgstr ""

#: Game.Levels.Proposition.L02_Assumption
msgid "**Robo**: `Â«{n}Â» : â„•` bedeutet, `Â«{n}Â»` ist eine natÃ¼rliche Zahl.\n"
"\n"
"**Du**: Warum schreibt er dann nicht `Â«{n}Â» âˆˆ â„•`??\n"
"\n"
"**Robo**: Weil das hier alles komische Typen sind â€¦ Ich kann dir das spÃ¤ter mal in Ruhe erklÃ¤ren.\n"
"Jetzt will ich erst einmal die Frage entschlÃ¼sseln.\n"
"\n"
"**Robo**: Also, `Â«{hâ‚}Â»`, `Â«{hâ‚‚}Â»`, `Â«{hâ‚ƒ}Â»` sind einfach nur Namen fÃ¼r verschiedene Annahmen, und zwar\n"
"fÃ¼r die Annahme `n < 10`, `1 < n` und `n â‰  5`. Beweisen sollen wir: `1 < n`.\n"
"\n"
"**Du**: Aber das war doch gerade eine der Annahmen.\n"
"\n"
"**Robo**: Ja, stimmt.\n"
"\n"
"**Du**: ???\n"
"\n"
"**Robo**: Du musst ihm das halt explizit sagen. Probiers mal mit `assumption`."
msgstr ""

#: Game.Levels.Proposition.L02_Assumption
msgid "**Untertan**: Ja richtig! Wenn Ihr nur wÃ¼sstet, was ich mir an dieser Frage schon den Kopf\n"
"zerbrochen habe!"
msgstr ""

#: Game.Levels.Proposition.L03_Assumption
msgid "Logische Aussagen"
msgstr ""

#: Game.Levels.Proposition.L03_Assumption
msgid "Ein dritter Untertan kommt mit folgendem Problem."
msgstr ""

#: Game.Levels.Proposition.L03_Assumption
msgid "**Robo**: Hier bedeutet `Â«{A}Â» : Prop` wieder, dass `Â«{A}Â»` irgendeine Aussage ist.\n"
"Und `Â«{hA}Â»` ist eine Name fÃ¼r die Annahme, dass `Â«{A}Â»` wahr ist.\n"
"\n"
"**Du**: Und unter dieser Annahme sollen wir jetzt `Â«{A}Â»` beweisen?\n"
"\n"
"**Robo**: Ja. Da kommst du jetzt selbst drauf, wie das geht, oder?"
msgstr ""

#: Game.Levels.Proposition.L03_Assumption
msgid "**Robo**: Ist doch genau wie eben:\n"
"die Aussage, die zu beweisen ist, gehÃ¶rt selbst zu den Annahmen.\n"
"Also wird `assumption` auch wieder funktionieren."
msgstr ""

#: Game.Levels.Proposition.L03_Assumption
msgid "**Untertan**: Das ging ja schnell. Super! Vielen Dank."
msgstr ""

#: Game.Levels.Proposition.L04_True
msgid "True/False"
msgstr ""

#: Game.Levels.Proposition.L04_True
msgid "Der nÃ¤chste Untertan in der Reihe ist ein Schelm."
msgstr ""

#: Game.Levels.Proposition.L04_True
msgid "**Robo**: Dieses `True` ist eine spezielle Aussage, nÃ¤mlich die Aussage, die immer und\n"
"bedingungslos wahr ist.\n"
"\n"
"**Du**: Und was genau ist dann zu beweisen?\n"
"\n"
"**Robo**: Ich glaube, nichts. Ich glaube, du kannst einfach `trivial` schreiben."
msgstr ""

#: Game.Levels.Proposition.L04_True
msgid "**Schelm**: Wollte nur mal sehen, dass Ihr nicht auf den Kopf gefallen seid â€¦\n"
"\n"
"**Du** *(zu Robo)*: KÃ¶nnen wir nicht einfach immer dieses `trivial` verwenden?\n"
"Wie in einer Mathe-Vorlesung?\n"
"\n"
"**Robo**: Nein, das `trivial` hier hat eine ziemlich spezielle Bedeutung.\n"
"Das funktioniert nur in einer Handvoll Situationen."
msgstr ""

#: Game.Levels.Proposition.L05_Not
msgid "Not"
msgstr ""

#: Game.Levels.Proposition.L05_Not
msgid "Der Schelm hat noch eine Schwester dabei."
msgstr ""

#: Game.Levels.Proposition.L05_Not
msgid "**Robo**: Dieses Zeichen `Â¬` bedeutet Negation. Also wenn eine Aussage `(A : Prop)`\n"
"wahr ist, dann ist `Â¬A` falsch, und umgekehrt.\n"
"\n"
"**Du**: Und `False` ist wahrscheinlich die Aussage, die immer falsch ist?\n"
"\n"
"**Robo**: Ja, richtig.\n"
"\n"
"**Du**: Ist das jetzt nicht doch wieder trivial?\n"
"\n"
"**Robo**: Probier mal!"
msgstr ""

#: Game.Levels.Proposition.L05_Not
msgid "Die Schwester lacht und eilt ihrem Bruder hinterher."
msgstr ""

#: Game.Levels.Proposition.L06_False
msgid "Aus Falschem folgt vieles."
msgstr ""

#: Game.Levels.Proposition.L06_False
msgid "Als nÃ¤chstes kommen drei Querulanten. Der erste hat folgendes Problem:"
msgstr ""

#: Game.Levels.Proposition.L06_False
msgid "**Du** Wenn ich das jetzt richtig lese, ist `Â«{A}Â»` eine Aussage,\n"
"und wir haben auÃŸerdem eine Annahme names `Â«{h}Â»`, die besagt â€¦\n"
"\n"
"**Robo**: â€¦ die besagt, dass `False` gilt.\n"
"\n"
"**Du**: Ich dachte, `False` gilt nie?\n"
"\n"
"**Robo**: Ja, genau. Die Annahme ist `False`, also falsch.\n"
"Und aus einer falschen Annahme kann man bekanntlich alles beweisen!\n"
"Insbesondere die gesuchte Aussage `Â«{A}Â»`.\n"
"\n"
"**Du**: Und wie erklÃ¤re ich das jetzt diesem Formalosophen?\n"
"\n"
"**Robo**: Ich glaube, du musst ihn darauf hinweisen, dass zwischen der allgemeingÃ¼ltigen\n"
"Annahme `True` und seiner Annahme `False` ein Widerspruch besteht. Probier mal `contradiction`."
msgstr ""

#: Game.Levels.Proposition.L06_False
msgid "Der erste Querulant ist offenbar zufrieden.\n"
"\n"
"**Du**: War das jetzt ein Widerspruchsbeweis?\n"
"\n"
"**Robo**: Nein, nein, ein Widerspruchsbeweis sieht anders aus. Das Argument hier war:\n"
" wir haben eine `contradiction` in unserem Annahmen, also folgt jede beliebige Aussage."
msgstr ""

#: Game.Levels.Proposition.L07_ContraNotEq
msgid "Aus Falschem folgt vieles."
msgstr ""

#: Game.Levels.Proposition.L07_ContraNotEq
msgid "Auftritt zweiter Querulant."
msgstr ""

#: Game.Levels.Proposition.L07_ContraNotEq
msgid ""
msgstr ""

#: Game.Levels.Proposition.L07_ContraNotEq
msgid "**Du** Ist `Â«{n}Â» â‰  Â«{n}Â»` nicht auch ein Widerspruch?\n"
"\n"
"**Robo**: Probiers mal!"
msgstr ""

#: Game.Levels.Proposition.L07_ContraNotEq
msgid "**Du**: Ja, scheint funktioniert zu haben.\n"
"\n"
"**Du**: Aber irgendwie kommt mir das immer noch ein wenig suspekt vor.\n"
"Jetzt habe ich bewiesen, dass eine beliebige natÃ¼rliche Zahl gleich 37 ist?\n"
"\n"
"**Robo**: Nein, nicht doch. Nur eine beliebige Zahl, die ungleich sich selbst ist, ist gleich 37.\n"
"Und gleich 38, und gleich 39, â€¦\n"
"\n"
"**Du**: Okay, okay, verstehe."
msgstr ""

#: Game.Levels.Proposition.L08_Contra
msgid "Aus Falschem folgt vieles."
msgstr ""

#: Game.Levels.Proposition.L08_Contra
msgid "Auftritt dritter Querulant."
msgstr ""

#: Game.Levels.Proposition.L08_Contra
msgid ""
msgstr ""

#: Game.Levels.Proposition.L08_Contra
msgid "**Du** Wieder ein Widerspruch in den Annahmen?\n"
"\n"
"**Robo**: Ich sehe, du hast langsam den Dreh raus."
msgstr ""

#: Game.Levels.Proposition.L08_Contra
msgid "**Robo**: Gut gemacht. Bei dieser Frage ist auch ein bisschen offensichtlicher,\n"
"worin der Widerspruch besteht: Die Annahme `n â‰  10` ist genau die Negation von `n = 10`.\n"
"Man muss `â‰ ` immer als `Â¬(Â· = Â·)` lesen."
msgstr ""

#: Game.Levels.Proposition.L09_And
msgid "Und"
msgstr ""

#: Game.Levels.Proposition.L09_And
msgid "Der nÃ¤chste Formalosoph in der Reihe hat seine Frage bereits mitgebracht.\n"
"Er legt sie uns vor, setzt sich hin und hÃ¤kelt."
msgstr ""

#: Game.Levels.Proposition.L09_And
msgid ""
msgstr ""

#: Game.Levels.Proposition.L09_And
msgid "**Du**: Also, wir haben zwei Annahmen: `Â«{A}Â»` gilt, und `Â«{B}Â»` gilt auch. Und beweisen sollen wir\n"
"dass `Â«{A}Â» und Â«{B}Â»` gilt. Ich glaube, diese Formalospinner treiben mich noch zur Verzweiflung.\n"
"Kann ich nicht wieder `trivial` sagen?\n"
"\n"
"**Robo**: Nee, diesmal wird das nicht funktionieren.\n"
"Du musst das Beweisziel einfach in zwei Teile zerlegen. Probier mal `constructor`.\n"
"\n"
"**Du**: Du meinst, `destructor`??\n"
"\n"
"**Robo**: Nein, `constructor`. Ich weiÃŸ, das ist verwirrend,\n"
"aber die nennen das hier so weil man die Aussage aus mehreren Teilen\n"
"konstruieren kann."
msgstr ""

#: Game.Levels.Proposition.L09_And
msgid "**Robo**: Schau mal, das ist Zauberpapier.\n"
"Jetzt haben wir auf einmal zwei Beweisziele.\n"
"Hier ist dast Ziel `Â«{B}Â»`.\n"
"Ich glaube, du weiÃŸt schon, wie man die jeweils erreicht.\n"
"Die Ziele stehen ja jeweils in den *Annahmen*."
msgstr ""

#: Game.Levels.Proposition.L09_And
msgid "**Robo**: Super!\n"
"\n"
"Ihm scheinen diese Fragen inzwischen SpaÃŸ zu machen.\n"
"\n"
"**Robo**: Meinst du, dieser Hebel, an dem \"Editor mode\" steht, ist echt?\n"
"Oder ist der nur gemalt? Probier mal!"
msgstr ""

#: Game.Levels.Proposition.L10_And
msgid "Und"
msgstr ""

#: Game.Levels.Proposition.L10_And
msgid "Langsam wird die Schlange kÃ¼rzer. Die nÃ¤chste Formalosophin, ebenfalls hÃ¤kelnd, hat folgendes Anliegen."
msgstr ""

#: Game.Levels.Proposition.L10_And
msgid "**Du**: Jetzt mÃ¼ssen wir wohl die Annahme de-konstruieren.\n"
"\n"
"**Robo**: Ja, genau. Das geht am einfachsten mit `rcases Â«{h}Â» with âŸ¨hâ‚, hâ‚‚âŸ©`.\n"
"\n"
"**Du**: Moment, wie schreib ich *das* denn hier auf?\n"
"\n"
"**Robo**: Die bleiden Klammern schreibst du als `\\<` und `\\>`, oder gleichzeitig als `\\<>`.\n"
"Und hâ‚ schreibst du einfach als `h\\1`. Aber du kannst dir auch einfach andere Namen\n"
"fÃ¼r `hâ‚` und `hâ‚‚`, zum Beispiel `rcases Â«{h}Â» with âŸ¨hA, hBCâŸ©`"
msgstr ""

#: Game.Levels.Proposition.L10_And
msgid "**Robo**: Das sieht doch schon besser aus! Gleich nochmal!"
msgstr ""

#: Game.Levels.Proposition.L10_And
msgid "**Robo**: Du hast einen Beweis dafÃ¼r in den *Annahmen*."
msgstr ""

#: Game.Levels.Proposition.L10_And
msgid "**Robo**: Du hÃ¤ttest das Ã¼brigens auch direkt verschachtelt schreiben kÃ¶nnen:\n"
"`rcases h with âŸ¨hâ‚, âŸ¨hâ‚‚ , hâ‚ƒâŸ©âŸ©`."
msgstr ""

#: Game.Levels.Proposition.L11_Or
msgid "Oder"
msgstr ""

#: Game.Levels.Proposition.L11_Or
msgid "Der nÃ¤chste bitte â€¦"
msgstr ""

#: Game.Levels.Proposition.L11_Or
msgid "**Du** Muss ich jetzt wieder das Beweisziel de-konstruieren?\n"
"\n"
"**Robo** Nein, viel einfacher. Wenn du eine Oder-Aussage beweisen sollst, musst du dich\n"
"einfach entscheiden, ob du die linke oder rechte Seite beweisen willst.\n"
"\n"
"**Du** Und wie erklÃ¤re ich meinem Formalosophen, welche Seite ich gern beweisen wÃ¼rde?\n"
"Ich will natÃ¼rlich `Â«{A}Â»` beweisen!\n"
"\n"
"**Robo** Mit `left` bzw. `right`. Ist doch logisch, oder?"
msgstr ""

#: Game.Levels.Proposition.L11_Or
msgid "**Robo** Wusste gar nicht, dass du eine Links-Rechts-SchwÃ¤che hast. Probier's nochmal."
msgstr ""

#: Game.Levels.Proposition.L11_Or
msgid "Auch dieser Formalosoph zieht zufrieden von dannen."
msgstr ""

#: Game.Levels.Proposition.L12_Or
msgid "Oder"
msgstr ""

#: Game.Levels.Proposition.L12_Or
msgid "Der nÃ¤chste bitte â€¦"
msgstr ""

#: Game.Levels.Proposition.L12_Or
msgid ""
msgstr ""

#: Game.Levels.Proposition.L12_Or
msgid "**Robo** Schau mal, wenn du mit dem Finger eine Annahme berÃ¼hrst, zeigt es dir,\n"
"wie die Klammern gesetzt sind. Irreâ€¦\n"
"\n"
"**Du** Ah ich sehe, also `(Â«{A}Â» âˆ§ Â«{B}Â») âˆ¨ Â«{A}Â»`!\n"
"\n"
"**Du** Ich glaube den ganzen Zircus hier langsam nicht mehr:\n"
"Zuerst ein \"Und\" im Ziel, dann \"Und\" in der Annahme, dann \"Oder\" im Ziel und jetzt\n"
"\"Oder\" in der Annahme, die haben sich doch abgesprochen!\n"
"\n"
"**Robo** Lass ihnen doch ihren SpaÃŸ.\n"
"Wir sind ja gleich hier fertig, und kÃ¶nnen zu einem interessanteren Planeten weiterfliegen.\n"
"\n"
"**Du** Also, wieder `rcases â€¦`?\n"
"\n"
"**Robo** Ja, aber diesmal nicht `rcases Â«{h}Â» with âŸ¨hâ‚, hâ‚‚âŸ©`, sondern `rcases Â«{h}Â» with h | h`."
msgstr ""

#: Game.Levels.Proposition.L12_Or
msgid "**Robo**\n"
"Jetzt musst du dein Ziel zweimal beweisen:\n"
"Einmal unter Annahme der linken Seite `Â«{A}Â» âˆ§ Â«{B}Â»`,\n"
"und einmal unter Annahme der rechten Seite `Â«{A}Â»`.\n"
"Hier haben nehmen wir an, die linke Seite\n"
"sei wahr."
msgstr ""

#: Game.Levels.Proposition.L12_Or
msgid "**Robo** Wie man mit einem Und in den Annahmen umgeht,\n"
"weiÃŸt du doch schon:\n"
"`rcases h with âŸ¨hâ‚, hâ‚‚âŸ©`. Zur Erinnerung: FÃ¼r die Klammern schreibst du `\\<>`."
msgstr ""

#: Game.Levels.Proposition.L12_Or
msgid "**Robo** Jetzt musst du dein Ziel noch unter der rechten Annahme\n"
"von `(Â«{A}Â» âˆ§ Â«{B}Â») âˆ¨ Â«{A}Â»` zeigen, also angenommen, `Â«{A}Â»` sei wahr."
msgstr ""

#: Game.Levels.Proposition.L12_Or
msgid "**Du** Okay, das scheint ihn zufriedenzustellen. Nur noch eine Seeleâ€¦\n"
"Kannst du mir vorher noch einmal kurz alles Leansch zusammenfassen,\n"
"das du mir bis hierher beigebracht hast?\n"
"\n"
"Robo strahlt Ã¼berglÃ¼cklich. Noch *nie* warst du so auf ihn angewiesen.\n"
"\n"
"**Robo** Na klar, schau her!\n"
"\n"
"## Notationen / Begriffe\n"
"\n"
"|               | Beschreibung                                                             |\n"
"|:--------------|:-------------------------------------------------------------------------|\n"
"| *Goal*        | Was aktuell zu beweisen ist.                                             |\n"
"| *Annahme*     | Objekte & Resultate, die man zur VerfÃ¼gung hat.                          |\n"
"| *Taktik*      | Befehl im Beweis. Entspricht einem Beweisschritt.                        |\n"
"| `â„•`           | Typ aller natÃ¼rlichen Zahlen.                                            |\n"
"| `0, 1, 2, â€¦`  | Explizite natÃ¼rliche Zahlen.                                             |\n"
"| `=`           | Gleichheit.                                                              |\n"
"| `â‰ `           | Ungleichheit. AbkÃ¼rzung fÃ¼r `Â¬(Â·=Â·)`.                                    |\n"
"| `Prop`        | Typ aller logischen Aussagen.                                            |\n"
"| `True`        | Die logische Aussage `(True : Prop)` ist bedingungslos wahr.             |\n"
"| `False`       | Die logische Aussage `(False : Prop)` ist bedingungslos falsch.          |\n"
"| `Â¬`           | Logische Negierung.                                                      |\n"
"| `âˆ§`           | Logisch UND.                                                             |\n"
"| `âˆ¨`           | Logisch ODER.                                                            |\n"
"| `(n : â„•)`     | Eine natÃ¼rliche Zahl.                                                    |\n"
"| `(A : Prop)`  | Eine logische Aussage.                                                   |\n"
"| `(ha : A)`    | Ein Beweis, dass die logische Aussage `(A : Prop)` wahr ist.             |\n"
"| `(h : A âˆ§ B)` | Eine Annahme, die den Namen `h` bekommen hat.                            |\n"
"| `âŸ¨Â·,Â·âŸ©`       | Schreibweise fÃ¼r Struktur mit mehreren Feldern (kommt spÃ¤ter im Detail). |\n"
"| `h.1, h.2, â€¦` | Die einzelnen Felder der Stuktur. Auch `h.[Name des Feldes]`             |\n"
"\n"
"\n"
"## Taktiken\n"
"\n"
"Die Worte, die du aktiv gebrauchen musst, heiÃŸen zusammengefasst `Taktiken`. Hier sind alle Taktiken, die wir auf diesem Planeten gebraucht haben:\n"
"\n"
"|    | Taktik                    | Beispiel                                          |\n"
"|:---|:--------------------------|:--------------------------------------------------|\n"
"| 1  | `rfl`                     | Beweist `A = A`.                                  |\n"
"| 2  | `assumption`              | Sucht das Goal in den Annahmen.                   |\n"
"| 3  | `contradiction`           | Sucht einen Widerspruch.                          |\n"
"| 4  | `trivial`                 | Kombiniert die obigen drei Taktiken (und mehr).   |\n"
"| 5  | `constructor`             | Teilt ein UND im Goal auf.                        |\n"
"| 6  | `left`/`right`            | Beweist eine Seite eines ODER im Goal.            |\n"
"| 7áµƒ | `rcases h with âŸ¨hâ‚, hâ‚‚âŸ©`  | Teilt ein UND in den Annahmen auf.                |\n"
"| 7áµ‡ | `rcases h with h \\| h`   | Teilt ein ODER in den Annahmen in zwei FÃ¤lle auf. |\n"
"\n"
"**Du** Woher weiÃŸt du das eigentlich alles?\n"
"\n"
"**Robo** Keine Ahnung. War, glaube ich, vorinstalliert."
msgstr ""

#: Game.Levels.Proposition.L13_Summary
msgid "Zusammenfassung"
msgstr ""

#: Game.Levels.Proposition.L13_Summary
msgid "Der letzte Untertan tritt vor. Ihr Anliegen ist etwas komplizierter als die vorherigen.\n"
"\n"
"**Robo** Wirf einfach alles drauf, was du gelernt hast.\n"
"Hier, ich bin sogar so nett und zeig dir noch einmal die vier\n"
"wichtigsten Taktiken fÃ¼r diese Situation an.\n"
"\n"
"| (Ãœbersicht) | Und (`âˆ§`)                | Oder (`âˆ¨`)              |\n"
"|-------------|:-------------------------|:------------------------|\n"
"| Annahme     | `rcases h with âŸ¨hâ‚, hâ‚‚âŸ©` | `rcases h with h \\| h` |\n"
"| Goal        | `constructor`            | `left`/`right`          |"
msgstr ""

#: Game.Levels.Proposition.L13_Summary
msgid "**Robo**: Ich wÃ¼rd zuerst die Annahme Â«{h}Â» mit `rcases Â«{h}Â»` aufteilen."
msgstr ""

#: Game.Levels.Proposition.L13_Summary
msgid "**Robo**: Jetzt kannst du das `âˆ§` im Goal mit `constructor` angehen."
msgstr ""

#: Game.Levels.Proposition.L13_Summary
msgid "**Robo**: Hier wÃ¼rde ich die Annahme Â«{h}Â» nochmals mit `rcases` aufteilen."
msgstr ""

#: Game.Levels.Proposition.L13_Summary
msgid "**Robo**: Der Nachteil an der Reihenfolge ist, dass du jetzt in jedem Untergoal\n"
"`rcases h` aufrufen musst."
msgstr ""

#: Game.Levels.Proposition.L13_Summary
msgid "**Robo** Bravo! Jetzt aber nichts wie weg hier, bevor sich eine neue Schlange bildet!\n"
"\n"
"KÃ¶nigin *Logisinde* ist in der Zwischenzeit eingeschlafen, und ihr stehlt euch heimlich davon."
msgstr ""

#: Game.Levels.Proposition
msgid "Logo"
msgstr ""

#: Game.Levels.Proposition
msgid "Durch eine unvorhergesehene und nicht-kanonische SingularitÃ¤t in der Raumzeit\n"
"bist du aus Versehen in ein Paralleluniversum gestolpert. Wie es aussieht, gibt es kein zurÃ¼ck.\n"
"Richte dich besser darauf ein, hier bleiben und dich zurechtzufinden zu mÃ¼ssen.\n"
"\n"
"Wie es aussieht, gibt es hier viele nette kleine Planeten. Alle bewohnbar, und bis zu\n"
"sieben SonnenuntergÃ¤nge tÃ¤glich inklusive. Nur werden sie allesamt von Formalosophen bewohnt,\n"
"seltsamen Wesen mit ausgefallenen mathematischen Obsessionen. Und dummerweise hat sich\n"
"herumgesprochen, dass du in deinem frÃ¼heren Universum Mathematiker warst. du wirst hier\n"
"keine Ruhe finden, solange du nicht lernst, ihren unablÃ¤ssigen Wissensdurst zu stillen.\n"
"\n"
"Es gibt nur zwei Schwierigkeiten: Erstens haben die Formalosophen allem Anschein nach\n"
"Ã¼berhaupt kein tieferes mathematisches VerstÃ¤ndnis, und zweitens kommunizieren Sie Ã¼ber Mathematik\n"
"exklusiv in einem dir fremden Dialekt, den sie Leansch [liËnÊƒ] nennen.\n"
"\n"
"Zum GlÃ¼ck hat Robo mit dir das Universum gewechselt.\n"
"Robo, das ist dein kleiner SmartElf. Robo ist zwar auch nicht die mathematische Leuchte, die du Dir\n"
"in dieser Situation gewÃ¼nscht hÃ¤ttest, aber es scheint, er hat irgendwo Leansch gelernt.\n"
"Und das ist Gold wert."
msgstr ""

#: Game.Levels.Sum.L01_Simp
msgid "Simp"
msgstr ""

#: Game.Levels.Sum.L01_Simp
msgid "**Babylonier**: Jeder Turm hat eine Inschrift. Da kÃ¶nnt ihr noch einmal genau nachlesen,\n"
"warum er steht. Hier zum Beispiel."
msgstr ""

#: Game.Levels.Sum.L01_Simp
msgid "**Du**: Oh das ist ganz schÃ¶n viel neues â€¦ mal sehen â€¦\n"
"\n"
"Das sieht aus wie $( \\sum_i 0 + 0 ) = 0$.\n"
"\n"
"**Robo**: Genau! Man schreibt `\\sum`. Und `i : Fin n` bedeutet,\n"
"dass summiert wird Ã¼ber $0$, $1$, â€¦, $n-1$.\n"
"\n"
"**Du**: Okay. Und was mach ich jetzt?\n"
"\n"
"**Robo**: `simp` ist eine starke Taktik, die viele Terme vereinfacht.\n"
"Wir fangen besser an, sie zu benutzen."
msgstr ""

#: Game.Levels.Sum.L01_Simp
msgid "**Babylonier**: Seht ihr, das passt!\n"
"\n"
"**Robo**: Mir fÃ¤llt gerade ein, du hattest ja mal gefragt bezÃ¼glich `rw` unter Quantoren.\n"
"Mit Summen ist das das gleiche: Hier musst du immer `simp_rw` verwenden, wenn du innerhalb\n"
"einer Summe was umschreiben mÃ¶chtest."
msgstr ""

#: Game.Levels.Sum.L02_Sum
msgid "endliche Summe"
msgstr ""

#: Game.Levels.Sum.L02_Sum
msgid "Ihr schaut euch den nÃ¤chsten Turm an."
msgstr ""

#: Game.Levels.Sum.L02_Sum
msgid "$\\sum_{i=0}^{n-1} (i + 1) = n + \\sum_{i=0}^{n-1} i$."
msgstr ""

#: Game.Levels.Sum.L02_Sum
msgid "**Du**: Hmm, wieder `simp`?\n"
"\n"
"**Robo**: Nicht ganz. `simp` benutzt nur Lemmata, die klar eine Vereinfachung darstellen.\n"
"Im Lean-Duden sind diese Lemmata mit `@[simp]` markiert.\n"
"Hier brauchen wir aber folgende IdentitÃ¤t:\n"
"\n"
"$$\n"
"\\sum_{i = 0}^n a_i + b_i = \\sum_{i = 0}^n a_i + \\sum_{j = 0}^n b_j\n"
"$$\n"
"\n"
"**Robo**: Und da bei dieser IdentitÃ¤t unklar ist, welche Seite â€einfacherâ€œ ist, wird so ein Lemma nicht mit\n"
"`@[simp]` markiert.\n"
"\n"
"**Du**: Hat diese Gleichheit denn wenigstens einen Namen.\n"
"\n"
"**Robo**: Sie heiÃŸt `sum_add_distrib`."
msgstr ""

#: Game.Levels.Sum.L02_Sum
msgid "**Robo**: Die zweite Summe `âˆ‘ x : Fin n, 1` kann jetzt aber mit\n"
"`simp` zu `n` vereinfacht werden."
msgstr ""

#: Game.Levels.Sum.L02_Sum
msgid "**Robo**: Bis auf Umordnung sind jetzt beide Seiten gleich!\n"
"\n"
"**Du**: Dann greift jetzt wohl `ring`!\n"
"\n"
"**Robo**: Genau! Und alternativ kÃ¶nntest du mit `rw [add_comm]` die Arbeit von `ring`\n"
"auch manuell machen."
msgstr ""

#: Game.Levels.Sum.L02_Sum
msgid ""
msgstr ""

#: Game.Levels.Sum.L02_Sum
msgid "Der Babylonier macht ein sehr zufriedenes Gesicht."
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "Arithmetische Summe"
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "**Babylonier**: Kommt, ich zeig Euch mal einen unserer schÃ¶nsten TÃ¼rme!\n"
"\n"
"Nach einem kurzen Spaziergang steht ihr davon.\n"
"\n"
"**Robo**: Das muss der bekannte *GauÃŸsche Turm von Babylon* sein!\n"
"Ãœber den hab ich schon einmal Daten verarbeitet.\n"
"\n"
"**Babylonier**: Richtig. GauÃŸ war ein Babylonier!"
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "$2 \\cdot \\sum_{i = 0}^n i = n \\cdot (n + 1)$."
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "**Du**: Klar, die werden ja nicht oben anfangen mit bauen. Sag mal,\n"
"wie zeige ich denn die arithmetische Summe, die hier gekritzelt steht?\n"
"Ich wÃ¼rde gerne Induktion Ã¼ber $n$ anwenden.\n"
"\n"
"**Robo**: Wenn du meinst â€¦ Auf Leansch wÃ¤re das: `induction n with d hd`!\n"
"Der Zusatz `with d hd` ist natÃ¼rlich optional.\n"
"Du kannst damit Namen fÃ¼r Induktionsvariable (d) und -hypothese (h) vorgeben."
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "**Du**: Zuerst der Induktionsanfang â€¦\n"
"\n"
"**Robo**: Diesen kannst du oft mit `simp` abkÃ¼rzen!"
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "**Robo**: Jetzt der Induktionsschritt.\n"
"Bei Induktion Ã¼ber endlichen Summen beginnst du den Induktionsschritt\n"
"immer mit `rw [sum_univ_castSucc]`."
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "**Du**: Oh das sieht jetz aber kompliziert ausâ€¦\n"
"\n"
"**Robo**: Da musst du etwas drÃ¼ber hinweg lesen. Am besten machst du kurz `simp`,\n"
"dann sieht's schon wieder besser aus."
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "**Du**: Was bedeutet eigentlich der kleine Pfeil `â†‘`?\n"
"\n"
"**Robo**: Das ist eine *Coersion*. Sowas wie wenn man eine natÃ¼rliche Zahl als ganze Zahl betrachtet,\n"
"also die natÃ¼rliche Abbildung `â„• â†ª â„¤` benutzt. Oder hier, wenn ein Element `x : Fin n` als\n"
"Element `(â†‘x : â„•)` betrachtet wird."
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "**Robo**: Um die Induktionshypothese anzuwenden, brauchst du zuerst das Lemma `mul_add`."
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "**Du**: Und wie wende ich jetzt die Induktionshypothese an?\n"
"\n"
"**Robo** mit `rw` wie jede andere Annahme auch."
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "**Du**: Der Rest ist einfach Rechnerei.\n"
"\n"
"**Robo**: Dann wird `ring` wohl keine Probleme haben."
msgstr ""

#: Game.Levels.Sum.L03_ArithSum
msgid "Du schaust dich um und bewunderst das Tal in dem hunderte, wenn nicht tausende,\n"
"SteintÃ¼rme in allen Formen und HÃ¶hen stehen."
msgstr ""

#: Game.Levels.Sum.L04_SumOdd
msgid "Summe aller ungeraden Zahlen"
msgstr ""

#: Game.Levels.Sum.L04_SumOdd
msgid "Aus reiner Neugierde gehst Du zu einem etwas kleineren Nachbarsturm hinÃ¼ber."
msgstr ""

#: Game.Levels.Sum.L04_SumOdd
msgid "$\\sum_{i = 0}^n (2n + 1) = n ^ 2$."
msgstr ""

#: Game.Levels.Sum.L04_SumOdd
msgid "**Robo**: Das funktioniert genau gleich wie zuvor, viel GlÃ¼ck."
msgstr ""

#: Game.Levels.Sum.L04_SumOdd
msgid "Den Induktionschritt bei Summen solltest du wie gesagt\n"
"immer mit `rw [sum_univ_castSucc]` beginnen."
msgstr ""

#: Game.Levels.Sum.L05_SumComm
msgid "Summe vertauschen"
msgstr ""

#: Game.Levels.Sum.L05_SumComm
msgid "**Babylonier**: Schaut mal, da vorn stehen zwei Freunde von mir. Ich muss euch unbedingt vorstellen!\n"
"\n"
"Die beiden Freunde stehen vor zwei TÃ¼rmen mit einer kleinen BrÃ¼cke, die zwischen den ihnen verlÃ¤uft.\n"
"Aber die Tafel am Eingang ist so sehr verwittert, dass sie nicht mehr lesbar ist.\n"
"Auf der oberen HÃ¤lfte steht nur folgendes, *in einer Form, die Du verstehst*:\n"
"\n"
"$$\\sum_{i=0}^n\\sum_{j=0}^m a_{ij} = \\sum_{j=0}^m\\sum_{i=0}^n a_{ij}$$\n"
"\n"
"NatÃ¼rlich fangt ihr an zu rÃ¤tseln, was darunter stand.\n"
"\n"
"**Robo**: Probier mal, das im lokalen Dialekt zu formulieren."
msgstr ""

#: Game.Levels.Sum.L05_SumComm
msgid "**Robo**: Das sieht gut aus, aber du solltest das kurz beweisen, um sicher zu sein.\n"
"\n"
"**Du**: Hast du nicht ein Lemma dafÃ¼r?\n"
"\n"
"**Robo**: Doch, probier mal `sum_comm`."
msgstr ""

#: Game.Levels.Sum.L05_SumComm
msgid "Die drei Babylonier sind begeistert, als ihr ihnen das StÃ¼ck Papier Ã¼berreicht,\n"
"  auf das du die Aussage gekritzelt hast. Gleich zÃ¼ckt einer einen MeiÃŸel und sie beginnen, eine\n"
"  neue Platte zu erstellen.\n"
"\n"
"  Ihr beschlieÃŸt, euch noch ein bisschen allein umzusehen."
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "Zusammenfassung"
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "**Du**: Robo, gib mir doch nochmals eine Ãœbersicht, bitte.\n"
"\n"
"**Robo**: Aber klar:\n"
"\n"
"|                      | Beschreibung                              |\n"
"|:---------------------|:------------------------------------------|\n"
"| `Fin n`              | Ist ein Typ mit Zahlen $0, \\ldots, n-1$. |\n"
"| `âˆ‘ (i : Fin n), a i` | $\\sum_{i=0}^{n-1} a_i$                   |\n"
"| `â†‘i`                 | Eine Coersion, z.B. `Fin n â†’ â„•`.          |\n"
"\n"
"und\n"
"\n"
"|    | Taktik                    | Beispiel                             |\n"
"|:---|:--------------------------|:-------------------------------------|\n"
"| 21 | `simp`                    | Simplifikation.                      |\n"
"| 22 | `induction n`             | Induktion Ã¼ber $n$                   |\n"
"\n"
"Da kommt hinter einem Turm plÃ¶tzlich ein besonders groÃŸer Babylonier hervor, schaut euch\n"
"bedrohlich an und fragt in tiefer Stimme:"
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "**Du**: Gulp. Naja das wird schon klappen. Also man fÃ¤ngt wieder mit Induktion an â€¦"
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "**Du**: Also den Induktionsanfang kann man einfach zeigen â€¦"
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "**Robo**: Und jetzt wieder `rw [sum_univ_castSucc]` und `simp`, um vorwÃ¤rts zu\n"
"kommen!"
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "**Robo**: Siehst du die Induktionshypothese hier drin?"
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "**Du**: Okay, damit habe ich die linke Seite der Gleichung ziemlich gut bearbeitet.\n"
"Aber, ehm, mit der Rechten komme ich nicht weiter â€¦\n"
"\n"
"Der Babylonier schaut dich finster an.\n"
"\n"
"**Du**: Ich will `sum_univ_castSucc` auf der rechten Seite anwenden, aber es gibt mehrere Orte, wo das Lemma passen wÃ¼rde, und ich will es nur an einer bestimmten Stelle anwenden.\n"
"\n"
"**Robo**:\n"
"Mit `rw [sum_univ_castSucc (n := Â«{n}Â» + 1)]` kannst du angeben, wo genau.\n"
"\n"
"**Du**: Was bedeutet das?\n"
"\n"
"**Robo** Das Lemma hat eine Annahme `n` und du sagst ihm explizit, was es fÃ¼r dieses `n`\n"
"einsetzen muss, nÃ¤mlich `Â«{n}Â» + 1`"
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "**Robo**: Das hat jetzt einfach `Fin.sum_univ_castSucc` am ersten Ort angewendet,\n"
"wo das mÃ¶glich war. Das ist nicht so ideal, die linke Seite war schon okay.\n"
"\n"
"**Robo**: Geh doch zurÃ¼ck und bring `rw` dazu am anderen Ort umzuschreiben."
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "**Robo**: `add_pow_two` ist auch noch nÃ¼tzlich!"
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "**Du**: Ich glaube, ich sehe hier eine GauÃŸsche Summe!!\n"
"\n"
"**Robo**: Ich habe dir das vorhin temporÃ¤r als `arithmetic_sum` gespeichert.\n"
"Das kannst du jetzt benutzen."
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "**Du**: Jetzt sollten es eigentlich nur noch arithmetische Operationen sein."
msgstr ""

#: Game.Levels.Sum.L06_Summary
msgid "Der Babylonier denkt ganz lange nach, und ihr bekommt das GefÃ¼hl, dass er gar nie\n"
"aggressiv war, sondern nur eine sehr tiefe Stimme hat.\n"
"\n"
"Mit einem kleinen Erdbeben setzt er sich hin und winkt euch dankend zu."
msgstr ""

#: Game.Levels.Sum
msgid "Babylon"
msgstr ""

#: Game.Levels.Sum
msgid "Ihr erreicht einen Planet, auf dem unzÃ¤hlige Steinplatten zu bizzar hohen TÃ¼rme\n"
"gestapelt sind. Die ganze Landschaft wirkt wie ein grosses Puzzle, in dem jede Platte\n"
"feinsÃ¤uberlich auf den darunterliegenden Platten aufbaut. Einige TÃ¼rme sind so hoch, dass man ihre Spitze gar nicht erkennen kann. Bald trefft ihr auch den ersten Bewohner dieses Planeten an.\n"
"\n"
"**Babylonier**: Willkommen auf *Babylon*!\n"
"\n"
"**Du**: Oh â€¦\n"
"\n"
"Dich beschleicht ein ungutes GefÃ¼hl.\n"
"\n"
"**Du**: Seid ihr euch sicher, dass diese TÃ¼rme stabil sind?\n"
"\n"
"**Babylonier**: 100 Pro!\n"
"\n"
"**Du**: Wie baut ihr denn diese Meisterwerke?\n"
"\n"
"**Babylonier**: Ganz einfach! Ein Stein nach dem anderen."
msgstr ""

#: Game.Levels.SetTheory.L01_Univ
msgid "Mengen"
msgstr ""

#: Game.Levels.SetTheory.L01_Univ
msgid "**Mengea**: Ich wÃ¼rde leider den Inhalt jenes Buches eh nicht verstehen. Aber der beste Weg fÃ¼r\n"
"euch, dieses zu entschlÃ¼sseln ist, euch ausgiebig mit der BevÃ¶lkerung hier zu unterhalten.\n"
"Lebt mit ihnen, redet mit ihnen und ihr werdet die Sprache automatisch lernen.\n"
"\n"
"**Mengea**: Seid aber vorgewarnt, die Leute hier denken ganz viel Ã¼ber Mengen nach,\n"
"womit sie immer *homogene Mengen* meinen. Eine Menge natÃ¼rlicher Zahlen `{1, 4, 6}` ist\n"
"verstÃ¤ndlich, aber sowas wie eine Menge `{(2 : â„•), {3, 1}, \"e\", (1 : â„‚)}` gibt es hier\n"
"einfach nicht. Punkt.\n"
"\n"
"**Robo**: Als Kontext: Wenn `A` ein beliebiger `Type` ist, dann ist `(U : Set A)` eine Menge\n"
"mit Elementen aus `A`\n"
"\n"
"**Mengea**: Damit ich weiÃŸ, dass ihr euch grundsÃ¤tzlich mit den Leuten austauschen kÃ¶nnt,\n"
"erklÃ¤rt mir doch folgendes:"
msgstr ""

#: Game.Levels.SetTheory.L01_Univ
msgid "**Du**: Also `A` ist ein `Type`, `x` ist ein Element in `A`â€¦\n"
"\n"
"**Robo** â€¦ und `univ` ist die Menge aller Elemente in `A`.\n"
"\n"
"**Du** ist das nicht einfach `A` selber?\n"
"\n"
"**Robo** Fast, aber das eine ist ein `Type`, das andere eine Menge, also vom Typ `Set A`.\n"
"\n"
"**Du**: Unlogisch?\n"
"\n"
"**Mengites**: Naja, Typen und Mengen sind halt zwei unterschiedliche Sachen und wenn ihr\n"
"Ã¼ber Mengen sprechen wollt, mÃ¼ssen alles Mengen sein.\n"
"\n"
"**Du**: Na gut. Und wieso `x âˆˆ univ` und nicht `x : univ` wie bei Typen?\n"
"\n"
"**Robo**: Jedes Element `(x : A)` hat entweder die Eigenschaft `x âˆˆ U` (`\\in`) oder `x âˆ‰ U`\n"
"(`\\nin`) fÃ¼r eine Menge `(U : Set A)`.\n"
"\n"
"**Du**: Also das ist ja dann `trivial`. Hoffentlich sehen die das hier auch soâ€¦"
msgstr ""

#: Game.Levels.SetTheory.L01_Univ
msgid "Die Menge `(univ : Set A)` ist die Menge aller Elemente in `A`. Obwohl mathematisch `A` und\n"
"`(univ : Set A)` so erscheinen, als seien sie das gleiche, ist das in Leans Typentheorie nicht so.\n"
"Elemente haben immer Typ `x : A`, aber sie kÃ¶nnen Elemente von verschiedenen \"Teilmengen\" von `A`\n"
"-- `U : Set A` -- sein. Z.B. gilt immer `x âˆˆ univ` und nie `x âˆˆ âˆ…`."
msgstr ""

#: Game.Levels.SetTheory.L01_Univ
msgid "TODO. Siehe `univ`.\n"
"\n"
"`x âˆ‰ A` ist eine Notation fÃ¼r `Â¬ (x âˆˆ A)`.\n"
"\n"
"(`\\in`, `\\nin`)"
msgstr ""

#: Game.Levels.SetTheory.L01_Univ
msgid "**Mengea**: Ja das stimmt schon. Dann wÃ¼nsche ich euch viel Erfolg auf eurer Reise!"
msgstr ""

#: Game.Levels.SetTheory.L02_Empty
msgid "leere Menge"
msgstr ""

#: Game.Levels.SetTheory.L02_Empty
msgid "Ihr zieht also durch die Gegend und redet mit den Leuten. Ein Junge rennt zu euch und fragt:"
msgstr ""

#: Game.Levels.SetTheory.L02_Empty
msgid "**Du**: Kein Element ist in der leeren Menge enthalten? Das ist ja alles\n"
"tautologisches Zeugs...\n"
"\n"
"**Robo**: Dann behaupte das doch."
msgstr ""

#: Game.Levels.SetTheory.L02_Empty
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L02_Empty
msgid "Der Junge rennt weiter.\n"
"\n"
"**Du**: So wird das ganze schon angenehmer.\n"
"\n"
"**Robo**: Die Leere Menge schreibst du mit `\\empty` falls du die nochmals brauchst."
msgstr ""

#: Game.Levels.SetTheory.L03_Subset
msgid "Teilmengen"
msgstr ""

#: Game.Levels.SetTheory.L03_Subset
msgid "Ihr bemerkt, dass mit dem Jungen noch zwei andere\n"
"Kinder zuhÃ¶rten. Eines der beiden MÃ¤dchen hat ebenfalls eine Frage."
msgstr ""

#: Game.Levels.SetTheory.L03_Subset
msgid "**Robo**: `A âŠ† B` ist als `âˆ€ x, x âˆˆ A â†’ x âˆˆ B` definiert.\n"
"\n"
"**Du**: Also kann ich mit `intro` anfangen, wie ich das bei einem `âˆ€` funktioniert?\n"
"\n"
"**Robo**: Das ist korrekt."
msgstr ""

#: Game.Levels.SetTheory.L03_Subset
msgid "**Robo**: Das dÃ¼rfte eine TrivialitÃ¤t sein."
msgstr ""

#: Game.Levels.SetTheory.L03_Subset
msgid "`A âŠ† B` ist definiert als `âˆ€ x, x âˆˆ A â†’ x âˆˆ B`.\n"
"\n"
"(`\\sub`)"
msgstr ""

#: Game.Levels.SetTheory.L03_Subset
msgid "Damit drehen sich die beiden MÃ¤dchen um und folgen dem Jungen."
msgstr ""

#: Game.Levels.SetTheory.L04_SubsetEmpty
msgid "Teilmengen"
msgstr ""

#: Game.Levels.SetTheory.L04_SubsetEmpty
msgid "Etwas weiter kommt ihr an einem kleinen GemÃ¼sestand vorbei. Da ihr nicht so\n"
"richtig einen Plan habt, fragt ihr den VerkÃ¤ufer.\n"
"\n"
"**VerkÃ¤ufer**: Hier ist was ganz Wichtiges, was ihr noch oft brauchen werdet:\n"
"Ein zentrales Lemma ist `Subset.antisymm_iff` welches folgendes sagt:\n"
"\n"
"```\n"
"lemma antisymm_iff {Î± : Type} {A B : Set Î±} :\n"
"  A = B â†” A âŠ† B âˆ§ B âŠ† A\n"
"```\n"
"\n"
"**VerkÃ¤ufer**: Fast immer wenn man Gleichheiten von Mengen zeigen muss, will\n"
"man diese in zwei Ungleichungen aufteilen. Hier, ich gebe euch mal ein\n"
"Beispiel:"
msgstr ""

#: Game.Levels.SetTheory.L04_SubsetEmpty
msgid "**Du**: Ja, die einzige Teilmenge der leeren Menge ist die leere Menge.\n"
"Das wird schon stimmen.\n"
"\n"
"**VerkÃ¤ufer**: Also zeig mir das mal!"
msgstr ""

#: Game.Levels.SetTheory.L04_SubsetEmpty
msgid "**Robo**: Fang doch einmal mit `constructor` an."
msgstr ""

#: Game.Levels.SetTheory.L04_SubsetEmpty
msgid "**VerkÃ¤ufer**: Jetzt kÃ¶nnt ihr mein Lieblingslemma brauchen!\n"
"\n"
"Dann sind `s âŠ† âˆ…` und `âˆ… âŠ† s` separat zu zeigen."
msgstr ""

#: Game.Levels.SetTheory.L04_SubsetEmpty
msgid "**Robo**: Was kann man denn mit `Â«{h}Â»` jetzt machen?\n"
"\n"
"**Du**: Wenn ich damit umschreibe erhalte ich `âˆ… âŠ† âˆ…`.\n"
"\n"
"**Robo**: Was `rw` als ReflexivitÃ¤t direkt lÃ¶st!"
msgstr ""

#: Game.Levels.SetTheory.L04_SubsetEmpty
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L04_SubsetEmpty
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L05_Empty
msgid "Empty"
msgstr ""

#: Game.Levels.SetTheory.L05_Empty
msgid "**Robo**: Ist das denn wirklich so wichtig?\n"
"\n"
"**VerkÃ¤ufer**: Hier, beantworte mir doch mal folgendes."
msgstr ""

#: Game.Levels.SetTheory.L05_Empty
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L05_Empty
msgid "jetzt kÃ¶nntest du Â«{h8}Â» mit `rcases` aufteilen"
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "Nonempty"
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "**Du**: Kann ich noch mehr Ã¼ben?\n"
"\n"
"**VerkÃ¤ufer**: Das Gegenteil von `A = âˆ…` ist `A â‰  âˆ…`, aber in Lean wird der Ausdruck `A.Nonempty` bevorzugt.\n"
"Dieser ist dadurch existiert, dass in `A` ein Element existiert: `âˆƒx, x âˆˆ A`.\n"
"\n"
"Zeige dass die beiden AusdrÃ¼cke Ã¤quivalent sind:"
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "**Robo**: Am besten fÃ¤ngst du mit `unfold Set.Nonempty` an."
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "`push_neg` kann hier helfen."
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "**Du**: Eben hatten wir doch etwas zu `Â«{s}Â» = âˆ…`.\n"
"\n"
"**Robo**: Das war `eq_empty_iff_forall_not_mem`. Du kannst ja einen\n"
"Widerspruchsbeweis anfangen, dann kannst du dieses Lemma an der Annahme `Â«{s}Â» = âˆ…`\n"
"benutzen!"
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "**Robo** Widerspruch war `by_contra hf`."
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "**Du**: Also ich weiss, dass es ein `x` gibt in `Â«{s}Â»` und dass gleichzeitig alle\n"
"`x` nicht in `Â«{s}Â»` sind, das ist doch ein Widerspruch!\n"
"\n"
"**Robo**: Ja aber nur `contradiction` wird noch nicht reichen, da diese noch nicht\n"
"syntaktisch negationen voneinander sind.\n"
"\n"
"**Du**: Na dann sollte das zumindest eine Tautologie sein."
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "**Du**: Vermutlich sollten wir hier aber dafÃ¼r\n"
"einen Beweis per Widerspruch anfangen?"
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "**Robo**: FÃ¼r dieses Problem ist es vermutlich besser nur\n"
"`push_neg at Â«{hf}Â»` zu verwenden, damit `Â«{h}Â»: Â«{s}Â» â‰  âˆ…` unverÃ¤ndert bleibt!\n"
"\n"
"**Du**: Wieso macht `push_neg` denn das?\n"
"\n"
"**Robo**: Weiss ich auch nichtâ€¦"
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "**Du**: Ist das nicht nochmals eine Seite des Lemmas von\n"
"vorhin?\n"
"\n"
"**Robo**: Ja, `eq_empty_iff_forall_not_mem` ist nochmals nÃ¼tzlich"
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "**Robo**: Mein System sagt, dass Kontraposition nÃ¼tzlich sein kÃ¶nnte.\n"
"\n"
"**Du**: Ja, dann sieht es schon wieder Ã¤hnlich dem Lemma von vorhin."
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "**Robo**: `push_neg at *` kÃ¶nnte helfen die ganzen `Â¬` wegzukriegen."
msgstr ""

#: Game.Levels.SetTheory.L06_Nonempty
msgid "**Du**: Und wie hies das Lemma nochmals?\n"
"\n"
"**Robo**: `eq_empty_iff_forall_not_mem`."
msgstr ""

#: Game.Levels.SetTheory.L07_UnionInter
msgid "Schnittmenge und Vereinigung"
msgstr ""

#: Game.Levels.SetTheory.L07_UnionInter
msgid "Eine alte Dame kommt daher und wendet sich zu VerkÃ¤ufer.\n"
"\n"
"**Dame**: Du, ich hatte einen Gedanken. Kannst du mir folgendes erklÃ¤ren?"
msgstr ""

#: Game.Levels.SetTheory.L08_UnionInter
msgid "Schnittmenge und Vereinigung"
msgstr ""

#: Game.Levels.SetTheory.L08_UnionInter
msgid "**VerkÃ¤ufer**: Ich habe aber was interessanteres:"
msgstr ""

#: Game.Levels.SetTheory.L08_UnionInter
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L08_UnionInter
msgid "**Robo**: Ich habe dir ein paar Sachen aus meinem Speicher zusammengekratzt."
msgstr ""

#: Game.Levels.SetTheory.L08_UnionInter
msgid "mit `union_assoc` und `union_diff_distrib` kannst du\n"
"auf der rechten Seite weiterkommen."
msgstr ""

#: Game.Levels.SetTheory.L09_Complement
msgid "Komplement"
msgstr ""

#: Game.Levels.SetTheory.L09_Complement
msgid "**Dame**: Ok gut. Aber hier nochmals was, was ich in der Zeitung gelesen habe:"
msgstr ""

#: Game.Levels.SetTheory.L09_Complement
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L09_Complement
msgid "**Du**: Gleichheit von Mengen. Das ist sicher wieder ein Fall fÃ¼r beide\n"
"Inkusionen.\n"
"\n"
"**Robo**: Das war `Subset.antisymm_iff`."
msgstr ""

#: Game.Levels.SetTheory.L09_Complement
msgid "**Robo**: `âŠ† univ` ist ein Fall fÃ¼r `simp`."
msgstr ""

#: Game.Levels.SetTheory.L09_Complement
msgid "Da `âŠ†` als `âˆ€x, x âˆˆ A â†’ x âˆˆ B ` definiert ist, fÃ¤ngst du\n"
"am besten mit `intro` an."
msgstr ""

#: Game.Levels.SetTheory.L09_Complement
msgid "Eine MÃ¶glichkeit ist, eine Fallunterscheidung zu machen: `by_cases g: Â«{x}Â» âˆˆ Â«{A}Â»á¶œ`."
msgstr ""

#: Game.Levels.SetTheory.L09_Complement
msgid "Hier kÃ¶nnte `mem_of_subset_of_mem` hilfreich werden."
msgstr ""

#: Game.Levels.SetTheory.L09_Complement
msgid "Diese Richtung geben wir als Lemma: `not_mem_compl_iff`."
msgstr ""

#: Game.Levels.SetTheory.L10_Morgan
msgid "Morgansche Regeln"
msgstr ""

#: Game.Levels.SetTheory.L10_Morgan
msgid "**VerkÃ¤ufer**: Haben Sie schon von Morgan gehÃ¶rt? Der hatte letztig dieses ungelÃ¶ste Problem!"
msgstr ""

#: Game.Levels.SetTheory.L10_Morgan
msgid "**Robo**: Oh du lieber Schaltkreis. Hier ist sind noch mehr aus meinem Speicher."
msgstr ""

#: Game.Levels.SetTheory.L11_SSubset
msgid "Strikte Teilmenge"
msgstr ""

#: Game.Levels.SetTheory.L11_SSubset
msgid "Die Dame geht mit ihrem Einkauf davon.\n"
"\n"
"**VerkÃ¤ufer**: Wisst ihr, seit einer weile redet sie eigentlich immer Ã¼ber den Unterschied\n"
"von `âŠ‚` und `âŠ†`, aber heute nicht. KÃ¶nnt ihr mir schon mal helfen, damit ich morgen\n"
"gewappnet bin?"
msgstr ""

#: Game.Levels.SetTheory.L11_SSubset
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L12_Insert
msgid "Konkrete Mengen"
msgstr ""

#: Game.Levels.SetTheory.L12_Insert
msgid "**Du**: Das ist ja alles schÃ¶n und gut, aber ich weiss immernoch nicht, wie\n"
"ich eine ganz simple Menge wie `{4, 9}` notiereâ€¦\n"
"\n"
"**VerkÃ¤ufer**: Genau so! Aber diese endlichen Mengen sind alles iterative\n"
"Konstruktionen aus `Set.insert` und `singleton`. Hier zum Beispiel:"
msgstr ""

#: Game.Levels.SetTheory.L12_Insert
msgid "Die Menge `{4, 9}` ist per Definition `{4} âˆª {9}`."
msgstr ""

#: Game.Levels.SetTheory.L12_Insert
msgid "**Du**: Das wÃ¤r ja dann `rfl`."
msgstr ""

#: Game.Levels.SetTheory.L13_Insert
msgid "Konkrete Mengen"
msgstr ""

#: Game.Levels.SetTheory.L13_Insert
msgid "**VerkÃ¤ufer**: Ja, also hier ein besseres Beispiel:\n"
"\n"
"Um zu Ã¼berprÃ¼fen, dass gewisse Elemente in\n"
"konkreten Mengen enthalten sind, gibt es nicht direkt eine Taktik, aber ein\n"
"einfaches Rezept:\n"
"\n"
"```\n"
"simp_rw [mem_insert_iff, mem_singleton_iff] at *\n"
"```\n"
"\n"
"vereinfacht Aussagen der Form `6 âˆˆ {0, 6, 1}` zu `(6 = 0) âˆ¨ (6 = 6) âˆ¨ (6 = 1)`,\n"
"und dann kann `tauto` diese Aussage beweisen.\n"
"\n"
"Bei `âŠ†` kann man wie schon vorher zuerst mit `intro x hx` die Definition\n"
"auseinandernehmen und dann gleich vorgehen."
msgstr ""

#: Game.Levels.SetTheory.L13_Insert
msgid "Fang wieder mit `rw [subset_def]` oder direkt mit `intro` an."
msgstr ""

#: Game.Levels.SetTheory.L13_Insert
msgid "**Du**: Das ist ja die eigentliche Aufgabe.\n"
"\n"
"**VerkÃ¤ufer**: Solche Aufgaben sind immer mit\n"
"`simp_rw [mem_insert_iff, mem_singleton_iff] at *` gefolgt von `tauto` lÃ¶sbar!"
msgstr ""

#: Game.Levels.SetTheory.L13_Insert
msgid "**Robo**: Das kann aber ganz schÃ¶n lang werden.\n"
"\n"
"**VerkÃ¤ufer**: Ich habe mir noch nie Ã¼berlegt, was passiert wenn man Ã¼ber zu groÃŸe Mengen\n"
"nachdenktâ€¦"
msgstr ""

#: Game.Levels.SetTheory.L13_Insert
msgid "Damit lÃ¤sst ihr den VerkÃ¤ufer mit seinen Mengen an Obst zurÃ¼ck und wandert weiter."
msgstr ""

#: Game.Levels.SetTheory.L14_SetOf
msgid "Mengen mit Konditionen"
msgstr ""

#: Game.Levels.SetTheory.L14_SetOf
msgid "Eine wichtige mathematische Notation ist Teilmengen zu erstellen,\n"
"die gewissen Bedingungen unterliegen.\n"
"\n"
"`{n : â„• | Odd n}` ist die Menge aller natÃ¼rlichen Zahlen, die ungerade sind.\n"
"Diese Konstruktion hat in Lean den Namen `setOf`\n"
"\n"
"Um zu beweisen, dass ein Element in einer Teilmenge mit Bedingungen ist, braucht\n"
"man `rw [mem_setOf]`. Danach muss man zeigen, dass die Bedinung fÃ¼r\n"
"dieses Element erfÃ¼llt ist."
msgstr ""

#: Game.Levels.SetTheory.L14_SetOf
msgid "**Robo**: Zur Erinnerung, wenn du nicht mehr weisst, wie `Odd` definiert\n"
"ist, benutze `rw [Odd]`."
msgstr ""

#: Game.Levels.SetTheory.L15_Powerset
msgid "Potenzmenge"
msgstr ""

#: Game.Levels.SetTheory.L15_Powerset
msgid "Eine andere wichtige Menge ist die Potenzmenge einer Menge, welche als\n"
"`ğ’« A` geschrieben wird (`\\powerset`). Diese ist als `{S | S âŠ† A}` definiert, also\n"
"alle Mengen, die in $A$ enthalten sind.\n"
"\n"
"Eines der wichtigsten Lemmas ist `mem_powerset_iff: x âˆˆ ğ’« s â†” x âŠ† s` welches\n"
"im Grunde die Definition einsetzt."
msgstr ""

#: Game.Levels.SetTheory.L15_Powerset
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L15_Powerset
msgid "**Robo**: Fang mal mit `intro` an, wie das bei `âŠ†` fast immer der Fall ist."
msgstr ""

#: Game.Levels.SetTheory.L15_Powerset
msgid "**Robo**: Als nÃ¤chstes must du noch die Annahme `Â«{A}Â» âˆˆ ğ’« X âˆª ğ’« Y` zu\n"
"`Â«{A}Â» âˆˆ (ğ’« X) âˆ¨ Â«{A}Â» âˆˆ (ğ’« Y)` wechseln. DafÃ¼r kennst du schon ein Lemma."
msgstr ""

#: Game.Levels.SetTheory.L15_Powerset
msgid "**Robo**: Jetzt wÃ¤r der Zeitpunkt um `mem_powerset_iff` mal Ã¼berall anzuwenden."
msgstr ""

#: Game.Levels.SetTheory.L15_Powerset
msgid "**Robo**: Jetzt kann `tauto` den rest Ã¼bernehmen, vielleicht solltest du diese\n"
"Hilfe annehmen.\n"
"Wenn nicht, brauchst du vermutlich die Lemmas `Set.subset_union_of_subset_left`\n"
"und `Set.subset_union_of_subset_right`"
msgstr ""

#: Game.Levels.SetTheory.L16_Disjoint
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L16_Disjoint
msgid "Um anzunehmen, dass zwei Mengen disjunkt sind schreibt man\n"
"`Disjoint S T`, welches dadurch definiert ist das die\n"
"einzige gemeinsame Teilmenge die leere Menge ist,\n"
"also etwa `A âŠ† S â†’ A âŠ† T â†’ A âŠ† âˆ…`.\n"
"\n"
"Beachte, dass `Disjoint` in Lean genereller definiert ist als\n"
"fÃ¼r Mengen, deshalb siehst du die Symbole\n"
"`â‰¤` anstatt `âŠ†` und `âŠ¥` anstatt `âˆ…`, aber diese bedeuten genau\n"
"das gleiche."
msgstr ""

#: Game.Levels.SetTheory.L16_Disjoint
msgid "**Robo**: Ã–ffne als erstes mal `Disjoint`."
msgstr ""

#: Game.Levels.SetTheory.L16_Disjoint
msgid "**Robo**: Das sieht jetzt ein bisschen gefÃ¼rchig aus, aber das ist einfach ein `âˆƒ`.\n"
"Was du jetzt angeben musst, ist eine Menge, die Teilmenge beider Mengen\n"
"`{n : â„¤ | âˆƒ k, n = 2 * k}` und `{3, 5, 6, 9, 11}` ist."
msgstr ""

#: Game.Levels.SetTheory.L16_Disjoint
msgid "**Robo**: Versuch einmal `use {6}`."
msgstr ""

#: Game.Levels.SetTheory.L16_Disjoint
msgid "**Robo**: Schau mal wie weit `simp` kommt."
msgstr ""

#: Game.Levels.SetTheory.L17_SetOf
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L17_SetOf
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L17_SetOf
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L18_SetOf
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L18_SetOf
msgid "Zu der Teilmengen-Schreibweise (`SetOf`) gibt es noch zwei spezielle\n"
"Syntax, die abundzu auftreten.\n"
"\n"
"Der erste ist `{ x âˆˆ S | 0 â‰¤ x}` ( fÃ¼r z.B `(S : Set â„¤)`),\n"
"welcher eine AbkÃ¼rzung fÃ¼r `{ x : â„¤ | x âˆˆ S âˆ§ 0 â‰¤ x}` ist.\n"
"Entsprechend hilft auch hier `setOf_and`."
msgstr ""

#: Game.Levels.SetTheory.L18_SetOf
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L19_Subtype
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L19_Subtype
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L19_Subtype
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L20_UnionInter
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L20_UnionInter
msgid "Wir haben bereits `âˆª` und `âˆ©` kennengelernt. Von beiden gibt es auch eine Version fÃ¼r Familien\n"
"von Mengen: $\\bigcup_i A_ i$ und $\\bigcap_j B_ j$."
msgstr ""

#: Game.Levels.SetTheory.L20_UnionInter
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L21_Summary
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L21_Summary
msgid ""
msgstr ""

#: Game.Levels.SetTheory.L21_Summary
msgid ""
msgstr ""

#: Game.Levels.SetTheory
msgid "Synolos"
msgstr ""

#: Game.Levels.SetTheory
msgid "[Du betrittst einen Teil des Universums, der noch in der Entstehung ist.\n"
"Lass dich auf Ungereimtheiten, Stolperfallen, und HandlungslÃ¶cher ein. Viel GÃ¼ck!]\n"
"\n"
"Der grÃ¶ÃŸere der beiden Monde sieht dunkelrot und karg aus. Trotzdem sollen dort nomadische\n"
"Gesellschaften wohnen, die sich in der EinÃ¶de zurechtfinden.\n"
"\n"
"Ihr steuert einen der wenigen befestigten Standorte am FuÃŸe eines Berges an.\n"
"\n"
"**Robo**: Die BevÃ¶lkerung hier lebt so abgekapselt vom Rest des Universums, dass sie sich\n"
"vermutlich noch viel besser mit alter Sprache und Schrift auskennt.\n"
"\n"
"**Du**: Hoffen wir, dass sie uns weiterhelfen kÃ¶nnen dieses Buch der Urbilder zu entschlÃ¼sseln.\n"
"\n"
"Sofort begrÃ¼ÃŸt euch eine Ã¤ltere Frau, die sich als *Mengea*, die BeschÃ¼tzerin des Mondes,\n"
"vorstellt."
msgstr ""

#: Game.Levels.SetTheory
msgid "Mehr Mengenlehre"
msgstr ""

#: Game.Levels.SetTheory
msgid "Dieser Planet ist kahl un leer und noch unentdeckt. Zeit und Geschichte scheint es\n"
"hier nicht zu geben."
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "Matrix"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "[Es] fragt euch folgendes:\n"
"\n"
"```\n"
"def FirstColumnSumZero {n : â„•} [NeZero n] :\n"
"    Submodule â„ (Mat[n,n][â„]) where\n"
"  carrier := {A | âˆ‘ i, A i 0 = 0}\n"
"  add_mem' := sorry\n"
"  zero_mem' := sorry\n"
"  smul_mem' := sorry\n"
"```\n"
"\n"
"**Du**: Also die Frage ist, ob die Menge aller `nÃ—n`-Matrizen Ã¼ber $\\mathbb{R}$ mit der\n"
"ersten Spalte null auch wieder einen $\\mathbb{R}$-Vektorraum bildet. Aber wie gehe ich jetzt mit\n"
"dieser Struktur vor? Robo, kannst du mir helfen?\n"
"\n"
"**Robo**: Klar, den Untervektorraum kann ich definieren, aber ich verstehe die Mathe nicht.\n"
"Hier sind die drei Goals die noch Ã¼brig sind:"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Du**: Ich verstehe, beim ersten mÃ¼ssen wir zeigen, dass `a + b` wieder in `M` ist."
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Du**: Haben wir nicht schon gesehen, was dieses `âˆˆ M` bedeutet?\n"
"\n"
"**Robo**: Wir hatten einmal `Set.mem_setOf`, das wird dir helfen!"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Du**: also vermutlich will ich ja jetzt sagen, dass\n"
"$(Â«{a}Â» + Â«{b}Â»)(i,j) = a(i,j) + b (i,j)$ ist.\n"
"\n"
"**Robo**: Das ist `Matrix.add_apply`. Und vergiss nicht, dass man unter Summen\n"
"`simp_rw` verwenden muss anstatt `rw`!"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Du**: DarÃ¼ber hatten wir mal auf Babylon geredet, wie hiess dass nochmals?"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Robo**: `sum_add_distrib`."
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Robo**: Ob deine Annahmen wohl was nÃ¼tzen?"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Robo**: Du kÃ¶nntest aber noch mit `rw [mem_setOf] at *` die Annahmen\n"
"in die richtige Form bringen!"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Robo**: Dieses Goal verlangt, dass `0` in `M` liegt.\n"
"\n"
"**Du**: Ich wÃ¼rd wohl wie vorher gleich mit `mem_setOf` anfangen!"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Robo**: Den Fall wo alles Null ist kann `simp` ganz gut!"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Du**: Ah und das letzte Goal will dass `r â€¢ a` in `M` liegt!\n"
"\n"
"**Robo**: sieht ganz so aus!"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Robo**: `mem_setOf`, dass weisst du doch schon!"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Du**: Ich weiss nicht, was ich mit der Skalarmultiplikation mache. eigenlich ist der\n"
"innere Teil ja einfach `Â«{c}Â» â€¢ (Â«{a}Â» i 0)`.\n"
"\n"
"**Robo**: Das klingt nach einem Fall fÃ¼r `simp`!"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Robo**: Meine Datenbank mit alten Konversationen sagt, dass wir mal `mul_sum`\n"
"hatten auf Babylon."
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Robo**: Du willst von rechts nach links umschreiben, also brauchst du hier\n"
"ein `â†mul_sum`."
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "**Robo**: Du kÃ¶nntest aber noch mit `rw [mem_setOf] at Â«{ha}Â»` die Annahmen\n"
"in die richtige Form bringen!"
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid ""
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid ""
msgstr ""

#: Game.Levels.Matrix.L01_VectorSpace
msgid "Dieses Theorem sollte eigentlich woanders eingefÃ¼hrt werden"
msgstr ""

#: Game.Levels.Matrix
msgid "Matrix"
msgstr ""

#: Game.Levels.Matrix
msgid "Dieser Planet ist kahl un leer und noch unentdeckt. Zeit und Geschichte scheint es\n"
"hier nicht zu geben."
msgstr ""

#: Game.Levels.MatrixTrace.L01_SMulEBasis
msgid "Standardbasis"
msgstr ""

#: Game.Levels.MatrixTrace.L01_SMulEBasis
msgid "Den Spuren folgend, findet ihr ein StÃ¼ck Pergament, auf dem zuoberst\n"
"eine Notiz steht.\n"
"\n"
"```\n"
"E i j := stdBasisMatrix i j (1 : â„)\n"
"```\n"
"\n"
"Darunter ein bisschen wildes Gekritzel, das aber deutlich mit einer klaren\n"
"Zeile angefangen hat:"
msgstr ""

#: Game.Levels.MatrixTrace.L01_SMulEBasis
msgid "`E i j` ist die `n Ã— n`-Matrix (mit Werten in `â„`) mit einer `1` an\n"
"Stelle $(i, j)$ und null Ã¼berall sonst.\n"
"\n"
"Bemerkung: Dies ist eine spezialisierte Form der generellen `stdBasisMatrix i j (a : R)`,\n"
"welche auch nicht-quadratisch sein kann und einen beliebigen Wert `a` aus einem beliebigen\n"
"Ring annehmen kann.\n"
"\n"
"Das Spiel bevorzugt `E`, um die Lesbarkeit zu erhÃ¶hen."
msgstr ""

#: Game.Levels.MatrixTrace.L01_SMulEBasis
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L01_SMulEBasis
msgid "**Du**: Welches Wesen auch immer hier Spuren hinterlassen hat â€“ mir scheint, es mag Matrizen. Was meints du?\n"
"\n"
"**Robo**: Ja! `stdBasisMatrix i j a` kenne ich, das ist die Matrix, die an der Position `(i, j)` den Eintrag `a` hat und sonst Ã¼berall Null ist.\n"
"\n"
"**Du**: Und die `E`s sind dann einfach eine AbkÃ¼rzung fÃ¼r den Fall `a = 1`?\n"
"\n"
"**Robo**: So sieht's aus. Und `A i j` ist einfach der Eintrag der Matrix `A` an der Position `(i, j)`.\n"
"\n"
"**Du**: Ah, verstehe. Da steht also kein Produkt von Matrizen, sondern nur eine Skalarmultiplikation. Dann ist das ja einfach.\n"
"\n"
"**Robo**: Ja. Ich denke wenn du mit `unfold E` anfÃ¤ngst, geht der Rest wie von selbst."
msgstr ""

#: Game.Levels.MatrixTrace.L01_SMulEBasis
msgid "**Du**: Ob das wohl was bringt?\n"
"\n"
"**Robo**: Ich speichere das mal als `Matrix.smul_ebasis` ab, falls wir es nochmals\n"
"brauchen.\n"
"\n"
"Damit folgt ihr weiter der Spur."
msgstr ""

#: Game.Levels.MatrixTrace.L02_EBasis
msgid "Falsche Indizes"
msgstr ""

#: Game.Levels.MatrixTrace.L02_EBasis
msgid "Kurze Zeit spÃ¤ter findet ihr zwei sehr Ã¤hnlichen Zettel, wieder\n"
"vollgekritzelt, fast alles durchgestrichen.\n"
"Die erste Zeile aber lÃ¤sst sich jeweils gerade noch ausmachen."
msgstr ""

#: Game.Levels.MatrixTrace.L02_EBasis
msgid "**Robo**: Ich speichere dieses `E.mul_of_ne` auch mal, wer weiÃŸ.\n"
"\n"
"  **Du**: Jetzt bin ich aber neugierig, wer diese Zettel hier verloren oder weggeworfen hat. Komm, lass uns weitergehen."
msgstr ""

#: Game.Levels.MatrixTrace.L02_EBasis
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L02_EBasis
msgid "**Du**: Das sieht jetzt aber nach Matrizen-Multiplikation aus.\n"
"MÃ¼sste so auch stimmen."
msgstr ""

#: Game.Levels.MatrixTrace.L02_EBasis
msgid "**Robo**: Vergiss aber nicht, dass `simp` die Annahme `Â«{h}Â»` explizit braucht!"
msgstr ""

#: Game.Levels.MatrixTrace.L03
msgid "Richtige Indizes"
msgstr ""

#: Game.Levels.MatrixTrace.L03
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L03
msgid "**Du**: Jetzt bin ich aber neugierig, wer diese Zettel hier verloren oder weggeworfen hat. Komm, lass uns weitergehen."
msgstr ""

#: Game.Levels.MatrixTrace.L03
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L03
msgid "**Du**:  Sieht auch richtig aus."
msgstr ""

#: Game.Levels.MatrixTrace.L04_MatrixEqSum
msgid "Summe von Basiselementen"
msgstr ""

#: Game.Levels.MatrixTrace.L04_MatrixEqSum
msgid "Ihr kommt an eine Stelle, wo das Gras auf einer grÃ¶ÃŸeren, quadratischen\n"
"FlÃ¤che heruntergetrampelt ist. Spuren fÃ¼hren kreuz und queer und in verschiedene\n"
"Richtungen weg.\n"
"\n"
"Ein bisschen planlos sucht ihr die Stelle ab und findet verschiedenste PergamentstÃ¼cke.\n"
"Die meisten sind leer oder unleserlich, aber eines kannst du entziffern."
msgstr ""

#: Game.Levels.MatrixTrace.L04_MatrixEqSum
msgid "Du beschliesst einer besonders markanten Spur zu folgen. Robo zieht dir hinterher und schnappt\n"
"sich beim gehen noch ein willkÃ¼rliches StÃ¼ck Pergament vom Boden."
msgstr ""

#: Game.Levels.MatrixTrace.L04_MatrixEqSum
msgid "Sagt aus, dass man jede $(n Ã— n)$-Matrix (Ã¼ber $\\mathbb{R}$) $A$ schreiben kann\n"
"als $A = \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} A_{ij} \\cdot E(i, j)$.\n"
"\n"
"Siehe auch `matrix_eq_sum_std_basis`, welches die generalisierte Form fÃ¼r\n"
"$(m Ã— n)$-Matrix (Ã¼ber beliebigem $R$) ist."
msgstr ""

#: Game.Levels.MatrixTrace.L04_MatrixEqSum
msgid "Die generellere Version von `matrix_eq_sum_ebasis`. Siehe dort."
msgstr ""

#: Game.Levels.MatrixTrace.L04_MatrixEqSum
msgid "**Du**: Das scheint einfach zu sagen, dass diese `E i j` ein Erzeugendensystem fÃ¼r den Raum der Matrizen bilden.\n"
"\n"
"**Robo**: Da kannst du bestimmt gleich die Resultate anwenden, die wir schon gefunden haben!"
msgstr ""

#: Game.Levels.MatrixTrace.L04_MatrixEqSum
msgid "**Robo**: Unter Summen braucht man `simp_rw`."
msgstr ""

#: Game.Levels.MatrixTrace.L04_MatrixEqSum
msgid "**Robo**: Ja gut, du kannst auch einfach den Beweis vom ersten Pergament wiederholen.\n"
"Nur zu, Ãœbung macht den Meister.\n"
"\n"
"**Du**: Schon gut, ich hab kein mechanisches Hirn wie du."
msgstr ""

#: Game.Levels.MatrixTrace.L04_MatrixEqSum
msgid "**Robo**: Ach ja!  So wie es jetzt hier steht, kenne ich die Aussage aus meiner Bibliothek.\n"
"Das ist genau `apply matrix_eq_sum_std_basis`.\n"
"\n"
"**Du**: Super! Dann brauchen wir uns ja gar nicht damit aufhalten."
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "Einheitsmatrix"
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Du**: Zeig mal, was hast du da? Was zur Einheitsmatrix? Passend fÃ¼r unsere Sammlung?\n"
"\n"
"**Robo**: Ja, schau. Ich glaube, hier kannst Du gleich mit `matrix_eq_sum_ebasis` beginnen.\n"
"\n"
"**Du**: Ich frage mich, ob wir noch wichtiges auf dem Platz zurÃ¼ckgelassen haben?\n"
"\n"
"**Robo**: Egal, jetzt sind wir schon ein gutes StÃ¼cken weiter. Probier jetzt hier einmal!"
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Du**: Ich habe das GefÃ¼hl, wir sind jemandem auf der Spur, der sich fÃ¼r die\n"
"die Diagonale von Matrizen interessiert.  Aber ich bekomme langsam Durst!"
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Du**: Ich denke, die beiden Summen sind identisch, weil jeder Summand identisch ist.\n"
"Denkst du das funktioniert Ã¤hnlich wie mit den Funktionen, da bei dieser Bibliothek?\n"
"\n"
"**Robo**: Die beiden Taktiken `congr` und `ext` kÃ¶nnten dir hier tatsÃ¤chlich helfen.\n"
"\n"
"*(von oben)*: Wurde noch nicht erklÃ¤rt, aber zukÃ¼nftig werden `ext` und\n"
"`congr` schon frÃ¼her eingefÃ¼hrt."
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Du**: Oh, jetzt habe ich nicht nur den Summationsindex, sondern auch noch die beiden\n"
"Indices `Â«{r}Â»,Â«{s}Â»` der Matrizen eingefÃ¼hrt. Aber das sollte passen. Nurâ€¦ die verbleibende Summe\n"
"ist ja Ã¼berall Null auÃŸer beim Index `Â«{i}Â»`.\n"
"\n"
"**Robo**: Ist das so?  Lass mich mal suchenâ€¦  Nicht schÃ¶n, sollte aber funktionieren:  mit `rw [â† Finset.sum_subset (Finset.subset_univ {Â«{i}Â»})]`\n"
"solltest du die Summe so umschreiben kÃ¶nnen, dass sie nur Ã¼ber dem Singleton `{Â«{i}Â»}` lÃ¤uft."
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Du**: Danke, das hilft! Dieser Schritt sollte einfach sein: Eine Summe Ã¼ber ein Element,\n"
"bei diesem ist `1 i i` wieder Eins, und `1 â€¢ _` vereinfacht sich auch!"
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Robo**: `simp` klingt wirklich nach einer guten Idee."
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Du**: Aber was mache ich hier? `Â«{hâ‚‚}Â»` sagt ja mehr oder weniger dass `i â‰  x` ist.\n"
"\n"
"**Robo**: Ja, aber nicht ganz. FÃ¼hr das doch mit `have hâ‚ƒ : i â‰  x` ein und zeig das kurz!"
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Robo**: Umgekehrt wÃ¤re es nÃ¼tzlicher, da\n"
"`1 i x` als `if i = x then _ else _` definiert ist!\n"
"\n"
"**Du**: Du hast recht, ich brauch gleich `i = x` oder `i â‰  x`. Lass mich das Ã¤ndern."
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Du**: Als erstes wÃ¼rde ich mal schauen, ob sich `Â«{hâ‚‚}Â»` vereinfacht."
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Du**: Hmm, jetzt ist das erstmal verdreht.\n"
"\n"
"**Robo**: Erinnere dich an `symm`!\n"
"\n"
"**Du**: Richtig, das brauchten wir ja schon bei diesem wilden Typen mit seinen FÃ¶rderbÃ¤ndern."
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Du**: Wie setze ich denn jetzt die Definition fÃ¼r `1 Â«{i}Â» Â«{x}Â»` ein?\n"
"\n"
"**Robo**: `Matrix.one_apply`!"
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "**Robo**: Und da das falsch ist, kannst du mit `rw` und `if_neg` weiterkommen."
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "Dieses Theorem sollte eigentlich woanders eingefÃ¼hrt werden"
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "Dieses Theorem sollte eigentlich woanders eingefÃ¼hrt werden"
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "Zwei Funktionen sind gleich, wenn sie auf allen Elementen gleich sind.\n"
"\n"
"Wenn das Goal `f = g` ist, kann man mit `ext i`, ein Element `i` einfÃ¼hren, und dann zeigen,\n"
"dass `f i = g i` ist.\n"
"\n"
"`ext` versucht, so viele Indices einzufÃ¼gen wie mÃ¶glich `funext i` fÃ¼hrt nur den spezifizierten ein."
msgstr ""

#: Game.Levels.MatrixTrace.L05_EBasisDiagSum
msgid "`congr` versucht, eine Gleichung `_ = _` auf eine Gleichung von Untertermen zu reduzieren. Zum\n"
"Beispiel ein Goal der Form `f a = f b` wird durch `congr` zu `a = b` reduziert."
msgstr ""

#: Game.Levels.MatrixTrace.L06_EBasisEqOnDiag
msgid "Ein nihilierter Kommutator"
msgstr ""

#: Game.Levels.MatrixTrace.L06_EBasisEqOnDiag
msgid "Der Spur folgend kommt ihr an einem groÃŸen Baum. Im Schatten findet ihr ein regloses Etwas:\n"
"\n"
"$$\n"
"[A, B] = AB - BA\n"
"$$\n"
"\n"
"**Robo**:  Ach ja, ein Kommutator!\n"
"\n"
"**Du**: Der sieht aber ziemlich nihiliert aus.  Ich glaube, der ist verdurstet.\n"
"\n"
"**Robo**: Und schau, hier ist noch was in den Baum gekritzelt."
msgstr ""

#: Game.Levels.MatrixTrace.L06_EBasisEqOnDiag
msgid "**Robo**: Ich glaube, die Annahme, dass Kommutatoren nihiliert werden, nehmen wir jetzt erst\n"
"einmal mit.\n"
"\n"
"**Du**: SchÃ¶n.  Sagte ich bereits, dass ich langsam Durst habe?"
msgstr ""

#: Game.Levels.MatrixTrace.L06_EBasisEqOnDiag
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L06_EBasisEqOnDiag
msgid "**Du**: Mit anderen Worten: Wenn `f` Kommutatoren nihiliert, dann stimmen seine Werte\n"
"auf allen `E i i` Ã¼berein. Stimmt das??\n"
"\n"
"**Robo**: Lass es uns herausfinden!"
msgstr ""

#: Game.Levels.MatrixTrace.L06_EBasisEqOnDiag
msgid "**Du**: Aber was soll ich denn mit unserer Annahme `Â«{hâ‚}Â»` anfangen!\n"
"Ich mÃ¼sste Ã¼berhaupt erst einmal eine Multiplikation haben.\n"
"\n"
"**Robo**: Du mÃ¼sstest ein Matrizenprodukt `A * B` finden, fÃ¼r das  `f (E i i) = f (A * B) = f (E j j)` gilt.\n"
"Dann kÃ¶nnstest du `trans f (A * B)` schreiben, um zwei Beweisziele â€“ `f (E i i) = f (A * B)` und `f (A * B) = f (E j j)` â€“ zu erhalten,\n"
"bei denen `Â«{hâ‚}Â»` vielleicht anwendbar ist."
msgstr ""

#: Game.Levels.MatrixTrace.L06_EBasisEqOnDiag
msgid "**Robo**: Hatten wir nicht `E i k = (E i j) * (E j k)` auf einem dieser Zettel?"
msgstr ""

#: Game.Levels.MatrixTrace.L06_EBasisEqOnDiag
msgid "**Robo**: Hast du das nicht alles gemacht, weil du `Â«{hâ‚}Â»` brauchen\n"
"wolltest?\n"
"\n"
"**Du**: Ah ja, stimmt!"
msgstr ""

#: Game.Levels.MatrixTrace.L07_EBasisZeroOffDiag
msgid "Desinteresse"
msgstr ""

#: Game.Levels.MatrixTrace.L07_EBasisZeroOffDiag
msgid "Gleich neben dem Baum findest du noch eine Notiz, in der groÃŸ `E i j` durchgestrichen ist.\n"
"\n"
"**Du**: Soll wohl heiÃŸen: `E i j` mit i â‰  j interessieren nicht."
msgstr ""

#: Game.Levels.MatrixTrace.L07_EBasisZeroOffDiag
msgid "Die Spuren wirken mittlerweile viel frischer und ihr folgt ihnen schneller und\n"
"unvorsichtiger als zuvor."
msgstr ""

#: Game.Levels.MatrixTrace.L07_EBasisZeroOffDiag
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L07_EBasisZeroOffDiag
msgid "**Robo**: Wie kÃ¶nnten wir denn hier `Â«{hâ‚}Â»` verwenden?\n"
"\n"
"**Du**: Wie wÃ¤r's, wenn wir diesmal `E i j` als Produkt `E i j * E j j` schreiben?\n"
"\n"
"**Robo**:  Wieso gerade so?\n"
"\n"
"**Du**: Wenn ich in diesem Produkt die Faktoren vertausche, erhalte ich Null!  Hatten wir doch auch schon, `E.mul_of_ne` oder so etwas."
msgstr ""

#: Game.Levels.MatrixTrace.L07_EBasisZeroOffDiag
msgid "**Robo*: Wie du meinst. Dann probier doch am besten `trans f (E i j * E j j)`."
msgstr ""

#: Game.Levels.MatrixTrace.L07_EBasisZeroOffDiag
msgid "**Du**: Ehm, das sehe ich einfach von der Definition.\n"
"\n"
"**Robo**: Vergiss nicht `unfold E`, oder sag `simp`, dass es die Definition von `E` benutzen soll (`simp [E]`)."
msgstr ""

#: Game.Levels.MatrixTrace.L07_EBasisZeroOffDiag
msgid "**Robo**: Und hier wolltest du jetzt kommutieren?\n"
"\n"
"**Du**: Genau!"
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "Die Summe der Summe der Summe"
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "Ihr findet nochmals einen Hinweis, aber in der Eile verliert ihr die FÃ¤hrte.\n"
"Du bist inzwischen sehr durstig.  \n"
"WÃ¤hrend Robo die nÃ¤here Umgebung absucht, setzt du dich erschÃ¶pft hin und\n"
"starrst unter der warmen Sonne etwas beduselt auf den Pergamentfetzen."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Du**: Na endlich.  \n"
"\n"
"Robo reicht dir eine Flasche Wasser.\n"
"\n"
"**Du**: Wo hast du die denn auf einmal her? \n"
"\n"
"**Robo**: Trick 17.\n"
"\n"
"**Du**:  Und hast du die FÃ¤hrte wiedergefunden?\n"
"\n"
"**Robo**:  Ja, komm mit! Da hinten hab ich etwas gesehen."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Du**: Ich versteh beim besten Willen nicht, was das jetzt soll! \n"
"Vermutlich sollte ich das `A` in `f A` als Summe von Basismatrizen\n"
"schreiben, nicht aber das andere `A` weiter hinten.\n"
"\n"
"**Robo** (*aus der Ferne*): `nth_rw 1 [ ... ]`! Funktioniert wie `rw`."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Du** (*schreiend*): Was meinst du damit?\n"
"\n"
"**Robo** (*ebenfalls schreiend*): Na, du willst bestimmt `matrix_eq_sum_ebasis A` anwenden, aber mit `nth_rw 1` und nicht mit `rw`.\n"
"`rw [matrix_eq_sum_ebasis A]` wÃ¼rde beide `A`s ersetzen."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Du**: Hmm, `rw` ist tatsÃ¤chlich eine schlechte Idee. \n"
"Das sieht zu kompliziert aus. Lass es mich doch mit `nth_rw` versuchen."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Du** (*in Gedanken*): Jetzt die Funktion in die Summe reinâ€¦ Und ja nicht an Wasser denkenâ€¦\n"
"Auf Babylon gabs genug Wasserâ€¦ Woran war ich nochmals?"
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Robo** (*von irgendwo*): Das klingt nach `map_sum`, aber das hatten wir\n"
"auf Babylon nicht gesehen, das fantasierst du. Aber `simp` kennt dieses Lemma sonst auch."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Du**: Ah ja, im Zweifelsfall vereinfachen."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Du**: Die Summe der Summe der Summe derâ€¦\n"
"\n"
"**Robo*: Hey, woran bist du eigentlich?\n"
"\n"
"**Du**: Keine Ahnung!\n"
"\n"
"**Robo**: Mach doch folgenden Zwischenschritt:\n"
"\n"
"`trans âˆ‘ i, âˆ‘ j, if i = j then (A i j) * f (E i j) else 0`"
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Du**: Summe gleich Summe, `congr`-`ext` macht da der Dumme."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Robo**: Vielleicht gleich nocheinmal?"
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Du**: Und jetzt Fallunterscheidung zu `i = j`â€¦"
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Robo**: `by_cases` war das, genau!"
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Robo**: Hier ist `if_pos Â«{hâ‚‚}Â»` nÃ¼tzlich."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Robo**: â€¦und hier `if_neg Â«{hâ‚‚}Â»`.\n"
"\n"
"**Du**: WeiÃŸ ich doch."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Du**: `f (E i j)` ist doch Null, hatten wir doch schon gesehen!"
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Robo**: Und das hieÃŸ `zero_on_offDiag_ebasis`."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "**Du**: Und ich dachte schon das wÃ¤r's.\n"
"\n"
"**Robo**: Fast, da ist noch die zweite HÃ¤lfte des `trans`-Befehls oben. Diese HÃ¤lfte\n"
"ist ganz einfach."
msgstr ""

#: Game.Levels.MatrixTrace.L08_EvalOnEBasis
msgid "Lineare Abbildungen (oder genereller \"additive\" Abbildungen) kann man mit einer\n"
"Summe vertauschen."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "Matrix"
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "Keine fÃ¼nfzig Meter weiter kommt ihr auf eine kleine AnhÃ¶he. \n"
"Robo zeigt auf einen Punkt in der Ferne.\n"
"\n"
"**Robo**: Schau mal, da liegt es! \n"
"\n"
"**Du**: Und was *ist* das???\n"
"\n"
"**Robo**:  WeiÃŸ nicht.  Aber mein GefÃ¼hl sagt mir, diese Zettel sind eine Art Steckbrief.  Schau mal, hier ist noch einer.  Ich glaube, der sagt, wie groÃŸ es ist."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Du**: Okay. Lass uns vorsichtig nÃ¤her gehen."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Du**: Ich glaube, ich habe eine Idee! DafÃ¼r muss ich aber\n"
"beide Seiten mit `(n + 1)` multiplizieren.\n"
"\n"
"**Robo**: Da gibt es verschiedene MÃ¶glichkeiten.  Zum Beispiel:\n"
"`apply nat_mul_inj' (n := n.succ)`!"
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "(*Stimme von oben*) : Der nÃ¤chste Schritt ist `rw [â†smul_eq_mul, â† LinearMap.map_smul]`,\n"
"aber das kannst du nicht wissen."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Du**: Das Argument auf der linken Seite kann ich jetzt als konstante Summe\n"
"darstellen.\n"
"\n"
"**Robo**: Probier `trans Â«{f}Â» (âˆ‘ x : Fin Â«{n}Â».succ, E Â«{i}Â» Â«{i}Â»)`."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Du**: Genau, dann mÃ¼ssen wir fÃ¼r diese erste Gleichheit nur die konstante Summe ausrechnen.\n"
"\n"
"**Robo**: `simp` kann das sicher komplett vereinfachen."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Du**: Als nÃ¤chstes ziehen wir die Funktion in die Summe rein."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Du**: Und jetzt mÃ¶chte ich die Gleichung durch einen Zwischenschritt\n"
"`âˆ‘ i, f (E i i)` zeigen."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Du**: Nein, das ist jetzt mathematisch falsch!"
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Robo**: Jetzt wieder `congr`-`ext`?\n"
"\n"
"**Du**: Nein, zuerst, die Funktion in die Summe rein, sonst klappt das nicht."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Du**: Nochmals!"
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Du**: Und das war ein Resultat, welches wir auf dem Weg gefunden haben."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Robo**: `eq_on_diag_ebasis` sagt meine Speicherplatte."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "**Robo**: Das sieht nach `ebasis_diag_sum_eq_one` aus."
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "Dieses Theorem sollte eigentlich woanders eingefÃ¼hrt werden"
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "Dieses Theorem sollte eigentlich woanders eingefÃ¼hrt werden"
msgstr ""

#: Game.Levels.MatrixTrace.L09_EvalOnEBasis
msgid "Dieses Theorem sollte eigentlich woanders eingefÃ¼hrt werden"
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "Trace"
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "Ihr schleicht euch langsam an.\n"
"\n"
"**Du** (**flÃ¼sternd**): Ich glaube, du hattest Recht.  Diese Zettel sind eine Art Steckbrief!  \n"
"Und sie beschreiben dieses Wesen hier eindeutig!\n"
"\n"
"**Robo**: Wie meinst du das?\n"
"\n"
"**Du**: Schau doch, seine GrÃ¶ÃŸe, seine Vorliebe fÃ¼r Kommutatoren, und all die anderen Sachen,\n"
"damit kann es eindeutig identifiziert werden kann!\n"
"\n"
"**Robo**: Das musst du mir genauer erklÃ¤ren.\n"
"\n"
"**Du**:  Ich versuch's mal. Gibt es in Leansch einen Namen fÃ¼r die Spur? \n"
"\n"
"**Robo**: Ja klar, die heiÃŸt natÃ¼rlich `trace`.  Manche Formalosophen nennen sie auch liebevoll Tracy.\n"
"\n"
"Du nimmst einen der Pergamentfetzen und schreibst auf die RÃ¼ckseite."
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "**Robo**: Tatsache. Du hattest Recht.\n"
"\n"
"Ihr beobachtet voller EntzÃ¼cken dieses offenbar einzigartige Wesen auf diesem Planeten.\n"
"\n"
"Als ihr nÃ¤her kommt, scheint euch Tracy zu bemerken.  Aber es scheint dadurch keinesfalls gestÃ¶rt\n"
"zu sein."
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "**Du**:  Hier sind noch einmal alle Eigenschaften zusammengefasst.  \n"
"\n"
"**Robo**:  Und du behauptest, nur Tracy hat diese Eigenschaften?\n"
"\n"
"**Du**: Ja.  Ich glaube, das ist so.  Jedes `f`, dass diese Eigenschaften hat, verhÃ¤lt sich auch allen Matrizen genauso wie Tracy.  Und deshalb *ist* es Tracy!"
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "**Robo**: `ext`!"
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "**Du**: Und jetzt schreiben wir `f A` als Summe von Basiselementen."
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "**Robo**: Den Fall `n = 0` sehe ich sofort!\n"
"\n"
"**Du**: Wirklich?\n"
"\n"
"**Robo**: Ja, die Spur einer 0Ã—0-Matrix ist per Definition `0`. Mach mal `rcases n`.\n"
"\n"
"**Du**: Nicht `induction n`?\n"
"\n"
"**Robo**: Geht auch, aber wir brauchen die Induktionshypothese nicht."
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "**Robo**: Ich hab im Kopf mal `simp` ausprobiert. Probier es auch mal."
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "**Du**: Wir hatten doch eben festgestellt, dass `f (E i i) = 1` gilt!\n"
"\n"
"**Robo**: Nachschlagen kann ich gut! Das war `one_on_diag_ebasis`."
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "**Robo**: Denk daran, unter einer Summe must du `simp_rw` verwenden,\n"
"`rw` kann das nicht.\n"
"\n"
"**Du**: Ah, und die expliziten Argumente `hâ‚` und `hâ‚‚` sollte ich wohl auch noch angeben?"
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "**Du** `_ * 1` ist `simp`, oder?"
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "**Robo**: Die beiden Seiten sind per Definition gleich!"
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "**Du**: Wo kommt denn dieses Beweisziel jetzt noch her?\n"
"\n"
"**Robo**: Ganz am Anfang bei `rw [eq_sum_apply_diag_ebasis]` hast du vermutlich dieses Argument\n"
"ausgelassen.  Jetzt kannst du es noch nachholen."
msgstr ""

#: Game.Levels.MatrixTrace.L10_Characterize
msgid "Nicht genau definiert als, aber per Definition Ã¤quivalent zu:\n"
"`trace A = âˆ‘ i, A i i`.\n"
"\n"
"Mathlib benutzt den Term `diag A i` auf den wir hier nicht genauer eingehen."
msgstr ""

#: Game.Levels.MatrixTrace.L11_Linearity
msgid "Trace"
msgstr ""

#: Game.Levels.MatrixTrace.L11_Linearity
msgid "Als ihr mit etwas Abstand stehen bleibt, kommt Tracy auf euch zugelaufen und fÃ¤ngt an zu spielen. Belustigt gibt es euch verschiedenste\n"
"Aufgaben und Terme, und ihr versucht, diese schnell genug zu kombinieren."
msgstr ""

#: Game.Levels.MatrixTrace.L11_Linearity
msgid "SchlieÃŸlich macht ihr euch auf den RÃ¼ckweg.\n"
"Ihr verlauft euch sofort, aber Tracy ist euch offenbar gefolgt und fÃ¼hrt euch quer durch\n"
"die Grasslandschaft zurÃ¼ck zu eurem Schiff."
msgstr ""

#: Game.Levels.MatrixTrace.L11_Linearity
msgid "**Du**: Da geht es gerade offensichtlich um LinearitÃ¤t der Spur von Matrizen."
msgstr ""

#: Game.Levels.MatrixTrace.L11_Linearity
msgid "**Robo**: Dieser letzte Schritt ist `Fintype.card_fin`. Das ginge auch alles\n"
"mit `simp` wenn wir nicht am spielen wÃ¤ren.\n"
"\n"
"**Du**: Ist doch egal, das macht Spass!"
msgstr ""

#: Game.Levels.MatrixTrace.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.MatrixTrace
msgid "Robotswana"
msgstr ""

#: Game.Levels.MatrixTrace
msgid "Ihr landet auf einem warmen Planeten, und tretet auf eine weite Graslandschaft hinaus.\n"
"\n"
"Nach etwas Umschauen entdeckt Robo Spuren, die von eurem Landeplatz wegfÃ¼hren, zwischen\n"
" vereinzelten BÃ¤umen hindurch. Ihr beratet kurz und beschlieÃŸt, den Spuren zu folgen."
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "Cantor's Diagonalargument"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Cantor**: Wusstet ihr dass es keine surjektiven Funktionen `f : A â†’ Set A` gibt? Faszinierend\n"
"oder? Wie das geht? Nehmt doch einmal die Menge `C := { a | a âˆ‰ f a }`. Wenn `f` surjektiv wÃ¤re,\n"
"welches `a : A` wÃ¼rde diese Menge als Bildpunkt haben? Hier, ich gebe euch einfach `C` auch\n"
"schon mit!\n"
"\n"
"[Tipp: `unfold_let` ist wie `unfold` und wird zukÃ¼nftig in Lean zusammengefÃ¼hrt.\n"
"Brauche `unfold_let C` wenn eine lokale Definition in deinen Annahmen ist. Alternativ\n"
"funktionert auch `simp [C]`.]"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Du**: Uff. Aber ehrlich habe ich die das \"Diagonale\" daran noch nicht\n"
"ganz gesehen.\n"
"\n"
"\n"
"**Cantor**: NatÃ¼rlich, das kann ich euch zeigen, aber da muss ich etwas ausholenâ€¦"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Du**: Also ein Widerspruchsbeweis?"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Du**: Und jetzt existiert durch SurjektivitÃ¤t ein Urbild von `Â«{C}Â»`.\n"
"\n"
"**Cantor**: Genau! Und dann Ã¼berlegt euch, ob `b âˆˆ f b` ist oder nicht fÃ¼r\n"
"dieses Urbild `b`!"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Robo**: Das machen wir glaubs am besten mit `by_cases`."
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Du**: Jetzt will ich ja auch noch `Â«{b}Â» âˆ‰ Â«{f}Â» Â«{b}Â»` zeigen fÃ¼r den Widerspruch.\n"
"\n"
"**Robo**: Dann sag doch `suffices hn : Â«{b}Â» âˆ‰ Â«{f}Â» Â«{b}Â»`, erinnerst du dich?"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Robo**: Und noch den Fall wenn `Â«{b}Â» âˆ‰ Â«{f}Â» Â«{b}Â»`"
msgstr ""

#: Game.Levels.Cantor.L02_IsFixedPt_abs
msgid "Fixpunkte"
msgstr ""

#: Game.Levels.Cantor.L02_IsFixedPt_abs
msgid "**Du**: Also wie ist das mit der Diagonalen?\n"
"\n"
"**Cantor**: Um das genauer zu erlÃ¤utern muss ich euch zuerst ein paar rÃ¤tsel zu Fixpunkten stellen."
msgstr ""

#: Game.Levels.Cantor.L02_IsFixedPt_abs
msgid "**Robo**: `IsFixedPt f x` ist die Aussage `f x = x`.\n"
"\n"
"**Du**: Und `abs` ist der Betrag? Was mache ich damit?\n"
"\n"
"**Robo**: Ich denke so einfache Sachen, die `0` beinhalten kann `simp` ganz gut,\n"
"aber ich habe hier auch noch zwei Resultate, die hilfreich aussehen."
msgstr ""

#: Game.Levels.Cantor.L02_IsFixedPt_abs
msgid ""
msgstr ""

#: Game.Levels.Cantor.L02_IsFixedPt_abs
msgid ""
msgstr ""

#: Game.Levels.Cantor.L03_fixedPoints_neg
msgid "Fixpunkt"
msgstr ""

#: Game.Levels.Cantor.L03_fixedPoints_neg
msgid "**Cantor**: Oder schaut hier, die Menge der Fixpunkte von `-(Â·)` ist ein Singleton."
msgstr ""

#: Game.Levels.Cantor.L03_fixedPoints_neg
msgid "**Du**: `fixedPoints f` ist dann wohl die Menge aller Fixpunkte?\n"
"\n"
"**Robo**: Ja, genau: `fixedPoints f := { x | IsFixedPt f x }`.\n"
"\n"
"**Du**: Welche Optionen habe ich nochmals bei Gleichungen von Mengen?\n"
"\n"
"**Robo** Entweder du brauchst `ext x` um `x âˆˆ A â†” x âˆˆ B` zu zeigen, oder\n"
"du benÃ¼tzt `rw [Subset.antisymm_iff]` um dann `A âŠ† B âˆ§ B âŠ† A` zu zeigen."
msgstr ""

#: Game.Levels.Cantor.L03_fixedPoints_neg
msgid ""
msgstr ""

#: Game.Levels.Cantor.L03_fixedPoints_neg
msgid ""
msgstr ""

#: Game.Levels.Cantor.L04_IsFixedPt_not
msgid "Keine Fixpunkte"
msgstr ""

#: Game.Levels.Cantor.L04_IsFixedPt_not
msgid "**Cantor**: Aber auf was ich eigentlich hinaus wollte, ist die Fixpunkte von `Â¬` anzuschauen;\n"
"Es gibt nÃ¤mlich keine!"
msgstr ""

#: Game.Levels.Cantor.L04_IsFixedPt_not
msgid "**Du**: Und was hatten jetzt Fixpunkte mit dem Diagonalargument zu tun?\n"
"\n"
"**Cantor**: Nur Geduld! Ich habe gerade so viel SpaÃŸ!"
msgstr ""

#: Game.Levels.Cantor.L04_IsFixedPt_not
msgid "**Du**: Ja, `Â¬(Â·)` hat keinen Fixpunkt, keine Aussage kann gleichzeitig\n"
"wahr und falsch sein!"
msgstr ""

#: Game.Levels.Cantor.L05_IsFixedPt_odd
msgid "Fixpunkte"
msgstr ""

#: Game.Levels.Cantor.L05_IsFixedPt_odd
msgid "**Cantor**: Zum Beispiel bei ungeraden Funktionen. Da sind die Fixpunkte symmetrisch.\n"
"\n"
"**Du** (*flÃ¼sternd zu Robo*): Das hat jetzt wirklich nichts mehr mit der ursprÃ¼nglichen\n"
"Frage zu tun\n"
"\n"
"**Robo** (*leise*): Na komm schon, wir kommen bestimmt gleich dazu."
msgstr ""

#: Game.Levels.Cantor.L06_idempotent
msgid "Idempotent"
msgstr ""

#: Game.Levels.Cantor.L06_idempotent
msgid "**Cantor**: Also noch ein letztes RÃ¤tsel, dann kommen wir gleich zurÃ¼ck zum\n"
"Diagonalargument.\n"
"\n"
"**Robo**: Oh das sieht anspruchsvoller aus."
msgstr ""

#: Game.Levels.Cantor.L06_idempotent
msgid "**Du**: Etwas womit ich unsicher bin, wie spielt da wohl `Â«{f}Â» âˆ˜ Â«{f}Â» = Â«{f}Â»` mit rein?\n"
"\n"
"**Robo**: Vermutlich willst du das irgendwann auf ein bestimmtes `x` anwenden.\n"
"\n"
"DafÃ¼r kannst du irgendwann `apply congr_fun at Â«{h}Â»` brauchen, damit\n"
"du `âˆ€ x, (Â«{f}Â» âˆ˜ Â«{f}Â») x = Â«{f}Â» x` kriegst."
msgstr ""

#: Game.Levels.Cantor.L06_idempotent
msgid "**Robo**: Wir hatten einmal `Function.comp_apply`!"
msgstr ""

#: Game.Levels.Cantor.L06_idempotent
msgid ""
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag_IsFixedPt
msgid "Diagonalargument"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag_IsFixedPt
msgid "**Cantor**: Genug gerÃ¤tselt, jetzt aber zum Diagonalargument. Wenn wir eine surjektive\n"
"Funktion `f : A â†’ (A â†’ Y)` haben, dann hat jede Funktion `s : A â†’ A` einen Fixpunkt.\n"
"\n"
"**Du**: Und welcher Punkt ist das?\n"
"\n"
"**Cantor**: Gute Frage! Hier, ich geb euch eine Aufgabe um das herauszufinden."
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag_IsFixedPt
msgid "**Cantor**: Diese Aufgabe soll euch vermitteln, wie ihr den Fixpunkt kriegt!"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag_IsFixedPt
msgid "**Du**: Also ist der Fixpunkt dieses diagonale Element `f b b`, fÃ¼r ein `b`\n"
"  das irgendwie aus der SurjektivitÃ¤t kommtâ€¦\n"
"\n"
"  **Cantor**: Und damit auf zum Hauptsatz!"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "Diagonalargument"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Cantor**: Viel GlÃ¼ck!"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Du**: Jetzt mÃ¶chte ich aber mit dieser generellen Form, die ursprÃ¼ngliche\n"
"Aufgabe nochmals lÃ¶sen."
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Cantor**: Mit der Aufgabe vorhin kÃ¶nnt\n"
"ihr sicher herausfinden, was das richtige `c : A â†’ Y` ist, auf das ihr die SurjektivitÃ¤t\n"
"anwenden wollt."
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Robo**: So viel weiss ich: die Funktion\n"
"definieren wir mit\n"
"\n"
"```\n"
"let c : A â†’ Y := fun a â†¦ _\n"
"```\n"
"\n"
"aber den Wert musst schon du herausfinden!"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Cantor**: Gute Wahl!"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Cantor**: Das sieht gut aus, jetzt kÃ¶nnen wir ja\n"
"`cantor_diagonal_isFixedPt` von vorhin brauchen!"
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "Diagonalargument"
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Du**: Und wie hÃ¤ngt das jetzt damit zusammen, dass es keine Surjektive Funktion\n"
"`f : A â†’ Set A` gibt?\n"
"\n"
"**Cantor**: Ganz einfach, nehmt `s` als die Funktion `fun x â†¦ Â¬ x`.\n"
"\n"
"**Robo**: In Lean kann man nÃ¤mlich eine Menge `U : Set A` mit dem PrÃ¤dikat\n"
"`{ x : A | x âˆˆ U } : A â†’ Prop` gleichsetzen, die sind per Definition dasselbe.\n"
"Damit kann man `f : A â†’ Set A` auch als `f : A â†’ A â†’ Prop` sehen.\n"
"\n"
"**Du**: Und `{ a | a âˆ‰ f a }` ist `s (f a a)` fÃ¼r `s : (fun x â†¦ Â¬ x)`, alles klar."
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Cantor**: Ein Widerspruchsbeweis ist die KÃ¼r der Mathematik."
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Du**: Also hier jetzt `cantor_diagonal` verwenden?"
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Robo**: Zum Beispiel mit `apply cantor_diagonal at Â«{h}Â»`!"
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Cantor**: Nein, nein! Wir wollten doch\n"
"mein schÃ¶nes Theorem `cantor_diagonal` verwenden!"
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Cantor**: Wir hatten doch geÃ¼bt, dass `Â¬(Â·)` keinen Fixpunkt hat.\n"
"\n"
"**Robo**: Das habe ich als `not_isFixedPt_not` gepspeichert"
msgstr ""

#: Game.Levels.Cantor
msgid "Cantor"
msgstr ""

#: Game.Levels.Cantor
msgid "Auf eurer Reise kommt ihr an einem Zwergplaneten vorbei. Darauf steht ein Haus mit unendlich vielen\n"
"TÃ¼ren auf jeder Seite. Ihr macht euch einen Spass daran von einem Ecken aus gleichzeitig TÃ¼ren\n"
"aufzutun und zu beobachten wie sich dein Schatten mit dem von Robo kreuzt.\n"
"\n"
"Dann entdeckt ihr einen Mann, der draussen sitzt. In der Hand hÃ¤lt er eine Schriftrolle\n"
"auf der unendliche Zahlenfolgen geschrieben sind, und die Rolle scheint in einem riesigen\n"
"Haufen ausgerolltem Papier zu enden.\n"
"\n"
"Die Person stellt sich euch als Cantor der Magier vor."
msgstr ""

#: Game
msgid "Robo"
msgstr ""

#: Game
msgid "# Game Over oder QED?\n"
"\n"
"Willkommen zu unserem Prototyp eines Lean4-Lernspiels. Hier lernst du computer-gestÃ¼tzte\n"
"BeweisfÃ¼hrung. Das Interface ist etwas vereinfacht, aber wenn du den *Editor Mode* aktivierst, fÃ¼hlt es sich\n"
"fast genauso an wie in VSCode, der Standard-IDE fÃ¼r Lean.\n"
"\n"
"Rechts siehst du eine Ãœbersicht. Das Spiel besteht aus mehreren Planeten, und jeder Planet hat mehrere Levels,\n"
"die in Form von grauen Punkten dargestellt sind. GelÃ¶ste Levels werden grÃ¼n.\n"
"\n"
"Klicke auf den ersten Planeten *Logo*, um deine Reise zu starten.\n"
"\n"
"\n"
"### More\n"
"Schau im MenÃ¼ unter \"Game Info\" fÃ¼r mehr Informationen zum Spiel."
msgstr ""

#: Game
msgid "## Spielstand\n"
"\n"
"Dein Spielstand wird lokal in deinem Browser als *site data* gespeichert.\n"
"Solltest du diese lÃ¶schen, verlierst du deinen Spielstand!\n"
"Viele Browser lÃ¶schen *site data* und *cookies* zusammen.\n"
"Wenn du \"Game rules: lax\" auswÃ¤hlst kannst aber jederzeit jedes Level spielen,\n"
"auch wenn du vorhergende Levels noch nicht gelÃ¶st hast.\n"
"\n"
"## Funding\n"
"\n"
"Dieses Lernspiel wurde und wird im Rahmen des Projekts\n"
"[ADAM: Anticipating the Digital Age of Mathematics](https://hhu-adam.github.io/)\n"
"an der Heinrich-Heine-UniversitÃ¤t DÃ¼sseldorf entwickelt.\n"
"Es wird finanziert durch das Programm *Freiraum 2022* der\n"
"*Stiftung Innovation in der Hochschullehre*.\n"
"\n"
"## Credits\n"
"\n"
"* **Creators:** Jon Eugster, Alexander Bentkamp, Marcus Zibrowius, Sina Hazratpour\n"
"* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"* **Illustrationen:** DuÅ¡an PavliÄ‡\n"
"\n"
"## Kontakt\n"
"\n"
"Das Spiel befindet sich noch in der Entwicklung.\n"
"Wenn du Anregungen hast oder Bugs findest, schreib doch ein Email oder erstelle einen\n"
"Issue auf Github:\n"
"\n"
"* zum Spielinhalt im [Robo repo](https://github.com/hhu-adam/Robo/issues).\n"
"* zum Spielserver im [lean4game repo](https://github.com/leanprover-community/lean4game/issues).\n"
"\n"
"Kontakt: [Jon Eugster](https://www.math.hhu.de/lehrstuehle-/-personen-/-ansprechpartner/innen/lehrstuehle-des-mathematischen-instituts/lehrstuhl-fuer-algebraische-geometrie/team/jon-eugster)"
msgstr ""

#: Game
msgid "Fertig!"
msgstr ""

#: Game
msgid "Erkunde das Leansche Universum mit deinem Robo, welcher dir bei der VerstÃ¤ndigung mit den Formalosophen zur Seite steht."
msgstr ""

#: Game
msgid "Dieses Spiel fÃ¼hrt die Grundlagen zur BeweisfÃ¼hrung in Lean ein und schneidet danach verschiedene Bereiche des Bachelorstudiums an.\n"
"\n"
"(Das Spiel befindet sich noch in der Entstehungsphase.)"
msgstr ""
