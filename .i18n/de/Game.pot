msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Tue Mar 18 16:13:45 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: de\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! 🎉"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings… 🎭"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! 🎉"
msgstr ""

#: Game.Doc.Definition
msgid "Eine Abbildung `f` is injektiv, wenn gilt:\n"
"\n"
"```\n"
"∀ a b, f a = f b → a = b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "Eine Abbildung `f` is surjektiv, wenn gilt:\n"
"\n"
"```\n"
"∀ b, ∃ a, f a = b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "Eine Abbildung ist bijektiv, wenn sie injektiv und surjektiv ist."
msgstr ""

#: Game.Doc.Definition
msgid "Eine Abbildung `f` ist strikt monoton, wenn gilt:\n"
"\n"
"```\n"
"∀ a b, a < b → f a < f b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "`Function.RightInverse f g` ist als `LeftInverse g f` definiert.\n"
"Das bedeutet im Klartext natürlich `∀ x, g (f x) = x`.\n"
"\n"
"Man muss leider `Function.RightInverse`  statt `RightInverse` schreiben,\n"
"da `RightInverse` allein in Leansch mehrdeutig ist."
msgstr ""

#: Game.Doc.Definition
msgid "`LeftInverse g f` bedutet `g ∘ f = id`, oder genauer: `∀ x, g (f x) = x`, wie man mit `unfold` leicht sieht."
msgstr ""

#: Game.Doc.Definition
msgid "`HasRightInverse f` bedeutet, dass `f` ein Rechtsinverses besitzt.\n"
"\n"
"`HasLeftInverse f` bedeutet, dass `f` ein Linkssinverses besitzt."
msgstr ""

#: Game.Doc.Definition
msgid "Für zwei Teilmengen `A` und `B` von `S` (also `A B : Set S`) ist `A ∪ B` die Vereinigung der Teilmengen `A` und `B` von `S`.  Du schreibst `∪` als `\\\\union`."
msgstr ""

#: Game.Doc.Definition
msgid "Für zwei Teilmengen `A` und `B` von `S` (also `A B : Set S`) ist `A ∩ B` der Schnitt der Teilmengen `A` und `B` von `S`.  Du schreibst `∪` als `\\\\inter`."
msgstr ""

#: Game.Doc.Definition
msgid "Für eine Abbildung `f : A → B` ist `range f` die gesamte Bildmenge von `f`:\n"
"```\n"
"range f = {f a | a : A}\n"
"        = {  b | ∃ a, f a = b}\n"
"```\n"
"Das ist also im wesentlichen eine andere Schreibweise für `f '' univ`.\n"
"Um damit zu arbeiten, ist `mem_range` ganz nützlich:\n"
"```\n"
"x ∈ range f ↔ ∃ a, f a = b\n"
"```"
msgstr ""

#: Game.Doc.Definition
msgid "Für eine Abbildung `f : A → B` ist `image f : Set A → Set B`\n"
"einer der induzierten Abbildung auf den Potenzmengen –\n"
"sie bildet eine Teilmenge von `A` ab auf das Bild dieser Teilmenge unter `f`."
msgstr ""

#: Game.Doc.Definition
msgid "Für eine Abbildung `f : A → B` ist `preimage f : Set B → Set A`\n"
"eine der induzierten Abbildung auf den Potenzmengen –\n"
"sie bildet eine Teilmenge von `B` ab auf das Urbild dieser Teilmenge unter `f`."
msgstr ""

#: Game.Doc.Definition
msgid "Für eine Abbildung `f : A → B` und eine Teilmenge `S` von `A` ist\n"
"```\n"
"f '' S = {f a | a ∈ S}\n"
"       = {b | ∃ a ∈ S, f a = b}\n"
"```\n"
"ihr Bild unter `f`.  Beachte das Leerzeichen zwischen `f` und `''`."
msgstr ""

#: Game.Doc.Definition
msgid ", und für eine Teilmenge `T` von `B` ist\n"
"```\n"
"f ⁻¹' T = { a | f a ∈ T}\n"
"```\n"
"ihr Urbild unter `f`.\n"
"Du schreibst das als `f \\\\-1'`.\n"
"Beachte das Leerzeichen zwischen `f` und `\\\\-1'`."
msgstr ""

#: Game.Doc.Definition
msgid "Anonyme Funktionen kann man mit `fun (x : ℤ)  2 * x` definieren und\n"
"wie andere Objekte verwenden.  Den Pfeil `↦` schreibt man als `\\\\maps` oder `\\\\mapsto`.\n"
"Alternativ kann man statt `↦` auch `=>` verwenden."
msgstr ""

#: Game.Doc.Definition
msgid "`A : Set T` bedeutet, dass `A` eine Teilmenge von `T` ist\n"
"(oder genauer, dass `A` eine Menge ist, die aus Elementen vom Typ `T` besteht)."
msgstr ""

#: Game.Doc.Definition
msgid "Für eine Teilmenge `A : Set T` und ein Element `a` aus `T` (genauer: vom Typ `T`) bedeutet `a ∈ A`, dass\n"
"`a` in `A` liegt.\n"
"\n"
"Für Teilmengen der Form `A = { a : T | P a }` kannst du die Aussage\n"
"`a ∈ A` mit `simp` zu `P a` vereinfachen."
msgstr ""

#: Game.Doc.Definition
msgid "Für ein Prädikat `P : T → Prop` ist `{ a : T | P a } : Set P` die Teilmenge,\n"
"die aus all jenen Elementen besteht, die das Prädikat erfüllen.  Zum Beispiel ist\n"
"```\n"
"{ n : ℕ | Even n }\n"
"```\n"
"die Menge der geraden natürlichen Zahlen.\n"
"\n"
"Die Aussage `a ∈ { a : T | P a }` kannst du mit `simp` zu `P a` vereinfachen."
msgstr ""

#: Game.Doc.Definition
msgid "Für zwei Teilmengen `(A B : Set T)` ist `A\\\\B` die Differenz aus `A` and `B`,\n"
"bestehend aus allen Elementen von `A`, die nicht in `B` liegen."
msgstr ""

#: Game.Doc.Definition
msgid "Für `A B : Set T` bedeutet `A ⊆ B`, dass `A` in `B` enthalten ist.\n"
"\n"
"Mit `rw [subset_iff]` kannst du `A ⊆ B` zu `∀ x, x ∈ A → x ∈ B` umschreiben.\n"
"\n"
"Ist `A ⊆ B` das Beweisziel, kannst du auch auch direkt mit `intro a ha`\n"
"ein Element `a` mit `ha : a ∈ A` wählen (und dann `a ∈ B` zeigen).\n"
"\n"
"Ist `h : A ⊆ B` eine Annahme, erhältst du mit `obtain ⟨a, ha⟩ := h` ein Element `a` mit `ha : a ∈ A`.\n"
"\n"
"Um `⊆` zu schreiben, tippst du `\\subset`."
msgstr ""

#: Game.Doc.Definition
msgid "`∅ : Set T` ist die leere Teilmenge.\n"
"Im Formaloversum ist also `∅ : Set ℕ` etwas anderes als `∅ : Set ℝ`\n"
"– das eine ist eine Teilmenge von ℕ, das andere eine Teilmenge von ℝ!\n"
"\n"
"Mit `rw [eq_empty_iff_forall_not_mem]` überführst du eine Gleichung der Form `S = ∅` in die\n"
"Aussage `∀ (x : T), x ∉ s`.\n"
"\n"
"Du schreibst `∅` als `\\\\emptyset`."
msgstr ""

#: Game.Doc.Definition
msgid "`univ : Set T` ist die “Teil”menge, die aus *allen* Elementen vom vom Typ `T` besteht.\n"
"\n"
"Mit `rw [eq_univ_iff_forall]` überführst du eine Gleichung der Form `S = univ` in die\n"
"Aussage `∀ (x : T), x ∈ S`."
msgstr ""

#: Game.Doc.Definition
msgid "Für eine endliche Teilmenge `A : Finset T` und ein Element `a : T` ist\n"
"`insert a A` eine andere Schreibweise für `A ∪ {a}`.\n"
"Es wird keine inhärente Annahme getroffen, ob `a` bereits in `A` liegt, oder nicht."
msgstr ""

#: Game.Doc.Definition
msgid "Für eine endliche Teilmenge `A : Finset T` und ein Element `a : T` ist\n"
"`erase A a` eine andere Schreibweise für `A \\ {a}`."
msgstr ""

#: Game.Doc.Definition
msgid "`A ∧ B` (\"und\") ist die Aussage dass sowohl `A` als auch `B` wahr ist."
msgstr ""

#: Game.Doc.Definition
msgid "* Für `A B : Prop` ist `A → B` eine Implikation \"`A` impliziert `B`\"\n"
"* Für andere `X Y : Type` ist `X → Y` eine Funktion, die Werte aus `X` nach `Y` abbildet,\n"
"  z.B. `f : ℕ → ℤ := n ↦ -n`."
msgstr ""

#: Game.Doc.Definition
msgid "Existenzieller Quantor: Ist `P : A → Prop` ein Prädikat, so ist\n"
"`∃ a : A, P a` die Aussage, dass ein Element `a` in `A` (genauer: vom Typ `A`)\n"
"existiert, für das die Aussage `P a` wahr sei.  Eine reine Existenzaussage lässt sich\n"
"zum Beispiel als `∃ a : A, true` formulieren.\n"
"\n"
"Um eine Aussage der Form `∃ a : A, …` zu beweisen, konstruiert man ein geeignetes Element `a` und\n"
"nutzt dann die `use`-Taktik (`use a`).\n"
"\n"
"Eine Annahme der Form `h : ∃ a : A, P a` lässt sich mit\n"
"`choose a ha using h` oder `obtain ⟨a,ha⟩ := h` in die Bestandteile `a : A` und `ha : P a`\n"
"zerlegen."
msgstr ""

#: Game.Doc.Definition
msgid "Existenzieller Quantor: Ist `P : A → Prop` ein Prädikat, so ist\n"
"`∃! a : A, P a` die Aussage, dass *genau ein* Element `a` in `A` (genauer: vom Typ `A`)\n"
"existiert, für das die Aussage `P a` wahr sei.  Die Aussage hat also zwei Teile: ertens existiert\n"
"solch ein `a`, zweitens ist `a` eindeutig.\n"
"\n"
"Um eine Aussage der Form `∃! a : A, …` zu beweisen, konstruiert man ein geeignetes Element `a` und\n"
"nutzt dann die `use`-Taktik (`use a`), in der Regel unmittelbar gefolgt von `simp`.\n"
"Nach `use a ` and `simp` sollte das Beweisziel folgende Form haben:\n"
"\n"
"`P(a) ∧ ∀ a' : A, P(a') → a' = a`\n"
"\n"
"Eine Annahme der Form `h : ∃! a : A, P a` lässt sich mit\n"
"\n"
"```\n"
"  obtain ⟨a, h_exists, h_unique⟩ := h\n"
"  simp at h_unique\n"
"```\n"
"in die Bestandteile\n"
"```\n"
"   a : A\n"
"   h_exists : P a\n"
"   h_unique : ∀ (y : A), P y → y = a\n"
"```\n"
"zerlegen."
msgstr ""

#: Game.Doc.Definition
msgid "Universeller Quantor: Ist `P : A → Prop` ein Prädikat, so ist\n"
"`∀ a : A, P a` die Aussage, dass die Aussage `P a` für alle `a` in `A`\n"
"(genauer: für alle `a` vom Typ `A`) wahr sei.\n"
"\n"
"Um eine Aussage der Form `∀ a : A, …` zu beweisen, wählt man mit `intro a` zunächst ein\n"
"beliebiges Element `a`.\n"
"\n"
"Ist `h : ∀ a : A, P a` eine Annahme und `a₀ : A` ein konkretes Element, so ist `h a₀`\n"
"eine Notation für `P a₀`.  Man kann auch mit `specialize h a₀` die gegebene Annahme\n"
"über alle möglichen `a` zu einer Annahme `h : P a₀` über dieses konkrete `a₀` einschränken."
msgstr ""

#: Game.Doc.Definition
msgid "Nützliche Taktiken für Gleicheit sind: `rfl`, `rw`, `trans`"
msgstr ""

#: Game.Doc.Definition
msgid "`Even n` ist die Aussage dass `n : ℕ` gerade ist."
msgstr ""

#: Game.Doc.Definition
msgid "Die Aussage `False : Prop` ist nie wahr.\n"
"\n"
"Lean benützt diese intern für Widersprüche, ein Widerspruch ist ein Beweis `(hF : False)` von\n"
"`False` und z.B. `¬ A` ist als `A → False` implementiert."
msgstr ""

#: Game.Doc.Definition
msgid "Genau-dann-wenn (if-and-only-if). Can meistens mit `constructor` oder `obtain ⟨fwd, bwd⟩ := h`\n"
"in Einzelteile zerlegt werden.\n"
"\n"
"Bei einer Annahme `h : A ↔ B`, heissen die Einzelteile zudem `h.mp : A → B` und `h.mpr : B → A`."
msgstr ""

#: Game.Doc.Definition
msgid "Ungleichheit `x ≠ y` ist definiert als `¬ x = y`.  Du siehst das mit `unfold Ne`."
msgstr ""

#: Game.Doc.Definition
msgid "`Nonempty U` ist eine Instanz, die aussagt, dass `U` mindestens ein Element\n"
"enthält.\n"
"\n"
"Wenn `h : Nonempty U`, dann kriegt man mit `obtain ⟨d⟩ := h` eine solches Element `d : U`."
msgstr ""

#: Game.Doc.Definition
msgid "`¬ A` ist intern als `A → False` implementiert.\n"
"\n"
"Nütliche Tactiken sind: `push_neg`, `by_contra`, `contrapose`."
msgstr ""

#: Game.Doc.Definition
msgid "`Odd n` ist die Aussage dass `n : ℕ` ungerade ist."
msgstr ""

#: Game.Doc.Definition
msgid "`A ∨ B` (\"oder\") ist die Aussage mindestens eine der Aussagen `A`, `B` wahr ist."
msgstr ""

#: Game.Doc.Definition
msgid "Für `n : ℕ` bedeutet `Prime n`, dass `n` eine Primzahl ist.\n"
"Um mit dieser Definition zu arbeiten, ist es oft hilfreich, sie mit dem Lemma\n"
"`prime_def` umzuschreiben."
msgstr ""

#: Game.Doc.Definition
msgid "`(A : Prop)` ist eine beliebige Aussage, ohne weitere Angabe, ob diese wahr, falsch oder\n"
"nicht beweisbar ist.\n"
"\n"
"Siehe auch `(True : Prop)` und `(False : Prop)` die uneingeschränkt wahre (rsp. falsche)\n"
"Aussage."
msgstr ""

#: Game.Doc.Definition
msgid "Die Aussage `True : Prop` ist immer wahr."
msgstr ""

#: Game.Doc.Tactic
msgid "Sind eine Annahme `h : A` und eine Implikation `hAB : A → B` gegeben, so\n"
"verwandelt `apply hAB at h` die gegebene Annahme in die Annahme `h : B`.\n"
"Ist `B` unser Beweisziel, können wir mit `apply hAB` auch rückwärts argumentieren und\n"
"erhalten `A` als neues Beweisziel.   In beiden Fällen kann die Implikation `hAB` wahlweise\n"
"als Annahme gegeben oder ein bereits bekanntes Lemma sein.\n"
"\n"
"\n"
"## Beispiel\n"
"\n"
"Gegeben sei für `n : ℕ` folgendes Lemma:\n"
"```\n"
"lemma lem (h : n ≤ 0) : n = 0\n"
"```\n"
"\n"
"Finden wir nun als Beweisziel\n"
"\n"
"```\n"
"Goal\n"
"  n = 0\n"
"```\n"
"\n"
"vor, so ändert `apply lem` das Beweisziel zu `n ≤ 0`.\n"
"\n"
"Anders herum, falls wir eine Annahme `g : m ≤ 0` in unseren Annahmen finden, können wir\n"
"diese mit `apply lem at g` zu `g : m = 0` umwandeln.\n"
"\n"
"(Das Lemma ist gemeinhin als `Nat.eq_zero_of_le_zero` bekannt.)"
msgstr ""

#: Game.Doc.Tactic
msgid "`assumption` sucht nach einer Annahme, die genau dem Goal entspricht.\n"
"\n"
"## Beispiel\n"
"\n"
"`assumption` sucht durch die Annahmen und merkt dass `h` genau mit dem Goal übereinstimmt.\n"
"\n"
"```\n"
"Objekte\n"
"  a b c d : ℕ\n"
"  h : a + b = c\n"
"  g : a * b = 16\n"
"  t : c = 12\n"
"Goal\n"
"  a + b = c\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`by_cases h : P` macht eine Fallunterscheidung. Im ersten Goal wird eine Annahme\n"
"`(h : P)` hinzugefügt, im zweiten `(h : ¬P)`.\n"
"\n"
"## Details\n"
"\n"
"`P` kann eine beliegige Aussage sein, die als entweder wahr oder falsch angenommen wird.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"example (A : Prop) : A ∨ ¬ A := by\n"
"  by_cases h : A\n"
"  · left\n"
"    assumption\n"
"  · right\n"
"    assumption\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`by_contra h` startet einen Widerspruchsbeweis.\n"
"\n"
"## Details\n"
"Sei `P` das aktuelle Goal. `by_contra h` fügt eine neue Annahme `(h : ¬P)` hinzu\n"
"und setzt das Goal auf `False`.\n"
"\n"
"Oft will man `by_contra` nutzen wenn das Goal von der Form `¬ P` ist.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `contradiction` schliesst den Widerspruchsbeweis wenn sich (zwei) Annahmen\n"
"widersprechen.\n"
"* `contrapose` führt einen Beweis durch Kontraposition und ist entsprechend\n"
"in ähnlichen Situationen nutzbar wie `by_contra`"
msgstr ""

#: Game.Doc.Tactic
msgid "`change t` ändert das Goal zu `t`. Voraussetzung ist, dass `t` und das alte Goal defEq sind.\n"
"\n"
"## Details\n"
"\n"
"Dies ist insbesonder hilfreich wenn eine Taktik nicht merkt, dass das Goal defEq ist zu einem\n"
"Term, der eigentlich gebraucht würde.\n"
"\n"
"## Beispiel\n"
"\n"
"Aktuelles Goal:\n"
"\n"
"```\n"
"b: ℝ\n"
"⊢ 1 • b = b\n"
"```\n"
"Wobei die Skalarmultiplikation als `fun (a : ℚ) (r : ℝ) => ↑a * r` definiert war. Dann\n"
"kann man mit `change (1 : ℚ) * b = b` das Goal umschreiben und anschliessend mit Lemmas\n"
"über die Multiplikation beweisen."
msgstr ""

#: Game.Doc.Tactic
msgid "Eine Annahme der Form `h : ∃ b : B, P b` lässt sich mit\n"
"`choose b hb using h` in die Bestandteile `b : A` und `hb : P b`\n"
"zerlegen.\n"
"\n"
"Allgemeiner können wir `choose` verwenden, um Elemente mit dem Auswahlaxiom zu wählen:\n"
"aus einer Annahme der Form `h : ∀ a, ∃ b, P a b` extrahiert `choose f hf using h`\n"
"eine Abbildung `f : A → B` und die Aussage ` ∀ (a : A), P a (f a)`.\n"
"(Hier ist `P : A → (B → Prop)` ein Prädikat, dass von zwei Variablen `a` und `b` abhängt.)"
msgstr ""

#: Game.Doc.Tactic
msgid "`constructor` teilt ein Beweisziel, das eine Struktur ist, in seine Bestandteile auf.\n"
"\n"
"## Detail\n"
"\n"
"Übliche Anwendungsfälle sind Beweisziele der Form `A ∧ B` sowie Äquivalenzen, also Beweisziele der Form `A ↔ B`.\n"
"Im ersten Fall ersetzt `constructor` das Ziel `A ∧ B` durch die zwei Ziel `A` and `B`, im zweiten Fall ersetzt `constructor` die Äquivalenz durch die beiden Beweisziele `A → B` and `B → A`.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* Das Gegenteil von `constructor` ist `⟨_, _⟩` (`\\\\<>`), der *anonyme Konstruktor*.\n"
"Dieser enspricht ungefähr der Tupel-Notation in\n"
"\\\"eine Gruppe ist ein Tupel $(G, 0, +)$, sodass …\\\".\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"example {A B : Prop} (h : A) (g : B) : A ∧ B := by\n"
"  constructor\n"
"  · assumption\n"
"  · assumption\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`contradiction` schliesst den Beweis wenn es einen Widerspruch in den Annahmen findet.\n"
"\n"
"## Details\n"
"\n"
"Ein Widerspruch in den Annahmen kann unter anderem folgendermaßen aussehen:\n"
"\n"
"* `(h : n ≠ n)`\n"
"* `(h : A)` und `(h' : ¬A)`\n"
"* `(h : False)` (i.e. ein Beweis von `False`)\n"
"\n"
"## Beispiel\n"
"\n"
"Folgenes Goal wird von `contradiction` bewiesen\n"
"\n"
"```\n"
"Objekte:\n"
"  (n m : ℕ)\n"
"  (h : n = m)\n"
"  (g : n ≠ m)\n"
"Goal\n"
"  37 = 60\n"
"```\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* Normalerweise wird `contradiction` gebraucht um einen Widerspruchsbeweis zu\n"
"  schliessen, der mit `by_contra` eröffnet wurde.\n"
"* Ein Beweis von `False` representiert in Lean einen Widerspruch.\n"
"  nach dem Motto \\\"ein Widerspruch beweist alles.\\\""
msgstr ""

#: Game.Doc.Tactic
msgid "`contrapose` ändert ein Goal der Form `A → B` zu `¬B → ¬A` und führt damit\n"
"eine Beweis durch Kontraposition.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `revert h` kann nützlich sein um eine Annahme als Implikationsprämisse zu schreiben bevor man\n"
"  `contrapose` verwendet."
msgstr ""

#: Game.Doc.Tactic
msgid "`exact h` schliesst das Goal wenn der Term `h` mit dem Goal übereinstimmt."
msgstr ""

#: Game.Doc.Tactic
msgid "Zwei Teilmengen einer gegebenen Menge sind gleich, wenn sie dieselben Elemente besitzen.\n"
"Steht im Beweisziel\n"
"```\n"
"A = B\n"
"```\n"
"für zwei Teilmengen von `T` (also für `A B : Set T`),\n"
"so überführt `ext x` das Beweisziel in die Äquivalenz\n"
"```\n"
"x ∈ A ↔ x ∈ B.\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`fin_cases i` führt eine Fallunterscheidung wenn `i` ein endlicher Typ ist.\n"
"\n"
"## Details\n"
"`fin_cases i` ist insbesondere nützlich für `(i : Fin n)`, zum Beispiel als Index in\n"
"endlich dimensionalen Vektorräumen.\n"
"\n"
"In diesem Fall bewirkt `fin_cases i` dass man Komponentenweise arbeitet."
msgstr ""

#: Game.Doc.Tactic
msgid "Zwei Abbildungen mit demselben Werte- und Definitionsbereich sind gleich,\n"
"wenn sie auf allen Elementen des Definitionsbereichs dieselben Werte annehmen.\n"
"Ein Beweisziel der Form\n"
"```\n"
"f = g\n"
"```\n"
"für Abbildungen `f g : X → Y` wird durch `funext x`\n"
"in die Gleichung\n"
"```\n"
"f x = g x.\n"
"```\n"
"überführt."
msgstr ""

#: Game.Doc.Tactic
msgid "Mit `generalize` kann man ein Beweisziel verallgemeinern\n"
"– gewöhnlich in der Hoffnung, dass ein höherer Abstraktionsgrad einen einfacheren Beweis erlaubt.\n"
"Genauer ersetzt `generalize h : a = b` alle Vorkommen von `a` im Beweisziel durch `b`\n"
"(und ergänzt die Annahme `h : a = b`).\n"
"\n"
"## Beispiel\n"
"\n"
"Ein Ziel der Form\n"
"```\n"
"Even x ∨ ¬Even x\n"
"```\n"
"lässt sich mit\n"
"```\n"
"generalize h : (Even x) = A\n"
"```\n"
"in\n"
"```\n"
"A ∨ ¬A\n"
"```\n"
"überführen (und dann einfach mit `tauto` beweisen."
msgstr ""

#: Game.Doc.Tactic
msgid "`have h : P` führt ein Zwischenresultat ein.\n"
"\n"
"## Details\n"
"Anschliessend muss man zuerst dieses Zwischenresultat beweisen bevor man mit dem Beweis\n"
"weitermachen und das Zwischenresultat verwenden kann.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `suffices h : P` funktioniert genau gleich, außer dass die beiden entstehenden Beweise\n"
"  vertauscht sind.\n"
"* `let h : Prop := A ∧ B` ist verwandt mit `have`, mit Unterschied, dass man mit `let`\n"
"  eine temporäre Definition einführt."
msgstr ""

#: Game.Doc.Tactic
msgid "Mit `if … then … else` können Abbildungen mit zwei Definitionszweigen definiert werden.\n"
"\n"
"## Beispiel\n"
"\n"
"`fun x ↦ if 0 ≤ x then -x else x` definiert die Betragsfunktion."
msgstr ""

#: Game.Doc.Tactic
msgid "`induction n` führt einen Induktionsbeweis über `n`.\n"
"\n"
"## Detail\n"
"\n"
"Diese Taktik erstellt zwei Goals:\n"
"* Induktionsanfang, wo `n = 0` ersetzt wird.\n"
"* Induktionsschritt, in dem man die Induktionshypothese `n_ih` zur Verfügung hat.\n"
"\n"
"## Modifikationen in diesem Spiel\n"
"\n"
"* `induction n with d hd` benennt Induktionsvariable und -hypothese. (das ist Lean3-Syntax)\n"
"und funktioniert außerhalb vom Spiel nicht genau so.\n"
"* Außerhalb des Spiels kriegst du `Nat.zero` und `Nat.succ n` anstatt `0` und `n + 1`\n"
"als Fälle. Diese\n"
"Terme sind DefEq, aber manchmal benötigt man die lemmas `zero_eq` und `Nat.succ_eq_add_one`\n"
"um zwischen den schreibweisen zu wechseln\n"
"\n"
"Der richtige Lean4-Syntax für `with` streckt sich über mehrere Zeilen und ist:\n"
"\n"
"```\n"
"induction n with\n"
"| zero =>\n"
"  sorry\n"
"| succ m m_ih =>\n"
"  sorry\n"
"```\n"
"\n"
"da dieser sich über mehrere Zeilen erstreckt wird er im Spiel nicht eingeführt.\n"
"\n"
"## Hifreiche Resultate\n"
"\n"
"* `Nat.succ_eq_add_one`: schreibt `n.succ = n + 1` um.\n"
"* `Nat.zero_eq`: schreibt `Nat.zero = 0` um.\n"
"\n"
"Beide sind DefEq, aber manche Taktiken können nicht damit umgehen\n"
"\n"
"* Siehe Definition `∑` für Hilfe mit Induktion über Summen.\n"
"* `obtain ⟨⟩ := n` ist sehr ähnlich zu `induction n`. Der Unterschied ist, dass bei\n"
"`obtain` keine Induktionshypothese im Fall `n + 1` zur Verfügung steht.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"example (n : ℕ) : 4 ∣ 5^n + 7 := by\n"
"  induction n\n"
"  sorry      -- Fall `n = 0`\n"
"  sorry      -- Fall `n + 1`\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`intro x` wird für Goals der Form `A → B` oder `∀ x, P x` verwendet.\n"
"Dadurch wird die Implikationsprämisse (oder das Objekt `x`) den Annahmen hinzugefügt.\n"
"\n"
"## Beispiele\n"
"\n"
"```\n"
"Goal:\n"
"  ∀ (m n : ℕ), n ≤ m ∨ m ≤ n\n"
"```\n"
"\n"
"die Taktik `intro a n` führt 2 Variablen ein und gibt diesen die Namen `a` und `n`:\n"
"\n"
"```\n"
"Objekte:\n"
"  a n : ℕ\n"
"Goal:\n"
"  n ≤ a ∨ a ≤ n\n"
"```\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `revert h` macht das Gegenteil von `intro`."
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn das Goal von der Form `A ∨ B` ist, enscheidet man mit `left` die linke Seite zu zeigen.\n"
"\n"
"## Beispiele\n"
"\n"
"Folgendes Beispiel kann mit `left` und `assumption` gelöst werden.\n"
"```\n"
"Objekte:\n"
"  ha : A\n"
"Goal:\n"
"  A ∨ B\n"
"```\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `right` entscheidet sich für die right Seite."
msgstr ""

#: Game.Doc.Tactic
msgid "`let x : ℕ := 5 ^ 2` führt eine neue temporäre Definition ein.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `have x : ℕ := 5 ^ 2` führt ebenfalls eine neue natürliche Zahle `x` ein, aber\n"
"  Lean vergisst sofort, wie die Zahl definiert war. D.h. `x = 25` wäre dann nicht\n"
"  beweisbar. Mit `let x : ℕ := 5 ^ 2` ist `x = 25` durch `rfl` beweisbar.\n"
"* `set x : ℕ := 5 ^ 2` macht das Gleiche wie `let` aber versucht auch `x` im Goal überall einzusetzen wo `5 ^ 2` steht."
msgstr ""

#: Game.Doc.Tactic
msgid "`set f := _` funktioniert wie `let` aber versucht auch `f` im Goal überall einzusetzen."
msgstr ""

#: Game.Doc.Tactic
msgid "`linarith` kann zeigen, dass eine lineare Gleichung oder Ungleichung aus gegebenen Gleichungen oder Ungleichungen folgt.\n"
"Es ist recht flexibel, in welchem Kontext man arbeitet, und funktioniert genauso gut in ℕ wie in ℝ.\n"
"Die (Un)Gleichungen müssen aber gut lesbar gegeben sein -- eine Annahme der Form\n"
"```\n"
"m ≤ x → n < x\n"
"```\n"
"muss beispielsweise erst mit\n"
"```\n"
"rw [imp_iff_or_not] at h\n"
"```\n"
"zu\n"
"```\n"
"hx : n < x ∨ ¬m ≤ x\n"
"```\n"
"umgeschrieben werden, damit `linarith` damit etwas anfangen kann."
msgstr ""

#: Game.Doc.Tactic
msgid "`omega` kann zeigen, dass eine lineare Gleichung oder Ungleichungen in `ℕ` oder `ℤ`\n"
"aus gegebenen Gleichungen oder Ungleichungen folgt.\n"
"Es ist weniger wählerisch als `linarith`, was die Präsentation dieser (Un)Gleichungen anbelang."
msgstr ""

#: Game.Doc.Tactic
msgid "`push_neg` schreibt `¬∀ x, _` zu `∃ x, ¬ _` und `¬∃ x, _` zu `∀x, ¬ _` um.\n"
"\n"
"## Details\n"
"\n"
"`push_neg` schiebt das `¬` soweit nach innen wie möglich.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* Die beiden Lemmas heissen `not_forall` und `not_exists` und können mit `rw` einzeln angewendet\n"
"  werden.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Objekte:\n"
"  x : ℝ\n"
"  f : ℝ → ℝ\n"
"Goal:\n"
"  ¬ ∀ ε, ∃ δ, ∀ y, | x - y | < δ → | f x - f y | < ε\n"
"```\n"
"\n"
"`push_neg` wandelt dies in folgendes Goal um:\n"
"\n"
"```\n"
"Objekte:\n"
"  x : ℝ\n"
"  f : ℝ → ℝ\n"
"Goal:\n"
"  ∃ ε, ∀ δ, ∃ y, ¬ (| x - y | < δ → | f x - f y | < ε)\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`obtain ⟨⟩ := h` teilt eine Annahme `h` in ihre Einzelteile auf.\n"
"\n"
"## Details\n"
"Für Annahmen die Strukturen sind, wie z.B. `h : A ∧ B` (oder `∃x, P x`) kann man die\n"
"Einzelteile mit  `obtain ⟨a, b⟩ := h` benennen.\n"
"\n"
"Für eine Annahme der Form `h : A ∨ B` kann man mit `obtain ha | hb := h` zwei Goals\n"
"erzeugen, einmal unter Annahme der linken Seite, einmal unter Annahme der Rechten.\n"
"\n"
"Die Wildcard `obtain ⟨⟩ := h` entscheidet selbständig, welcher Fall vorliegt und\n"
"benennt die entehenden Annahmen.\n"
"\n"
"## Beispiele\n"
"\n"
"```\n"
"Annahmen:\n"
"  h : A ∧ B\n"
"  g : A → C ∨ B → C\n"
"Goal:\n"
"  C\n"
"```\n"
"\n"
"wenn man hier `obtain ⟨h₁, h₂⟩ := h` und danach `obtain g₁ | g₂ := g` benützt, kriegt man\n"
"zwei Goals:\n"
"\n"
"```\n"
"Annahmen:\n"
"  h₁ : A\n"
"  h₂ : B\n"
"  g₁ : A → C\n"
"Goal:\n"
"  C\n"
"```\n"
"\n"
"```\n"
"Annahmen:\n"
"  h₁ : A\n"
"  h₂ : B\n"
"  g₂ : B → C\n"
"Goal:\n"
"  C\n"
"```\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* Für `n : ℕ` hat `obtain ⟨⟩ := n` einen ähnlichen Effekt wie `induction n` mit dem Unterschied,\n"
"  dass im Fall `n + 1` keine Induktionshypothese zur Verfügung steht."
msgstr ""

#: Game.Doc.Tactic
msgid "`refine' { .. }` wird benötigt um eine Struktur (z.B. ein $R$-Modul) im Taktikmodus in einzelne\n"
"Goals aufzuteilen. Danach hat man ein Goal pro Strukturfeld.\n"
"\n"
"(*Bemerkung*: Es gibt in Lean verschiedenste bessere Varianten dies zu erreichen,\n"
"z.B. \\\"Term Modus\\\" oder \\\"anonyme Konstruktoren\\\", aber für den Zweck des Spieles bleiben wir\n"
"bei diesem Syntax.)"
msgstr ""

#: Game.Doc.Tactic
msgid "`revert h` fügt die Annahme `h` als Implikationsprämisse vorne ans Goal an.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Objekte:\n"
"  A B : Prop\n"
"Annahmen:\n"
"  h : A\n"
"  g : A → B\n"
"Goal:\n"
"  B\n"
"```\n"
"\n"
"In diesem Fall bewirkt `revert h`, dass `h` aus den Annahmen vorne als `A →` ans Goal angefügt wird:\n"
"\n"
"```\n"
"Objekte:\n"
"  A B : Prop\n"
"Annahmen:\n"
"  g : A → B\n"
"Goal:\n"
"  a → B\n"
"```\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `revert` ist das Gegenteil von `intro`.\n"
"* `revert` kann insbesondere nützlich sein, um anschliessend `contrapose` zu verwenden.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Objekte\n"
"  A P : Prop\n"
"  h : P\n"
"Goal\n"
"  A\n"
"```\n"
"\n"
"hier ändert `revert h` das Goal zu\n"
"\n"
"```\n"
"Objekte\n"
"  A P : Prop\n"
"Goal\n"
"  P → A\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`rfl` beweist ein Goal der Form `X = X`.\n"
"\n"
"## Detail\n"
"\n"
"`rfl` beweist jedes Goal `A = B` wenn `A` und `B` per Definition das gleiche sind (DefEq).\n"
"Andere Taktiken rufen `rfl` oft am Ende versteckt\n"
"automatisch auf um zu versuchen, den Beweis zu schliessen.\n"
"\n"
"\n"
"## Beispiel\n"
"`rfl` kann folgende Goals beweisen:\n"
"\n"
"```\n"
"Objekte\n"
"  a b c : ℕ\n"
"Goal:\n"
"  (a + b) * c = (a + b) * c\n"
"```\n"
"\n"
"```\n"
"Objekte\n"
"  n : ℕ\n"
"Goal\n"
"  1 + 1 = 2\n"
"```\n"
"denn Lean liest dies intern als `0.succ.succ = 0.succ.succ`."
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn das Goal von der Form `A ∨ B` ist, enscheidet man mit `right` die rechte Seite zu zeigen.\n"
"\n"
"## Beispiele\n"
"\n"
"Folgendes Beispiel kann mit `right` und `assumption` gelöst werden.\n"
"```\n"
"Objekte:\n"
"  hB : B\n"
"Goal:\n"
"  A ∨ B\n"
"```\n"
"\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `left` entscheidet sich für die linke Seite."
msgstr ""

#: Game.Doc.Tactic
msgid "Löst Gleichungen mit den Operationen `+, -, *, ^`.\n"
"\n"
"## Details\n"
"Insbesondere funktioniert `ring` in Ringen/Semiringen wie z.B. `ℕ, ℤ, ℚ, …`\n"
"(i.e. Typen `R` mit Instanzen `Ring R` oder `Semiring R`).\n"
"Die Taktik ist besonders auf kommutative Ringe (`CommRing R`) ausgelegt.\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `ring` kann nicht wirklich mit Division (`/`) oder Inversen (`⁻¹`) umgehen. Dafür ist die\n"
"  Taktik `field_simp` gedacht, und die typische Sequenz ist\n"
"  ```\n"
"  field_simp\n"
"  ring\n"
"  ```\n"
"\n"
"### Beispiel\n"
"\n"
"\n"
"Dieses Goal kann mit der Taktik `ring` gelöst werden:\n"
"\n"
"```\n"
"Goal:\n"
"  1 + n * 2 + n + 12 = 3 * n + 13\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn man eine Annahme `(h : X = Y)` hat, kann man mit\n"
"`rw [h]` alle `X` im Goal durch `Y` ersetzen.\n"
"\n"
"## Details\n"
"\n"
"* `rw [←h]` wendet `h` rückwärts an und ersetzt alle `Y` durch `X`.\n"
"* `rw [h, g, ←f]`: Man kann auch mehrere `rw` zusammenfassen.\n"
"* `rw [h] at h₂` ersetzt alle `X` in `h₂` zu `Y` (anstatt im Goal).\n"
"* `rw [my_theorem]` sucht nach dem ersten Ort, wo es umschreiben kann um die Impliziten\n"
"  Argumente von `my_theorem` zu füllen\n"
"* `nth_rw 2 [my_theorem]` ist eine Variante, die stattdessen am 2. Ort umschreibt.\n"
"\n"
"`rw` funktioniert gleichermaßen mit Annahmen `(h : X = Y)` also auch\n"
"mit Theoremen/Lemmas der Form `X = Y`\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Objekte:\n"
"  m n : ℕ\n"
"  f g : ℕ → ℕ\n"
"Annahmen:\n"
"  h₁ : m = n\n"
"  h₂ : f = g\n"
"Goal:\n"
"  f m = g n\n"
"```\n"
"\n"
"`rw [h₂]` schreibt das Goal zu `g n = g m` um, ein weiteres `rw [h₁]` dann zu `g m = g m`, was es\n"
"direkt auch schließt."
msgstr ""

#: Game.Doc.Tactic
msgid "(shouldn't be visible to the player!)"
msgstr ""

#: Game.Doc.Tactic
msgid "`simp` versucht alle Vereinfachungslemmas anzuwenden, die in der `mathlib` mit `@[simp]`\n"
"gekennzeichnet sind.\n"
"\n"
"## Details\n"
"\n"
"* `simp?` zeigt welche Lemmas verwendet wurden.\n"
"* `simp [my_lemma]` fügt zudem `my_lemma` temporär zur Menge der `simp`-Lemmas hinzu.\n"
"* ein `simp`, das nicht am Ende des Beweis steht sollte durch eine entsprechende\n"
"  `simp only [...]` Aussage ersetzt werden, um den Beweis stabiler zu machen."
msgstr ""

#: Game.Doc.Tactic
msgid "`simp_rw [h₁, h₂, h₃]` versucht wie `rw` jedes Lemma der Reihe nach zu Umschreiben zu verwenden,\n"
"verwendet aber jedes Lemma so oft es kann.\n"
"\n"
"## Details\n"
"\n"
"Es bestehen aber drei grosse Unterschiede zu `rw`:\n"
"\n"
"* `simp_rw` wendet jedes Lemma so oft an wie es nur kann.\n"
"* `simp_rw` kann besser unter Quantifiern umschreiben als `rw`.\n"
"* `simp_rw` führt nach jedem Schritt ein `simp only []` aus und vereinfacht dadurch grundlegenste\n"
"  Sachen."
msgstr ""

#: Game.Doc.Tactic
msgid "`specialize h a₁ a₂` ist äquivalent zu `have h := h a₁ a₂`: es ersetzt eine Annahme\n"
"`h : ∀ m₁ m₂, P m₁ m₂` durch den Spezialfall `h : P a₁ a₂`.\n"
"\n"
"Falls man mehrmals spezialisieren möchte, sollte man statt `specialize`\n"
"`have` verwenden, da `specialize h …` die alte Annahme `h` überschreibt.\n"
"Aus obiger Annahme `h` erhält man beispielsweise mit\n"
"```\n"
"have ha := h a₁ a₂\n"
"have hb := h b₁ b₂\n"
"```\n"
"die folgenden drei Annahmen:\n"
"```\n"
"h : ∀ m₁ m₂, P m₁ m₂\n"
"ha : P a₁ a₂\n"
"hb : P b₁ b₂\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`suffices h : P` führt ein neues Zwischenresultat ein, aus dem das Goal direkt folgen soll.\n"
"\n"
"## Details\n"
"\n"
"Der einzige Unterschied zu `have h : P` ist, dass die beiden resultierenden Goals vertauscht sind.\n"
"\n"
"Mathematisch braucht man diese in ein bisschen unterschiedlichen Fällen:\n"
"\n"
"* `suffices h : P` : \\\"Es genügt zu zeigen, dass …\\\". Als erstes folgt die Erklärung wieso\n"
"  das genügt, danach muss man nur noch `P` beweisen.\n"
"* `have h : P` : Ein (kleines) Zwischenresultat. Als erstes folgt dann der Beweis dieses\n"
"Resultats, anschliessend setzt man den Beweis mit Hilfe des Zwischenresultats fort."
msgstr ""

#: Game.Doc.Tactic
msgid "`symm` (für \"symmetry\") kann Gleichheiten oder `↔` umdrehen. `symm at h` dreht eine Gleichheit\n"
"(oder `↔`) in der Annahme `h`.\n"
"\n"
"## Details\n"
"\n"
"Man kann auch `h.symm` für die gedrehte Annahme schreiben, wenn man diese irgendwo\n"
"verwendet. Das verwendet intern die Lemmata\n"
"`Eq.symm` oder `Iff.symm`.\n"
"\n"
"## Beispiel\n"
"\n"
"ist das Goal `x = y`, dann wandelt es `symm` in `y = x` um. Analog, wandelt `symm at h` die Annahme\n"
"`(h : z = w)` in `(h : w = z)` um."
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn man `X = Z` zeigen möchte, kann man mit\n"
"`trans Y` einen Zwischenschritt `Y` einfügen.\n"
"Zu zeigen sind dann also `X = Y`  und `Y = Z`.\n"
"\n"
"## Details\n"
"`trans` ist besondern gut geeignet, um eine Gleichung `X = Z `\n"
"durch eine „Rechnung“ der Form `X = Y₁ = Y₂ = Y₃ … = Z` Schritt für Schritt nachzuweisen:\n"
"\n"
"* `trans Y₁`\n"
"* Beweis von `X = Y₁`\n"
"* `trans Y₂`\n"
"* Beweis von `Y₁ = Y₂`\n"
"* `trans Y₃`\n"
"* …\n"
"* Beweis von `… = Z`\n"
"\n"
"Genauso wie für Gleichungen `X = Z` funktioniert `trans` auch für Äquivalenzen `X ↔ Z` und gewisse\n"
"transitive Relationen im Beweisziel.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Objekte:\n"
"  A B C : Prop\n"
"Annahmen:\n"
"  h₁ : A ↔ B\n"
"  h₂ : B ↔ C\n"
"Goal:\n"
"  A ↔ C\n"
"```\n"
"\n"
"Die Taktik `trans B` erstellt dann aus dem Goal zwei neue `A ↔ B` und `B ↔ C`."
msgstr ""

#: Game.Doc.Tactic
msgid "`decide` kann Aussagen beweisen, für die es einen einfachen Algorithmus\n"
"gibt, der die Wahr- oder Falschheit der Aussage bestimmt.\n"
"\n"
"Wichtige Beispiele sind:\n"
"\n"
"* `True`\n"
"* Aussagen zu konkreten Zahlen, wie `Even 4`, `2 ≤ 5`, `4 ≠ 6`, …\n"
"\n"
"\n"
"## Details\n"
"\n"
"Konkret sucht `decide` für eine Aussage `P`  nach einer Instanz `Decidable P`\n"
"welche dann evaluiert entweder wahr oder falsch rausgibt.\n"
"\n"
"## Beispiel\n"
"\n"
"Folgendes kann mit `decide` gelöst werden:\n"
"\n"
"```\n"
"Goal:\n"
"  ¬ Odd 40\n"
"```"
msgstr ""

#: Game.Doc.Tactic
msgid "`unfold myDef` öffnet eine Definition im Goal.\n"
"\n"
"## Details\n"
"Bis auf DefEq (definitinal equality) ändert `unfold` nichts, manche Taktiken\n"
"(z.B. `push_neg`, `rw`) brauchen aber manchmal die Hilfe.\n"
"\n"
"`unfold myDef at h` kann auch Definitionen in Annahmen öffnen\n"
"\n"
"## Hilfreiche Resultate\n"
"\n"
"* `unfold f` kann insbesondere nötig sein, wenn man danach `rw` benützt,\n"
"  da `rw` nicht durch Definitionen hindurch sieht.\n"
"* `unfold f` oder `simp only [f]` machen praktisch das Gleiche.\n"
"* Im Moment kennt Mathlib auch noch `unfold_let`: `unfold` ist für Definitionen, `unfold_let`\n"
"  für `let`-Statements.\n"
"* `change _` ist eine andere Taktik (nicht im Spiel), die das aktuelle Goal in einen DefEq-Ausdruck\n"
"  umschreibt. Diese Taktik braucht man auch manchmal um zu hacken, wenn Lean Mühe hat etwas zu verstehen.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Goal:\n"
"  Even 0\n"
"```\n"
"\n"
"Auch wenn `rfl` dieses Goal lösen kann, kann es nützlich sein `unfold Even` zu benützen um die\n"
"Definition hinter `Even` zu sehen."
msgstr ""

#: Game.Doc.Tactic
msgid "Wenn das Goal von der Form `∃x, P x` ist, kann man mit `use n` ein konkretes Element angeben\n"
"mit dem man das Goal beweisen möchte.\n"
"\n"
"## Details\n"
"\n"
"`use n` versucht zudem anschliessend `rfl` aufzurufen, und kann das Goal damit manchmal direkt\n"
"schließen.\n"
"\n"
"## Beispiel\n"
"\n"
"```\n"
"Goal:\n"
"  ∃ x, x + 3 = 4\n"
"```\n"
"\n"
"hier würde man `use 1` benützen."
msgstr ""

#: Game.Doc.Tactic
msgid "`tauto` proves all logical tautologies.\n"
"\n"
"## Beispiel\n"
"\n"
"Folgendes Goal ist mit `tauto` lösbar\n"
"\n"
"```\n"
"Objekte:\n"
"  (A B C : Prop)\n"
"Goal:\n"
"  ¬((¬B ∨ ¬ C) ∨ (A → B)) → (¬A ∨ B) ∧ ¬ (B ∧ C)\n"
"```"
msgstr ""

#: Game.Doc.Theorem
msgid "Die Taktiken `tauto` oder `simp` können oft stattdessen verwendet werden."
msgstr ""

#: Game.Doc.Theorem
msgid "Oft kann `tauto` diese Art von logischen Ausdrücken lösen."
msgstr ""

#: Game.Levels.Logo.L01_Tauto
msgid ""
msgstr ""

#: Game.Levels.Logo.L01_Tauto
msgid "Gerade seid Ihr auf Königin *Logisindes* Planeten. Sie kommt ohne Umschweife zum Punkt:\n"
"\n"
"**Logisinde**: Werte Wesen aus fremden Welten, gestatten Sie eine Frage. Warum gilt …\n"
"\n"
"Und sie kritzelt etwas auf ein Stück Papier: oben ein paar Annahmen, unten eine Schlussfolgerung.\n"
"Dazwischen sollst du offenbar einen Beweis eintragen.\n"
"Du siehst Robo hilflos an."
msgstr ""

#: Game.Levels.Logo.L01_Tauto
msgid ""
msgstr ""

#: Game.Levels.Logo.L01_Tauto
msgid "**Robo**: Das ist ganz einfach. Mit `«{A}» «{B}» «{C}» : Prop` meint sie:\n"
"`«{A}»`, `«{B}»` und `«{C}»` sind irgendwelche Aussagen (*propositions*).\n"
"Und mit `→` meint sie ⇒, also “impliziert”. Die anderen Symbole kennst du, oder?\n"
"\n"
"**Du**: Ehhm, ja. Aber da muss ich jetzt trotzdem erst einmal überlegen.\n"
"\n"
"**Robo**: (flüsternd) Behaupte doch einfach, dass sei eine Tautologie.\n"
"\n"
"**Du**: Ernsthaft?\n"
"\n"
"**Robo**: Ja. Schreib einfach `tauto`.\n"
"\n"
"**Robo**: Mach schon …"
msgstr ""

#: Game.Levels.Logo.L01_Tauto
msgid "**Logisinde**: (etwas konsterniert) Ja, das ist streng genommen richtig.\n"
"Aber glaubt bloß nicht, dass Ihr damit auf *diesem* Planeten viel weiterkommt!\n"
"Meine Untertanen verstehen `tauto` nicht. Da müsst Ihr Euch schon etwas mehr anstrengen."
msgstr ""

#: Game.Levels.Logo.L02_Rfl
msgid ""
msgstr ""

#: Game.Levels.Logo.L02_Rfl
msgid "In der Zwischenzeit hat bereits sich eine lange Schlange Untertanen gebildet, die gern ihren\n"
"Fragen stellen würden. Logisinde winkt den ersten nach vorn. Er räuspert sich.\n"
"\n"
"**Untertan**: Warum ist $42 = 42$?\n"
"\n"
"Du schaust ihn fassungslos an.\n"
"Er schreibt es dir wieder auf."
msgstr ""

#: Game.Levels.Logo.L02_Rfl
msgid "**Robo**: Ist doch klar. Du musst ihn einfach daran erinnern,\n"
"dass Gleichheit *reflexiv* ist. Probier mal `rfl`."
msgstr ""

#: Game.Levels.Logo.L02_Rfl
msgid "**Untertan**: Ah, richtig. Ja, Sie haben ja so recht. Das vergesse ich immer. Rfl, rfl, rfl …"
msgstr ""

#: Game.Levels.Logo.L03_Assumption
msgid ""
msgstr ""

#: Game.Levels.Logo.L03_Assumption
msgid "Während der erste Untertan noch rfl, rfl, rfl murmelt, tritt schon der nächste nach vorne.\n"
"Es ist schüchtern und schreibt bloß."
msgstr ""

#: Game.Levels.Logo.L03_Assumption
msgid "**Robo**: `«{n}» : ℕ` bedeutet, `«{n}»` ist eine natürliche Zahl.\n"
"\n"
"**Du**: Warum schreibt er dann nicht `«{n}» ∈ ℕ`??\n"
"\n"
"**Robo**: Weil das hier alles komische Typen sind … Ich kann dir das später mal in Ruhe\n"
"erklären. Jetzt will ich erst einmal die Frage entschlüsseln.\n"
"\n"
"**Robo**: Also, `«{h₁}»`, `«{h₂}»`, `«{h₃}»` sind einfach nur Namen für verschiedene Annahmen,\n"
"und zwar für die Annahme `n < 10`, `1 < n` und `n ≠ 5`. Beweisen sollen wir: `1 < n`.\n"
"\n"
"**Du**: Aber das war doch gerade eine der Annahmen.\n"
"\n"
"**Robo**: Ja, stimmt.\n"
"\n"
"**Du**: ???\n"
"\n"
"**Robo**: Du musst ihm das halt explizit sagen. Probiers mal mit `assumption`."
msgstr ""

#: Game.Levels.Logo.L03_Assumption
msgid "**Untertan**: Ja richtig! Wenn Ihr nur wüsstet, was ich mir an dieser Frage schon den Kopf\n"
"zerbrochen habe!"
msgstr ""

#: Game.Levels.Logo.L04_Assumption
msgid ""
msgstr ""

#: Game.Levels.Logo.L04_Assumption
msgid "Ein dritter Untertan kommt mit folgendem Problem."
msgstr ""

#: Game.Levels.Logo.L04_Assumption
msgid "**Robo**: Hier bedeutet `«{A}» : Prop` wieder, dass `«{A}»` irgendeine Aussage ist.\n"
"Und `«{hA}»` ist eine Name für die Annahme, dass `«{A}»` wahr ist.\n"
"\n"
"**Du**: Und unter dieser Annahme sollen wir jetzt `«{A}»` beweisen?\n"
"\n"
"**Robo**: Ja. Da kommst du jetzt selbst drauf, wie das geht, oder?"
msgstr ""

#: Game.Levels.Logo.L04_Assumption
msgid "**Robo**: Ist doch genau wie eben:\n"
"die Aussage, die zu beweisen ist, gehört selbst zu den Annahmen.\n"
"Also wird `assumption` auch wieder funktionieren."
msgstr ""

#: Game.Levels.Logo.L04_Assumption
msgid "**Untertan**: Das ging ja schnell. Super! Vielen Dank."
msgstr ""

#: Game.Levels.Logo.L05_True
msgid ""
msgstr ""

#: Game.Levels.Logo.L05_True
msgid "Der nächste Untertan in der Reihe ist ein Schelm."
msgstr ""

#: Game.Levels.Logo.L05_True
msgid "**Robo**: Dieses `True` ist eine spezielle Aussage, nämlich die Aussage, die immer und\n"
"bedingungslos wahr ist.\n"
"\n"
"**Du**: Und was genau ist dann zu beweisen?\n"
"\n"
"**Robo**: Ich glaube, nichts. Probier mal `decide`."
msgstr ""

#: Game.Levels.Logo.L05_True
msgid "**Schelm**: Wollte nur mal sehen, dass Ihr nicht auf den Kopf gefallen seid …\n"
"\n"
"**Du** *(zu Robo)*: Können wir nicht einfach immer dieses `decide` verwenden?\n"
"\n"
"**Robo**: Nein, `decide` funktioniert nur in speziellen Situationen, in denen es einen\n"
"einfachen Algorithmus gibt, der entscheidet, ob die Aussage wahr ist."
msgstr ""

#: Game.Levels.Logo.L06_Not
msgid ""
msgstr ""

#: Game.Levels.Logo.L06_Not
msgid "Der Schelm hat noch eine Schwester dabei."
msgstr ""

#: Game.Levels.Logo.L06_Not
msgid "**Robo**: Dieses Zeichen `¬` bedeutet Negation. Also wenn eine Aussage `(A : Prop)`\n"
"wahr ist, dann ist `¬A` falsch, und umgekehrt.\n"
"\n"
"**Du**: Und `False` ist wahrscheinlich die Aussage, die immer falsch ist?\n"
"\n"
"**Robo**: Ja, richtig.\n"
"\n"
"**Du**: Ist das jetzt nicht doch wieder `decide`?\n"
"\n"
"**Robo**: Probier mal!"
msgstr ""

#: Game.Levels.Logo.L06_Not
msgid "Die Schwester lacht und eilt ihrem Bruder hinterher."
msgstr ""

#: Game.Levels.Logo.L07_Contradiction
msgid ""
msgstr ""

#: Game.Levels.Logo.L07_Contradiction
msgid "Als nächstes kommen drei Querulanten. Der erste hat folgendes Problem:"
msgstr ""

#: Game.Levels.Logo.L07_Contradiction
msgid "**Du** Wenn ich das jetzt richtig lese, ist `«{A}»` eine Aussage,\n"
"und wir haben außerdem eine Annahme names `«{h}»`, die besagt …\n"
"\n"
"**Robo**: … die besagt, dass `False` gilt.\n"
"\n"
"**Du**: Ich dachte, `False` gilt nie?\n"
"\n"
"**Robo**: Ja, genau. Die Annahme ist `False`, also falsch.\n"
"Und aus einer falschen Annahme kann man bekanntlich alles beweisen!\n"
"Insbesondere die gesuchte Aussage `«{A}»`.\n"
"\n"
"**Du**: Und wie erkläre ich das jetzt diesem Formalosophen?\n"
"\n"
"**Robo**: Ich glaube, du musst ihn darauf hinweisen, dass zwischen der allgemeingültigen\n"
"Annahme `True` und seiner Annahme `False` ein Widerspruch besteht. Probier mal `contradiction`."
msgstr ""

#: Game.Levels.Logo.L07_Contradiction
msgid "Der erste Querulant ist offenbar zufrieden.\n"
"\n"
"**Du**: War das jetzt ein Widerspruchsbeweis?\n"
"\n"
"**Robo**: Nein, nein, ein Widerspruchsbeweis sieht anders aus. Das Argument hier war:\n"
" wir haben eine `contradiction` in unserem Annahmen, also folgt jede beliebige Aussage."
msgstr ""

#: Game.Levels.Logo.L08_Contradiction
msgid ""
msgstr ""

#: Game.Levels.Logo.L08_Contradiction
msgid "Auftritt zweiter Querulant."
msgstr ""

#: Game.Levels.Logo.L08_Contradiction
msgid ""
msgstr ""

#: Game.Levels.Logo.L08_Contradiction
msgid "**Du** Ist `«{n}» ≠ «{n}»` nicht auch ein Widerspruch?\n"
"\n"
"**Robo**: Probiers mal!"
msgstr ""

#: Game.Levels.Logo.L08_Contradiction
msgid "**Du**: Ja, scheint funktioniert zu haben.\n"
"\n"
"**Du**: Aber irgendwie kommt mir das immer noch ein wenig suspekt vor.\n"
"Jetzt habe ich bewiesen, dass eine beliebige natürliche Zahl gleich 37 ist?\n"
"\n"
"**Robo**: Nein, nicht doch. Nur eine beliebige Zahl, die ungleich sich selbst ist, ist gleich 37.\n"
"Und gleich 38, und gleich 39, …\n"
"\n"
"**Du**: Okay, okay, verstehe."
msgstr ""

#: Game.Levels.Logo.L09_Contradiction
msgid ""
msgstr ""

#: Game.Levels.Logo.L09_Contradiction
msgid "Auftritt dritter Querulant."
msgstr ""

#: Game.Levels.Logo.L09_Contradiction
msgid ""
msgstr ""

#: Game.Levels.Logo.L09_Contradiction
msgid "**Du** Wieder ein Widerspruch in den Annahmen?\n"
"\n"
"**Robo**: Ich sehe, du hast langsam den Dreh raus."
msgstr ""

#: Game.Levels.Logo.L09_Contradiction
msgid "**Robo**: Gut gemacht. Bei dieser Frage ist auch ein bisschen offensichtlicher,\n"
"worin der Widerspruch besteht: Die Annahme `n ≠ 10` ist genau die Negation von `n = 10`.\n"
"Man muss `≠` immer als `¬(· = ·)` lesen."
msgstr ""

#: Game.Levels.Logo.L10_And
msgid ""
msgstr ""

#: Game.Levels.Logo.L10_And
msgid "Der nächste Formalosoph in der Reihe hat seine Frage bereits mitgebracht.\n"
"Er legt sie uns vor, setzt sich hin und häkelt."
msgstr ""

#: Game.Levels.Logo.L10_And
msgid ""
msgstr ""

#: Game.Levels.Logo.L10_And
msgid "**Du**: Also, wir haben zwei Annahmen: `«{A}»` gilt, und `«{B}»` gilt auch. Und beweisen sollen wir\n"
"dass `«{A}» und «{B}»` gilt. Ich glaube, diese Formalospinner treiben mich noch zur Verzweiflung.\n"
"Kann ich nicht wieder `trivial` sagen?\n"
"\n"
"**Robo**: Nee, diesmal wird das nicht funktionieren.\n"
"Du musst das Beweisziel einfach in zwei Teile zerlegen. Probier mal `constructor`.\n"
"\n"
"**Du**: Du meinst, `destructor`??\n"
"\n"
"**Robo**: Nein, `constructor`. Ich weiß, das ist verwirrend,\n"
"aber die nennen das hier so weil man die Aussage aus mehreren Teilen\n"
"konstruieren kann."
msgstr ""

#: Game.Levels.Logo.L10_And
msgid "**Robo**: Schau mal, das ist Zauberpapier.\n"
"Jetzt haben wir auf einmal zwei Beweisziele.\n"
"Hier ist dast Ziel `«{B}»`.\n"
"Ich glaube, du weißt schon, wie man die jeweils erreicht.\n"
"Die Ziele stehen ja jeweils in den *Annahmen*."
msgstr ""

#: Game.Levels.Logo.L10_And
msgid "**Robo**: Super!\n"
"\n"
"Ihm scheinen diese Fragen inzwischen Spaß zu machen.\n"
"\n"
"**Robo**: Meinst du, dieser Hebel, an dem \"Editor mode\" steht, ist echt?\n"
"Oder ist der nur gemalt? Probier mal!"
msgstr ""

#: Game.Levels.Logo.L11_And
msgid ""
msgstr ""

#: Game.Levels.Logo.L11_And
msgid "Langsam wird die Schlange kürzer. Die nächste Formalosophin, ebenfalls häkelnd, hat folgendes Anliegen."
msgstr ""

#: Game.Levels.Logo.L11_And
msgid "**Du**: Jetzt müssen wir wohl die Annahme de-konstruieren.\n"
"\n"
"**Robo**: Ja, genau. Das geht am einfachsten mit `obtain ⟨h₁, h₂⟩ := «{h}»`.\n"
"\n"
"**Du**: Moment, wie schreib ich *das* denn hier auf?\n"
"\n"
"**Robo**: Die bleiden Klammern schreibst du als `\\<` und `\\>`, oder gleichzeitig als `\\<>`.\n"
"Und h₁ schreibst du einfach als `h\\1`. Aber du kannst dir auch einfach andere Namen\n"
"für `h₁` und `h₂`, zum Beispiel `obtain ⟨hA, hBC⟩ := «{h}»`."
msgstr ""

#: Game.Levels.Logo.L11_And
msgid "**Robo**: Das sieht doch schon besser aus! Gleich nochmal!"
msgstr ""

#: Game.Levels.Logo.L11_And
msgid "**Robo**: Du hast einen Beweis dafür in den *Annahmen*."
msgstr ""

#: Game.Levels.Logo.L11_And
msgid "**Robo**: Du hättest das übrigens auch direkt verschachtelt schreiben können:\n"
"`obtain ⟨h₁, h₂ , h₃⟩ := {h}`."
msgstr ""

#: Game.Levels.Logo.L12_Or
msgid ""
msgstr ""

#: Game.Levels.Logo.L12_Or
msgid "Der nächste bitte …"
msgstr ""

#: Game.Levels.Logo.L12_Or
msgid "**Du** Muss ich jetzt wieder das Beweisziel de-konstruieren?\n"
"\n"
"**Robo** Nein, viel einfacher. Wenn du eine Oder-Aussage beweisen sollst, musst du dich\n"
"einfach entscheiden, ob du die linke oder rechte Seite beweisen willst.\n"
"\n"
"**Du** Und wie erkläre ich meinem Formalosophen, welche Seite ich gern beweisen würde?\n"
"Ich will natürlich `«{A}»` beweisen!\n"
"\n"
"**Robo** Mit `left` bzw. `right`. Ist doch logisch, oder?"
msgstr ""

#: Game.Levels.Logo.L12_Or
msgid "**Robo** Wusste gar nicht, dass du eine Links-Rechts-Schwäche hast. Probier's nochmal."
msgstr ""

#: Game.Levels.Logo.L12_Or
msgid "Auch dieser Formalosoph zieht zufrieden von dannen."
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid ""
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "Der nächste bitte …"
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid ""
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "**Robo** Schau mal, wenn du mit dem Finger eine Annahme berührst, zeigt es dir,\n"
"wie die Klammern gesetzt sind. Irre…\n"
"\n"
"**Du** Ah ich sehe, also `(«{A}» ∧ «{B}») ∨ «{A}»`!\n"
"\n"
"**Du** Ich glaube den ganzen Zircus hier langsam nicht mehr:\n"
"Zuerst ein \"Und\" im Ziel, dann \"Und\" in der Annahme, dann \"Oder\" im Ziel und jetzt\n"
"\"Oder\" in der Annahme, die haben sich doch abgesprochen!\n"
"\n"
"**Robo** Lass ihnen doch ihren Spaß.\n"
"Wir sind ja gleich hier fertig, und können zu einem interessanteren Planeten weiterfliegen.\n"
"\n"
"**Du** Also, wieder `obtain …`?\n"
"\n"
"**Robo** Ja, aber diesmal nicht `obtain ⟨h₁, h₂⟩ := «{h}»`, sondern `obtain h | h := «{h}»`."
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "**Robo**\n"
"Jetzt musst du dein Ziel zweimal beweisen:\n"
"Einmal unter Annahme der linken Seite `«{A}» ∧ «{B}»`,\n"
"und einmal unter Annahme der rechten Seite `«{A}»`.\n"
"Hier haben nehmen wir an, die linke Seite\n"
"sei wahr."
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "**Robo** Wie man mit einem Und in den Annahmen umgeht,\n"
"weißt du doch schon:\n"
"`obtain ⟨h₁, h₂⟩ := «{h}»`. Zur Erinnerung: Für die Klammern schreibst du `\\<>`."
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "**Robo** Jetzt musst du dein Ziel noch unter der rechten Annahme\n"
"von `(«{A}» ∧ «{B}») ∨ «{A}»` zeigen, also angenommen, `«{A}»` sei wahr."
msgstr ""

#: Game.Levels.Logo.L13_Or
msgid "**Du** Okay, das scheint ihn zufriedenzustellen. Nur noch eine Seele…\n"
"Kannst du mir vorher noch einmal kurz alles Leansch zusammenfassen,\n"
"das du mir bis hierher beigebracht hast?\n"
"\n"
"Robo strahlt überglücklich. Noch *nie* warst du so auf ihn angewiesen.\n"
"\n"
"**Robo** Na klar, schau her!\n"
"\n"
"## Notationen / Begriffe\n"
"\n"
"|               | Beschreibung                                                             |\n"
"|:--------------|:-------------------------------------------------------------------------|\n"
"| *Goal*        | Was aktuell zu beweisen ist.                                             |\n"
"| *Annahme*     | Objekte & Resultate, die man zur Verfügung hat.                          |\n"
"| *Taktik*      | Befehl im Beweis. Entspricht einem Beweisschritt.                        |\n"
"| `ℕ`           | Typ aller natürlichen Zahlen.                                            |\n"
"| `0, 1, 2, …`  | Explizite natürliche Zahlen.                                             |\n"
"| `=`           | Gleichheit.                                                              |\n"
"| `≠`           | Ungleichheit. Abkürzung für `¬(·=·)`.                                    |\n"
"| `Prop`        | Typ aller logischen Aussagen.                                            |\n"
"| `True`        | Die logische Aussage `(True : Prop)` ist bedingungslos wahr.             |\n"
"| `False`       | Die logische Aussage `(False : Prop)` ist bedingungslos falsch.          |\n"
"| `¬`           | Logische Negierung.                                                      |\n"
"| `∧`           | Logisch UND.                                                             |\n"
"| `∨`           | Logisch ODER.                                                            |\n"
"| `(n : ℕ)`     | Eine natürliche Zahl.                                                    |\n"
"| `(A : Prop)`  | Eine logische Aussage.                                                   |\n"
"| `(ha : A)`    | Ein Beweis, dass die logische Aussage `(A : Prop)` wahr ist.             |\n"
"| `(h : A ∧ B)` | Eine Annahme, die den Namen `h` bekommen hat.                            |\n"
"\n"
"\n"
"## Taktiken\n"
"\n"
"Die Worte, die du aktiv gebrauchen musst, heißen zusammengefasst `Taktiken`.\n"
"Hier sind alle Taktiken, die wir auf diesem Planeten gebraucht haben:\n"
"\n"
"|    | Taktik                    | Beispiel                                           |\n"
"|:---|:--------------------------|:---------------------------------------------------|\n"
"| 1  | `rfl`                     | Beweist `A = A`.                                   |\n"
"| 2  | `assumption`              | Sucht das Goal in den Annahmen.                    |\n"
"| 3  | `contradiction`           | Sucht einen Widerspruch.                           |\n"
"| 4  | `decide`                  | Versucht zu entscheiden, ob eine Aussage wahr ist. |\n"
"| 5  | `constructor`             | Teilt ein UND im Goal auf.                         |\n"
"| 6  | `left`/`right`            | Beweist eine Seite eines ODER im Goal.             |\n"
"| 7ᵃ | `obtain ⟨h₁, h₂⟩ := h`    | Teilt ein UND in den Annahmen auf.                 |\n"
"| 7ᵇ | `obtain h := h \\| h`     | Teilt ein ODER in den Annahmen in zwei Fälle auf.  |\n"
"\n"
"**Du** Woher weißt du das eigentlich alles?\n"
"\n"
"**Robo** Keine Ahnung. War, glaube ich, vorinstalliert."
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid ""
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "Der letzte Untertan tritt vor. Ihr Anliegen ist etwas komplizierter als die vorherigen.\n"
"\n"
"**Robo** Wirf einfach alles drauf, was du gelernt hast.\n"
"Hier, ich bin sogar so nett und zeig dir noch einmal die vier\n"
"wichtigsten Taktiken für diese Situation an.\n"
"\n"
"| (Übersicht) | Und (`∧`)                | Oder (`∨`)              |\n"
"|:------------|:-------------------------|:------------------------|\n"
"| Annahme     | `obtain ⟨h₁, h₂⟩ := h`   | `obtain h \\| h := h`   |\n"
"| Goal        | `constructor`            | `left`/`right`          |"
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "**Robo**: Ich würd zuerst die Annahme «{h}» mit `obtain ⟨⟩ := «{h}»` aufteilen."
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "**Robo**: Jetzt kannst du das `∧` im Goal mit `constructor` angehen."
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "**Robo**: Hier würde ich die Annahme «{h}» nochmals mit `obtain` aufteilen."
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "**Robo**: Der Nachteil an der Reihenfolge ist, dass du jetzt in jedem Untergoal\n"
"`obtain ⟨⟩ := h` aufrufen musst."
msgstr ""

#: Game.Levels.Logo.L14_Summary
msgid "**Robo** Bravo! Jetzt aber nichts wie weg hier, bevor sich eine neue Schlange bildet!\n"
"\n"
"Königin *Logisinde* ist in der Zwischenzeit eingeschlafen, und ihr stehlt euch heimlich davon."
msgstr ""

#: Game.Levels.Logo
msgid "Logo"
msgstr ""

#: Game.Levels.Logo
msgid "Durch eine unvorhergesehene und nicht-kanonische Singularität in der Raumzeit\n"
"bist du aus Versehen in ein Paralleluniversum gestolpert. Wie es aussieht, gibt es kein zurück.\n"
"Richte dich besser darauf ein, hier bleiben und dich zurechtzufinden zu müssen.\n"
"\n"
"Wie es aussieht, gibt es hier viele nette kleine Planeten. Alle bewohnbar, und bis zu\n"
"sieben Sonnenuntergänge täglich inklusive. Nur werden sie allesamt von Formalosophen bewohnt,\n"
"seltsamen Wesen mit ausgefallenen mathematischen Obsessionen. Und dummerweise hat sich\n"
"herumgesprochen, dass du in deinem früheren Universum Mathematiker warst. du wirst hier\n"
"keine Ruhe finden, solange du nicht lernst, ihren unablässigen Wissensdurst zu stillen.\n"
"\n"
"Es gibt nur zwei Schwierigkeiten: Erstens haben die Formalosophen allem Anschein nach\n"
"überhaupt kein tieferes mathematisches Verständnis, und zweitens kommunizieren Sie über Mathematik\n"
"exklusiv in einem dir fremden Dialekt, den sie Leansch [liːnʃ] nennen.\n"
"\n"
"Zum Glück hat Robo mit dir das Universum gewechselt.\n"
"Robo, das ist dein kleiner SmartElf. Robo ist zwar auch nicht die mathematische Leuchte, die du Dir\n"
"in dieser Situation gewünscht hättest, aber es scheint, er hat irgendwo Leansch gelernt.\n"
"Und das ist Gold wert."
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid ""
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**Operationsleiter**: Hier, zum Beispiel:"
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**Operationsleiter**: Die Arbeiten meinen, das wäre so richtig und wir würden das dringend\n"
"brauchen. Aber keiner kann es mir beweisen.\n"
"\n"
"**Du**: Einen Moment. Das ist ja gerade so eine Implikation (`\\to`). Wir nehmen an,\n"
"dass `«{B}»` gilt, und wollen zeigen, dass dann gilt `«{A}»` impliziert `«{A}» und «{B}»`. Ja,\n"
"klar! Natürlich stimmt das.\n"
"\n"
"Der Operationsleiter sieht dich erwartungsvoll an.\n"
"\n"
"**Du** *(leise zu Robo)*: Soll ich ihm `tauto` aufschreiben?\n"
"\n"
"**Robo** *(leise zurück)*: So wie der aussieht, fürchte ich, das wird er auch nicht verstehen.\n"
"Schreib den Beweis lieber aus.\n"
"\n"
"**Du**: Aber wie denn? Ich glaube, ich würde als erstes gern so etwas sagen wie 'Nehmen wir\n"
"also an, `«{A}»` gilt …'\n"
"\n"
"**Robo**: Ja, gute Idee. Wähle dazu für deine Annahme einfach einen Namen, zum Beispiel `h`,\n"
"und schreib `intro h`."
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**Du**: Okay. Jetzt habe ich also sowohl `«{A}»` als auch `«{B}»` in meinen Annahmen und\n"
"muss `«{A}» ∧ «{B}»` zeigen.\n"
"\n"
"**Robo**: Genau. Und wie das geht, weißt du ja schon."
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "**Operationsleiter**: Perfekt! Danke schön!\n"
"\n"
"Er geht zu einer Schalttafel und ein paar Knöpfe. Irgendwo setzt sich lautstark ein\n"
"Förderband in Bewegung.\n"
"\n"
"**Operationsleiter**: Habt Ihr vielleicht noch ein paar Minuten?"
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid ""
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "Der Operationsleiter holt aus einem Container einen Stapel Papier hervor.\n"
"\n"
"**Operationsleiter**: Hier hat sich echt einiges angesammelt. Wäre echt super, wenn Ihr mir\n"
"noch ein bisschen helfen könntet.\n"
"\n"
"Er übergibt Euch das oberste Blatt."
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "**Operationsleiter**: Das ist von einem Kollegen.\n"
"\n"
"**Robo**: Oh, das hab ich schon einmal irgendwo gelesen. Warte mal … Richtig! Das war\n"
"damals, als ich Wikipedia gecrawlt habe: `Der Modus ponens ist eine schon in der antiken\n"
"Logik geläufige Schlussfigur, die in vielen logischen …`\n"
"\n"
"**Du**: Robo! Gefragt ist ein Beweis und kein historischer Aufsatz! Oder komme ich hier\n"
"etwa mit `mopo` oder so etwas weiter?\n"
"\n"
"**Robo**: Okay, nein, sorry. `mopo` gibt es nicht. Probier lieber `revert «{hA}»`."
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "**Du**: Aha. `revert` ist quasi `intro` rückwärts.\n"
"\n"
"**Robo**: Genau. `intro` nimmt die Prämisse aus einer Implikation `«{A}» \\to «{B}»` im\n"
"Beweisziel und macht daraus eine Annahme. `revert` nimmt umgekehrt eine Annahme und\n"
"setzt sie als Implikationsprämisse vor das Beweisziel. Aber nun mach schon fertig."
msgstr ""

#: Game.Levels.Implis.L02_Revert
msgid "Der Operationsleiter nimmt erfreut Eure Lösung entgegen, und greift zum Telefon."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid ""
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "Leider läuft das Telefonat nicht so gut. Er legt wieder auf und schüttelt mit dem Kopf.\n"
"\n"
"**Operationsleiter**: Der Kollege auf der anderen Seite des Mondes versteht kein `revert`. Oder\n"
"er tut zumindest so. Habt Ihr noch eine andere Idee?\n"
"\n"
"Er zieht eine Linie unter Euren Beweis, ergänzt ein durchgestrichenes ~`revert`~, und legt Euch\n"
"das Blatt ein zweites Mal vor."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "**Robo**: Vielleicht wäre es ohnehin eleganter gewesen, die gegebene Implikation anzuwenden.\n"
"Probier doch mal `apply hAB at h`."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "**Robo**: Ich sagte `… at h`. Aber einfach nur `apply hAB` funktioniert offenbar auch.\n"
"Jetzt hast Du sozusagen `hAB` auf das Beweisziel `B` angewendet, und musst nur\n"
"noch `A` beweisen."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "**Du**: Ja, das kommt mir jetzt auch natürlich vor."
msgstr ""

#: Game.Levels.Implis.L03_Apply
msgid "Diesmal scheint das Telefonat erfolgreich zu verlaufen."
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid ""
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**Operationsleiter**: Das hier ist jetzt wieder ein lokales Problem."
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**Du**: Ich soll Implikationen $A \\Rightarrow B \\Rightarrow C$ zu $A \\Rightarrow C$\n"
"kombinieren?\n"
"\n"
"**Robo**: Vielleicht fängst du wieder mit `intro` an?"
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**Robo**: Das ist wieder eine Anwendung von `apply`."
msgstr ""

#: Game.Levels.Implis.L04_Apply
msgid "**Operationsleiter**: Ihr seid echt super!"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid ""
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "Die nächste Seite sieht ein bisschen komplizierter aus. Damit Ihr nicht die Übersicht verliert, fasst Robo sofort die verschiedenen Implikationen in einem Diagramm zusammen.\n"
"  $$\n"
"  \\begin{CD}\n"
"       A  @>{f}>> B @<{g}<< C    \\\\\n"
"    @V{h}VV    @V{i}VV   @V{j}VV \\\\\n"
"       D  @<{k}<< E @>{l}>> F    \\\\\n"
"    @A{m}AA    @A{n}AA   @V{p}VV \\\\\n"
"       G  @<{q}<< H @>{r}>> I\n"
"  \\end{CD}\n"
"  $$"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Du**: Also ich muss einen Pfad von Implikationen $A \\Rightarrow I$ finden.\n"
"\n"
"**Robo**: Lass mich mal raten, wie wir anfangen … Wieder `intro`?"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Na wieder `apply`, was sonst."
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Das sieht nach einer Sackgasse aus …"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Das sieht nicht gut aus."
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Nah, da stimmt doch was nicht …"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Halt! Falsch abgebogen."
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Bist du dir sicher?"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "**Robo**: Ehm …"
msgstr ""

#: Game.Levels.Implis.L05_Apply
msgid "Der Operationsleiter bedankt sich wieder artig. Er drückt wieder auf ein paar Knöpfe,\n"
"und mit einem lauten Ratteln springen mehrere Förderbänder gleichzeitig wieder an."
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid ""
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**Operationsleiter**: Wir hatten auch mal ein paar Förderbänder, die in beide Richtungen laufen\n"
"konnten. Die hatte ich vorsichtshalber alle abgestellt, weil in den neusten Handbüchern von\n"
"solchen Doppelbändern abgeraten wird. Aber vielleicht sind sie ja unter bestimmten\n"
"Voraussetzungen doch sicher? Was meint Ihr zu diesem Fall?"
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**Robo**: `A ↔ B` ist natürlich Leansch für $A \\iff B$, also genau-dann-wenn.\n"
"Die Aussage `A ↔ B` besteht also aus zwei Teilen; sie ist als `⟨A → B, B → A⟩` definiert.\n"
"\n"
"**Du**: Also ganz ähnlich wie das UND, `A ∧ B`?\n"
"\n"
"**Robo**: Genau. Entsprechend kannst du auch hier mit `constructor` anfangen."
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**Du**: Ah, und die beiden Teile habe ich schon in den Annahmen."
msgstr ""

#: Game.Levels.Implis.L06_Iff
msgid "**Operationsleiter**: Okay, das leuchtet mir ein.\n"
"\n"
"**Robo** *(zu dir)*: Übrigens, so wie bei `(h : A ∧ B)` die beiden\n"
"Teile `h.left` und `h.right` heißen,\n"
"heißen bei `(h : A ↔ B)` die beiden Teile `h.mp` und `h.mpr`.\n"
"\n"
"**Du**: Also `h.mp` ist `A → B`? Wieso `mp`?\n"
"\n"
"**Robo**: `mp` steht für Modus Ponens. Der Modus ponens ist eine schon in der antiken\n"
"Logik geläufige Schlussfigur, die in vielen logischen Systemen … Ach nee, das wolltest\n"
"du ja nicht hören. Das \"r\" in `mpr` steht für \"reverse\", weil's die Rückrichtung ist."
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid ""
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid "**Operationsleiter**: Hier ist noch so etwas."
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid "**Du**: Das ist ja nur verdreht.\n"
"\n"
"**Robo**: Ich kenne ein Werkzeug dafür. Mit `symm` oder `symm at «{h}»` kannst du eines\n"
"der beiden umdrehen."
msgstr ""

#: Game.Levels.Implis.L07_Symm
msgid "**Operationsleiter**: Das war ja symmpel. Das nächste Problem sieht aber schwieriger aus."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid ""
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**Operationsleiter**: Hier, könnt ihr dazu auch was sagen?"
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**Du**: $B \\iff A \\iff D \\iff C$, die sind doch alle äquivalent…\n"
"\n"
"**Robo**: Ja, aber du musst ihm helfen, die Äquivalenzen umzuschreiben. Mit `rw [h₁]` kannst\n"
"du `C` durch `D` ersetzen."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**Du** Und wenn ich in die andere Richtung umschreiben möchte?\n"
"\n"
"**Robo**: Dann schreibst du ein `←` (`\\l`, also klein \"L\") vor den Namen, also `rw [← hₓ]`."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**Du**: Ehm, das war verkehrt.\n"
"\n"
"**Robo**: Ja, anders herum wär's besser gewesen. Aber wenn du jetzt einfach weitermachst,\n"
"bis Du sowas wie `A ↔ A` erhältst, kann `rfl` das beweisen.\n"
"\n"
"**Robo: Da fällt mir ein, `rw` wendet ohnehin auch versuchsweise `rfl` an.\n"
"Das heißt, du musst `rfl` nicht einmal ausschreiben."
msgstr ""

#: Game.Levels.Implis.L08_Rw
msgid "**Operationsleiter**: Wenn Ihr so weitermacht, dann kommen wir ja durch den ganzen Packen durch!"
msgstr ""

#: Game.Levels.Implis.L09_Trans
msgid ""
msgstr ""

#: Game.Levels.Implis.L09_Trans
msgid "**Du**: Irgendwie fühlen sich diese `rw` an, als würde man von hinten durch den Bauch argumentieren.  Geht das nicht auch irgendwie geradeaus, oder denken alle hier um die Ecke?\n"
"\n"
"**Robo**:  Vielleicht würde dir `trans` besser gefallen.  Damit könntest du deine Kette von Äquivalenzen  $B \\iff A \\iff D \\iff C$ Schritt für Schritt abarbeiten: als erstes führst Du mit `trans A` den Zwischenschritt `B \\iff A` ein, dann mit `trans D` den nächsten Zwischenschritt."
msgstr ""

#: Game.Levels.Implis.L09_Trans
msgid "**Robo**: Und, war das besser?\n"
"\n"
"**Du**:  Weiß nicht.  Wir können jedenfalls weitermachen."
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid ""
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Operationsleiter**: Das hier ist wieder für meinen beschränkten Kollegen. Ich glaube,\n"
"`rw` mag der auch nicht. Geht das trotzdem?"
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Du**: Naja ich kann wohl immerhin mal mit `intro` anfangen …\n"
"\n"
"**Robo**: … und dann schauen wir weiter!"
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Robo**: Also eine Implikation wendet man mit `apply` an …\n"
"\n"
"**Du**: Weiß ich doch! Aber `«{h}»` ist keine Implikation, sondern eine Äquivalenz.\n"
"Da würde ich doch eigentlich `rw [← «{h}»]` sagen wollen.\n"
"\n"
"**Robo**: Die Richtung `«{A}» → «{B}»` von `«{h}»` heißt `«{h}».mp`. Du kannst sie\n"
"mit `apply («{h}».mp) at …` anwenden."
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Robo**: So kannst Du natürlich auch anfangen."
msgstr ""

#: Game.Levels.Implis.L10_Iff
msgid "**Operationsleiter**: Okay, super. Das müsste passen.\n"
"\n"
"Er telefoniert wieder.\n"
"\n"
"**Operationsleiter**: Bingo!"
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid ""
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Operationsleiter**: Ah, die nächste Seite ist auch von diesem Kollegen.\n"
"Aber da ist noch eine Notiz bei. Wir hatten hierfür schon einmal einen Beweis,\n"
"aber den mochte er nicht. Er wollte einen Beweis, der weder `rw` noch `apply` verwendet!!\n"
"\n"
"Er holt tief Luft und seuft.\n"
"\n"
"**Operationsleiter**: Ich glaube, der stellt sich immer viel dümmer, als er ist.\n"
"Aber meint Ihr, Ihr schafft das?"
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Du**: Hmm, mindestens mit der Implikation kann ich anfangen."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Robo**: Genau, das war `intro`."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Du**: Also, ich kenne `rw [«{h}»]` und `apply («{h}».mp)`, aber das wollten wir ja\n"
"diesmal vermeiden.\n"
"\n"
"**Robo**: Was du machen könntest, ist, mit `obtain ⟨mp, mpr⟩ := «{h}»` die Annahme\n"
"in zwei Teile aufteilen."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Robo**: Hier müsstest du jetzt `rw [←«{h}»]` oder `apply «{h}».mp` benutzen.\n"
"Geh lieber einen Schritt zurück, sodass das Goal `A → B` ist."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Du**: Ah, und jetzt ist das Beweisziel in den Annahmen."
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "**Operationsleiter**: Perfekt, das sollte reichen!"
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid ""
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "Beim nächsten Problem stutzt der Operationsleiter.\n"
"\n"
"**Operationsleiter**: Ehrlich gesagt weiß ich gar nicht, wo dieses Blatt herkommt. Das ist\n"
"gar nicht von mir. Sieht aber irgendwie interessant aus."
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "**Du**: Naja, eine der beiden Aussagen `A` oder `¬A` wird schon wahr sein.\n"
"\n"
"**Robo**: Klarer Fall für eine Fallunterscheidung, würde ich sagen. Probier\n"
"mal `by_cases h : A`."
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "**Robo**: Siehst du, jetzt hat der Beweis zwei Teile. Im ersten Teil nimmst\n"
"du an, dass `A` wahr ist. Im zweiten nimmst du an, dass `A` falsch ist."
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "Der Operationsleiter nickt zustimmend."
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid ""
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**Operationsleiter**: Wieder etwas für den Kollegen …. Und er wollte wieder einen\n"
"Beweise ohne `apply`. Ich sehe hier auch, dass ich mir schon einmal etwas\n"
"hierzu notiert hatte. Richtig, es gibt da dieses Lemma:\n"
"```\n"
"lemma not_not (A : Prop) : ¬¬A ↔ A\n"
"```\n"
"\n"
"**Operationsleiter**: Schafft Ihr das damit?"
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**Robo**: Ein Lemma, das wie `not_not` ein `↔` oder `=` im Statement hat, kann\n"
"auch mit `rw [not_not]` verwendet werden."
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**Du**: Häh, wieso hat das jetzt 2 von 3 der `¬¬` umgeschrieben?\n"
"\n"
"**Robo**: `rw` schreibt nur das erste um, das es findet, also `¬¬C`. Aber weil dieses\n"
"mehrmals vorkommt, werden die alle ersetzt …\n"
"\n"
"**Du**: Ah, und `¬¬B` ist etwas anderes, also brauche ich das Lemma nochmals."
msgstr ""

#: Game.Levels.Implis.L13_Rw
msgid "**Du**: Wir sind schon fertig …?\n"
"\n"
"**Robo**: Ja, `rw` versucht immer anschließend `rfl` aufzurufen, und das hat hier funktioniert."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid ""
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Operationsleiter**: Ihr habt mir wirklich so geholfen! Hier ist das letzte Problem.\n"
"Das habe ich von meinem Vorgänger geerbt. Er hat behauptet, wenn wir das lösen können,\n"
"dann läuft hier wieder alles. Aber es sah mir immer viel zu schwierig aus, um es überhaupt\n"
"zu versuchen. Wollt Ihr es einmal probieren?\n"
"\n"
"**Du**: Klar, zeig her! Robo, kannst du mir vielleicht auch noch einmal so eine nette\n"
"Zusammenfassung anzeigen, was ich theoretisch in den letzten fünf Minuten gelernt habe?\n"
"\n"
"**Robo**: Hier ist die Übersicht:\n"
"\n"
"## Notationen / Begriffe\n"
"\n"
"|               | Beschreibung                                             |\n"
"|:--------------|:---------------------------------------------------------|\n"
"| →             | Eine Implikation.                                        |\n"
"| ↔             | Genau-dann-wenn / Äquivalenz.                            |\n"
"\n"
"## Taktiken\n"
"\n"
"|     | Taktik                    | Beispiel                                                   |\n"
"|:----|:--------------------------|:-----------------------------------------------------------|\n"
"| 8   | `intro`                   | Für eine Implikation im Goal.                              |\n"
"| 9   | `revert`                  | Umkehrung von `intro`.                                     |\n"
"| 10  | `apply`                   | Wendet Implikation/Theorem (rückwärts) auf das Goal an.    |\n"
"| 10ᵇ | `apply at`                | Wendet Implikation/Theorem (forwärts) auf eine Annahme an. |\n"
"| 11  | `symm`                    | Tauscht `A ↔ B` zu `B ↔ A`.                                |\n"
"| 12  | `trans`                   | Ändert `A ↔ C` zu `A ↔ B` und `B ↔ C`                      |\n"
"| 13  | `rw`                      | Umschreiben zweier äquivalenter Aussagen.                  |\n"
"| 13ᵇ | `rw`                      | Benutzt ein Lemma, dessen Aussage eine Äquivalenz ist.     |\n"
"| 14  | `by_cases`                | Fallunterscheidung `P` und `¬P`                            |"
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Du** *(flüsternd)*: Ist das nicht die Definition von `→`?\n"
"\n"
"**Robo** *(flüsternd)*: Könnte man so sehen. Aber auf Leansch ist das bloß eine Äquivalenz."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Robo**: Vielleicht kannst du wieder `by_cases` benutzen."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Robo**: Na Implikationen gehst du immer mit `intro` an."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Robo**: Ich würde mal die Annahme `h` mit `obtain` aufteilen."
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid ""
msgstr ""

#: Game.Levels.Implis.L14_Summary
msgid "**Operationsleiter**: Das ist ja fantastisch! Tausend Dank! Dann will ich Euch auch gar\n"
"nicht länger aufhalten.\n"
"Ihr wollt bestimmt weiter zum Planeten Quantus, oder?\n"
"\n"
"**Du**: Ehm, vielleicht …\n"
"\n"
"**Operationsleiter**: Dann habe ich noch eine letzte Bitte. Ich habe hier noch ein Päckchen\n"
"für die Königin von Quantus! Auch schon von meinem Vorgänger geerbt. Die Post will es\n"
"nicht annehmen, weil ich die Adresse nicht weiß. Könntet Ihr es vielleicht zu ihr mitnehmen?\n"
"\n"
"**Du**: Klar! Robo, halt mal.\n"
"\n"
"Robo nimmt das Päckchen und lässt es irgendwo in seinem Innern verschwinden.\n"
"Der Operationsleiter sieht ihn entgeistert an.\n"
"\n"
"**Robo**: Keine Angst, ich verdaue nichts!"
msgstr ""

#: Game.Levels.Implis
msgid "Implis"
msgstr ""

#: Game.Levels.Implis
msgid "Zurück im Raumschiff macht ihr euch auf den Weg zu einem benachbarten Planeten, der ebenfalls\n"
"bewohnt zu sein scheinen.\n"
"\n"
"**Du**: Ich habe immer noch das Gefühl, dass ich die Aufgabe von Königin *Logisinde*\n"
"ohne `tauto` nicht hätte lösen können.\n"
"Kamen in der Aufgabe nicht auch Implikationen vor?\n"
"\n"
"**Robo**: Vielleicht haben wir ja auf dem Planeten *Implis*, den wir gerade ansteuern,\n"
"Gelegenheit, noch etwas dazuzulernen. Festhalten bitte …\n"
"\n"
"Und damit leitet Robo den Landeanflug ein.\n"
"\n"
"Implis scheint ein riesiger Tagebau zu sein.\n"
"Überall verlaufen Förderbänder, kreuz und quer, aber die meisten stehen still.\n"
"Ein schüchterner Operationsleiter erwartet Euch bereits.\n"
"\n"
"**Operationsleiter**: Ihr kommt mir gerade recht! Ich habe schon gehört. Echte Mathematiker!\n"
"Wisst Ihr, wir fördern hier Wahrheitswerte. Und dabei muss man höllisch aufpassen.\n"
"Ein Fehler, und alles bricht zusammen. Aber ich bin sehr vorsichtig. Ich sage immer:\n"
"Lieber Stillstand als Untergang!"
msgstr ""

#: Game.Levels.Quantus.L01_NonemptyUse
msgid ""
msgstr ""

#: Game.Levels.Quantus.L01_NonemptyUse
msgid "Auf der Vorderseite steht folgendes."
msgstr ""

#: Game.Levels.Quantus.L01_NonemptyUse
msgid "**Du**: Ich soll zeigen, dass es eine natürlich Zahl gibt?\n"
"\n"
"**Robo**: Genau.  Dazu gibts du mit `use _` einfach irgendeine natürlich Zahl an."
msgstr ""

#: Game.Levels.Quantus.L01_NonemptyUse
msgid "Ihr dreht das Blatt um."
msgstr ""

#: Game.Levels.Quantus.L02_NonemptyObtain
msgid ""
msgstr ""

#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "Auf der Rückseite steht folgendes."
msgstr ""

#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "**Du**: Was ist das denn jetzt?  `A` ist in „Typ“?\n"
"\n"
"**Robo** Du kannst dir `A` einfach als Menge vorstellen …\n"
"\n"
"**Du** … die laut Annahme `h` nicht leer ist?\n"
"\n"
"**Robo** Genau.\n"
"\n"
"**Du** Und zeigen soll ich, dass es ein Element in `A` gibt?\n"
"\n"
"**Robo** Richtig.\n"
"\n"
"**Du** Und folgt das nicht genau aus der Annahme?\n"
"\n"
"**Robo** Das ist wieder so ein Annahme, die man mit `obtain` „zerlegen“ kann.\n"
"Probier mal `obtain ⟨a⟩ := h`."
msgstr ""

#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "Ihr erhaltet einen bescheidenen Applaus.  Die Formalosophinnen tuscheln untereinander."
msgstr ""

#: Game.Levels.Quantus.L03_Decide
msgid ""
msgstr ""

#: Game.Levels.Quantus.L03_Decide
msgid "Offenbar versuchen sich die Formalosophinnen auf ein weiteres Problem zu einigen, dass sie euch präsentieren könnten.\n"
"Nach einer Weile kristallisieren sich zwei Lager heraus.\n"
"Ihr hört abwechselnd die Rufe „Even“ und „Odd“. Deshalb zeigt dir Robo\n"
"vorsichtshalber schon einmal die entsprechende Definition:\n"
"\n"
"```\n"
"def Even (n : ℕ) : Prop := ∃ r, n = r + r\n"
"```\n"
"\n"
"Bevor er zu `Odd` weitergehen kann,\n"
"taucht von irgendwo aus der Menge folgendes Papier auf:"
msgstr ""

#: Game.Levels.Quantus.L03_Decide
msgid "**Robo**: Moment! Dafür brauchst du die Definition gar nicht!\n"
"\n"
"**Du**: Das ist ja irgendwie trivial…\n"
"\n"
"**Robo**: Erinnerst du dich? `decide` kann alle Aufgaben lösen, bei denen es einen\n"
"einfachen Algorithmus gibt um die Wahrheit zu bestimmen.\n"
"Aussagen zu konkreten Zahlen fallen meistens in diese Kategorie!"
msgstr ""

#: Game.Levels.Quantus.L03_Decide
msgid "**Du**: Was kann denn `decide` noch alles?\n"
"\n"
"**Robo**: Konkret hat hier jemand einen ausführbaren\n"
"Algorithmus angegeben, wie entschieden werden\n"
"soll, ob `Even 42` wahr oder falsch ist. Wenn `decide` also so einen Algorithmus kennt,\n"
"dann kann es die Aufgabe lösen."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid ""
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "Die Rufe „Even“ und „Odd“ aus der Menge sind noch lange nicht verstummt, deshalb\n"
"zeigt dir Robo nochmals die Definitionen:\n"
"\n"
"```\n"
"def Even (n : ℕ) : Prop := ∃ r, n = r + r\n"
"```\n"
"\n"
"und\n"
"\n"
"```\n"
"def Odd (n : ℕ) : Prop := ∃ r, n = 2 * r + 1\n"
"```\n"
"\n"
"Damit erhaltet ihr auch ein weiteres Blatt:"
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "Das Quadrat einer geraden Zahl ist gerade."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**Robo**: Wie du oben siehst, ist `Even «{n}»` dadurch definiert,\n"
"dass ein `r` existiert so dass `r + r = «{n}»` ist. Am besten\n"
"öffnest du diese Definition mit `unfold Even at *` einmal.\n"
"Dann siehst du besser, was los ist.\n"
"\n"
"**Du**: Was ist mit `decide`?\n"
"\n"
"**Robo**: `decide` wird nicht funktionieren, da `«{n}»` keine konkrete sondern\n"
"eine beliebige Zahl ist. Da musst du schon etwas Arbeit leisten!"
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "Robo**: Am besten machst du auch noch `unfold Even at h`, damit du verstehst, was los ist."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "Ein verwirrtes murmeln geht durch die Menge.\n"
"\n"
"**Du**: Warte mal, wieso ist `«{n}» ^ 2 / 2` überhaupt wieder eine natürliche Zahl?\n"
"\n"
"**Robo**: Division auf `ℕ` wird in Lean immer abgerundet. Für `«{n}» = 1` steht da also\n"
"\n"
"```\n"
"1 ^ 2 = (1 ^ 2) / 2 + (1 ^ 2) / 2\n"
"```\n"
"\n"
"was ausgerechnet `1 = 1 / 2 + 1 / 2 = 0 + 0` ist, du bist also auf dem Holzweg!"
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**Du**: Also von `«{h}»` weiß ich jetzt, dass ein `s` existiert, so dass `s + s = «{n}»` …\n"
"\n"
"**Robo**: Mit `choose s hs using «{h}»` kannst du dieses `s` tatsächlich einführen."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**Du**: Und jetzt muss ich eine passende Zahl finden, so dass `x + x = «{n}» ^ 2`?\n"
"\n"
"**Robo**: Genau. Und mit `use _` gibst du diese Zahl an."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**Robo**: Also sowas ähnliches wie `use 4 * «{s}» ^ 3`, aber ich kann\n"
"dir leider nicht sagen, welche Zahl passt."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**Robo**: Das geht auch, jetzt musst du aber wirklich `use` verwenden."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**Du**: Ah, und jetzt `ring`!"
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "**Du**: Ah, und jetzt `ring`!\n"
"\n"
"**Robo**: Aber zuerst musst du noch mit\n"
"`rw` `n` durch `«{s}» + «{s}»` ersetzen, da `ring` das sonst nicht weiß."
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "Applaus!"
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid ""
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid "Eine weitere Frage erreicht euch.  Dieses stammt offenbar aus dem anderen Lager."
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid "**Robo**:  Ich glaube, hier kommst du mit `Odd.neg_pow` weiter."
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid ""
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid ""
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid ""
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid ""
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "Sofort taucht das nächste Blatt auf.\n"
"Es scheint, als hätten sie sich diesmal auf einen Kompromiss geeignet."
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "**Du**:  Ich glaube, ich würd gern eine Fallunterscheidung machen, ob `i` gerade oder ungerade ist.\n"
"\n"
"**Robo**:  Dann mach das doch – zum Beispiel mit `by_cases h : Even i`."
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "**Robo**:  Mit `odd_iff_not_even` kannst da `¬Odd` in `Even` verwandeln."
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "**Robo**:  Mit `odd_iff_not_even` kannst du `¬Even` in `Odd` verwandeln."
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "Eine Zahl ist gerade wenn sie nicht ungerade ist."
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "Eine Zahl ist ungerade wenn sie nicht gerade ist."
msgstr ""

#: Game.Levels.Quantus.L06_odd_iff_not_even
msgid "Diesmal habt ihr die Formalosophinnen offenbar beeindruckt.  Sie nicken anerkennend.\n"
"\n"
"Dann geht das Getuschel wieder los."
msgstr ""

#: Game.Levels.Quantus.L07_Forall
msgid ""
msgstr ""

#: Game.Levels.Quantus.L07_Forall
msgid "Nach längerem Durcheinander findet folgende Aufgabe aus der Menge zu Euch."
msgstr ""

#: Game.Levels.Quantus.L07_Forall
msgid "**Du**: Das `∀` heisst sicher \"für alle\".\n"
"\n"
"**Robo**: Und man schreibt `\\forall`. Ein `∀ x, …` im Beweisziel kannst du wie eine\n"
"Implikation mit `intro x` angehen."
msgstr ""

#: Game.Levels.Quantus.L07_Forall
msgid "Wieder anerkennendes Nicken.\n"
"\n"
"Wieder Getuschel."
msgstr ""

#: Game.Levels.Quantus.L08_PushNeg
msgid ""
msgstr ""

#: Game.Levels.Quantus.L08_PushNeg
msgid "**Robo**: Während wir warten, zeig ich dir vielleicht kurz, wie sich Negation mit Quantoren verträgt. Ich habe so ein Gefühl, dass wir das gleich brauchen werden."
msgstr ""

#: Game.Levels.Quantus.L08_PushNeg
msgid "**Du**: Was ist denn jetzt dieses `«{P}»`?\n"
"\n"
"**Robo**: `«{P}»` ist ein „Prädikat“; eine Aussage über Objekte vom Typ `«{X}»`.\n"
"Zum Beispiel könnte `«{X}»` wieder der Typ der natürlichen Zahlen sein.\n"
"Und `«{P}» x` könnte die Aussage sein:\n"
"Die natürliche Zahl `x` ist gerade. Oder: `x` hat sieben Primfaktoren. Oder: `x`\n"
"ist Robo's Lieblingszahl. Oder …\n"
"\n"
"**Du**: Schon gut, ich glaub ich habs verstanden. `«{P}»` ist sozusagen eine Abbildung, die\n"
"ein Element `x : «{X}»` nimmt und auf eine Aussage wirft.\n"
"\n"
"**Robo**: Ja, sozusagen.\n"
"\n"
"**Du**: Gut. Dann ist auch ziemlich klar, was hier die Aussage ist.\n"
"Und du wolltest mir jetzt verraten, wie ich das auf Leansch zeige?\n"
"\n"
"**Robo**: Genau. Was du brauchst, ist `push_neg`."
msgstr ""

#: Game.Levels.Quantus.L08_PushNeg
msgid "**Robo**: `push_neg` schiebt von links nach rechts. Du kannst es hier also nicht auf\n"
"das Beweisziel anwenden, wohl aber auf `«{h}»`."
msgstr ""

#: Game.Levels.Quantus.L08_PushNeg
msgid "**Robo**: Gut gemacht. Intern benutzt `push_neg` übrigens zwei Lemmas:\n"
"\n"
" - `not_exists (P : X → Prop) : ¬ (∃ x, P x) ↔ ∀ x, (¬ P x)`\n"
" - `not_forall (P : X → Prop) : ¬ (∀ x, P x) ↔ ∃ x, (¬ P x)`\n"
"\n"
"Das erste Lemma ist die Aussage, die du gerade gezeigt hast.\n"
"\n"
"**Du**: Na toll. Ich habe die Aussage also gezeigt, indem ich sie benutzt habe …\n"
"\n"
"**Robo**: :-) Hauptsache, Du merkst dir `push_neg`."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid ""
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "Nach langem Hin und Her haben sich die Formalosophinnen endlich auf folgende Frage geeignet."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Du**: Oha. Ganz links ein `¬`. Was du nicht sagst …"
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: Dieser Lösungsweg scheint mir etwas zu schwierig.\n"
"Ich würde nochmal zurückgehen und `Odd` behalten,\n"
"damit man schlussendlich `even_iff_not_odd` brauchen kann!"
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: Dieser Lösungsweg scheint mir etwas zu schwierig.\n"
"Ich würde nochmal zurückgehen und `Odd` behalten,\n"
"damit man schlussendlich `even_iff_not_odd` brauchen kann!"
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: Jetzt brauchst du eine Zahl mit `use`, und danach vermutlich das\n"
"Lemma `even_iff_not_odd` brauchen.\n"
"\n"
"**Du**: Könnte ich jetzt schon `even_iff_not_odd` anwenden?\n"
"\n"
"**Robo**: Nein, `rw` kann nicht innerhalb von Quantoren umschreiben.\n"
"\n"
"**Du**: Aber wie würde ich das machen?\n"
"\n"
"**Robo**: Zeig ich dir später, nicht hier vor großem Publikum.\n"
"Ich würde jetzt lieber mit `use` eine richtige Zahl angeben, und danach umschreiben."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: Gute Wahl! Jetzt kannst du `even_iff_not_odd` verwenden."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: Gute Wahl! Jetzt kannst du `even_iff_not_odd` verwenden."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "**Robo**: Gute Wahl! Jetzt kannst du `even_iff_not_odd` verwenden."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "Statt diesem Theorem kannst du `push_neg` verwenden."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "Statt diesem Theorem kannst du `push_neg` verwenden."
msgstr ""

#: Game.Levels.Quantus.L09_PushNeg
msgid "Die Formalosophinnen sind ganz begeistert.\n"
"Nachdem sich der Beifall gelegt hat, hast du auch einmal eine Frage.\n"
"\n"
"**Du**: Kann uns hier irgendjemand vielleicht ein bisschen Orientierung im Formaloversum geben?\n"
"\n"
"**Alle**: Ja, ja.\n"
"\n"
"**Du**: Wer denn?\n"
"\n"
"Die Frage war wieder zu konkret. Betretenes Schweigen."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid ""
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Du**: Könnt ihr eigentlich immer nur im Chor oder durcheinander reden?\n"
"\n"
"Wieder herrscht längeres Schweigen. Dann auf einmal:\n"
"\n"
"**Alle**: Es gibt unter uns eine Person, wenn die redet, dann reden alle!\n"
"\n"
"Du kratzt Dich am Kopf.\n"
"\n"
"**Robo**: Ist doch klar. Das ist auf jedem bewohnten Planeten so!\n"
"\n"
"**Du**: Was??\n"
"\n"
"**Robo**: Das ist eine Version vom Drinker's Paradox! Kennst du das nicht? Dann lies\n"
"das am besten Mal in deiner Handbibliothek nach! *In jeder Bar gibt es eine Person mit\n"
"der Eigenschaft, dass alle trinken, wenn sie trinkt.* Genauer gesagt: in jeder nicht-leeren Bar.\n"
"\n"
"**Du**: Glaube ich nicht.\n"
"\n"
"**Robo**: Glaube ich schon. Ich glaube sogar, du kannst das beweisen. Hier, probier mal!"
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Du**: Also, `«{isDrinking}»` ist wieder so ein Prädikat …\n"
"Wenn `p` eine Person ist, ist `«{isDrinking}» p` eine Aussage,\n"
"die wahr oder falsch ist. Soweit so gut."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Du**: Und wie fang ich jetzt an?\n"
"\n"
"**Robo**: Ich sagte doch, schau am besten Mal in deine Handbibliothek.\n"
"Wenn ich mich richtige erinnere, hilft eine Fallunterscheidung, ob die Aussage\n"
"`∀ (y : «{People}»), «{isDrinking}» y` wahr oder falsch ist."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Robo**: Schau mal `by_cases` an."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Du**: Und wen nehm ich jetzt?\n"
"\n"
"**Robo**: Ist das nicht egal? Aus der Annahme `h_nonempty` weißt du, dass es jemanden gibt."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Robo**: Du könntest hier mit `push_neg at «{h}»` weitermachen."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Du**: Also nach `«{h}»` existiert ja eine Person, die nicht trinkt. Könnte ich diese brauchen damit die Aussage trivialerweise wahr wird?\n"
"\n"
"**Robo**: Schau dir mal an wie man `obtain` auf die Annahme `«{h}»` anwenden könnte."
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Robo**: Was siehst du, wenn du `«{hp}»` und `«{hp'}»` anschaust?"
msgstr ""

#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "**Du**: Verstehe. Aber jetzt habe ich auch wirklich genug von dieser Prädikatenlogik!\n"
"\n"
"**Robo**: Dann fliegen wir am besten weiter! Aber bevor du fragst – hier ist wieder ein Überblick, was du auf diesem Planeten gelernt hast.\n"
"\n"
"\n"
"|               | Beschreibung                |\n"
"|:--------------|:----------------------------|\n"
"| `∃`           | Existential-Quantifier      |\n"
"| `∀`           | Forall-Quantifier           |\n"
"| `Even n`      | `n` ist gerade              |\n"
"| `Odd n`       | `n` ist ungerade            |\n"
"\n"
"|       | Taktik                    | Beispiel                                               |\n"
"|:------|:--------------------------|:-------------------------------------------------------|\n"
"| *13ᶜ* | `rw`                      | Umschreiben mit Gleichungen.                           |\n"
"| 15    | `ring`                    | Löst Gleichungen mit `+, -, *, ^`.                     |\n"
"| *4ᵇ*  | `decide`                  | Kann auch Aussagen zu konkreten Zahlen beantworten.    |\n"
"| 16    | `unfold`                  | Setzt visuell die Bedeutung einer Definition ein.      |\n"
"| 17    | `use`                     | Um ein `∃` im Goal anzugehen.                          |\n"
"| 18    | `choose x hx using h`     | Um ein `∃` in den Annahmen zu zerlegen.                |\n"
"| *8ᵇ*  | `intro`                   | Um ein `∀` im Goal anzugehen.                          |\n"
"| 19    | `push_neg`                | Für `¬∃` und `¬∀` im Goal.                             |"
msgstr ""

#: Game.Levels.Quantus
msgid "Quantus"
msgstr ""

#: Game.Levels.Quantus
msgid "Auf Quantus erwartet Euch bereits eine große Ansammlung von Formalosopheninnen.\n"
"Sie reden alle wild durcheinander und Ihr habt Probleme, Euch überhaupt Gehör zu verschaffen.\n"
"Robo produziert schließlich ein lautes Gong-Geräusch, das sie kurzzeitig zur Ruhe bringt.\n"
"\n"
"**Du**: Wir haben einen Brief für Eure Königin. Könntet Ihr uns zu Eurer Königin führen?\n"
"\n"
"**Alle** *(im Chor)*: Wir sind schon alle hier!\n"
"\n"
"**Du**: Okay. Und wer von Euch ist die Königin?\n"
"\n"
"Nun herrscht betretenes Schweigen. Alle zucken mit den Schultern.\n"
"\n"
"**Du**: Habt Ihr überhaupt eine Königin?\n"
"\n"
"**Alle** *(im Chor)*: Ja, ja. Wir haben eine Königin, wir haben eine Königin.\n"
"\n"
"**Robo** *(zu dir)*: Ich fasse mal zusammen. Es existiert eine Königin, aber keiner weiß, wer\n"
"sie ist …\n"
"\n"
"**Du**: Ist das nicht ein Widerspruch?\n"
"\n"
"**Robo**: Fragst du, du als Mathematiker? Nein, das ist kein Widerspruch. Das ist einfach eine\n"
"„reine Existenzaussage“.\n"
"\n"
"Du bist dir nicht ganz sicher, wie ernst er das meint.\n"
"\n"
"**Du**: Dann schlage ich vor, wir übergeben das Päckchen einfach an *alle* Bewohner. Dann haben\n"
"wir es ja insbesondere der Königin übergeben.\n"
"\n"
"**Du** *(in die Menge)*: Wir haben Euch ein Päckchen von Implis gebracht. Hier, das ist für Euch.\n"
"\n"
"Robo wirft es in die Menge, und die Formalosophinnen reißen es auf.\n"
"Tatsächlich befindet sich darin nur eine einziges Stück Papier.\n"
"Nach wenigen Minuten liegt es wieder bei euch.\n"
"Und die Formalosophinnen schauen alle neugirig, wie ihr damit umgeht."
msgstr ""

#: Game.Levels.Saturn.L01_Ring_add_pow_two
msgid ""
msgstr ""

#: Game.Levels.Saturn.L01_Ring_add_pow_two
msgid "Plötzlich erreicht euch ein Funkspruch."
msgstr ""

#: Game.Levels.Saturn.L01_Ring_add_pow_two
msgid "**Du**: Sind wir hier bei den anonymen Schulmathematikern?\n"
"Man rechnet das doch einfach aus, indem man die Terme umsortiert.\n"
"Was sollen wir da zurückfunken?\n"
"\n"
"**Robo**: Am einfachsten kannst du so eine Gleichung auf Leansch mit `ring` beweisen."
msgstr ""

#: Game.Levels.Saturn.L01_Ring_add_pow_two
msgid "Es kommt ein 👍 zurück.\n"
"\n"
"  **Robo**:  Übrigens heißt dieses Resultat auf Leansch …\n"
"\n"
"  **Du**: Warte, lass mich raten –  `binomi`?\n"
"\n"
"  **Robo**:  Nein.  Das heißt `add_pow_two`.\n"
"  Weil in der Formel zuerst ein “+” und dann ein “^2” steht."
msgstr ""

#: Game.Levels.Saturn.L01_Ring_add_pow_two
msgid ""
msgstr ""

#: Game.Levels.Saturn.L02_mul_comm
msgid ""
msgstr ""

#: Game.Levels.Saturn.L02_mul_comm
msgid "Noch ein Funkspruch."
msgstr ""

#: Game.Levels.Saturn.L02_mul_comm
msgid "Wieder ein 👍.\n"
"\n"
"  **Du**: Aber halt, diesmal sind die Variablen doch in `ℕ`!\n"
"  Das ist doch gar kein Ring!\n"
"\n"
"  **Robo**: Ist es nicht.  Aber `ring` funktioniert sogar für sogenannte Halbringe.\n"
"  Und die Aussage hier heißt übrigens `mul_comm`.\n"
"\n"
"  **Du**: So so …"
msgstr ""

#: Game.Levels.Saturn.L02_mul_comm
msgid ""
msgstr ""

#: Game.Levels.Saturn.L03_mul_assoc
msgid ""
msgstr ""

#: Game.Levels.Saturn.L03_mul_assoc
msgid "Noch ein Funkspruch."
msgstr ""

#: Game.Levels.Saturn.L03_mul_assoc
msgid "Wieder ein 👍.\n"
"\n"
"  **Du**: Und wie heißt diese tolle Gleichung?\n"
"  Langsam wird das ein bisschen langweilig …\n"
"\n"
"  **Robo**: Sie heißt `mul_assoc`.\n"
"  Ja, hoffen wir, dass der volle Antrieb bald wieder da ist."
msgstr ""

#: Game.Levels.Saturn.L03_mul_assoc
msgid ""
msgstr ""

#: Game.Levels.Saturn.L04_Rewrite_equality
msgid ""
msgstr ""

#: Game.Levels.Saturn.L04_Rewrite_equality
msgid "Der nächste Funkspruch sieht ein bisschen anders aus."
msgstr ""

#: Game.Levels.Saturn.L04_Rewrite_equality
msgid "**Du**: Ich habe das Gefühl, das habe ich schon einmal gesehen.\n"
"\n"
"**Robo**:  Ja!  Das sieht so ähnlich aus wie eine Aufgabe, die wir auf *Implis*\n"
"schon gelöst hatten.\n"
"Nur, das hier jetzt Gleichheiten von Zahlen statt Genau-Dann-Wenn-Aussagen stehen!\n"
"Aber das macht im Grunde gar keinen Unterschied.\n"
"Du kannst `=` und `↔` mit `rw` praktisch gleich behandeln."
msgstr ""

#: Game.Levels.Saturn.L04_Rewrite_equality
msgid "**Du**: Also auch `rw [hₓ]` und `rw [← hₓ]`?\n"
"\n"
"**Robo**: Probiers doch einfach."
msgstr ""

#: Game.Levels.Saturn.L04_Rewrite_equality
msgid "**Du**: Wie war das nochmals mit rückwärts umschreiben?\n"
"\n"
"**Robo**: `←` ist `\\l`. Und dann `rw [← hₓ]`"
msgstr ""

#: Game.Levels.Saturn.L04_Rewrite_equality
msgid "Wieder kommt ein 👍 zurück.\n"
"\n"
"  Dann möchte der anonyme Funker wissen, ob ihr bereit seid für das End Game,\n"
"  oder ob ihr lieber noch ein paar Runden um seinen Planeten kreisen wollt.\n"
"\n"
"  “Bereit” funkt Robo zurück."
msgstr ""

#: Game.Levels.Saturn.L04_Rewrite_equality
msgid ""
msgstr ""

#: Game.Levels.Saturn.L04_Rewrite_equality
msgid ""
msgstr ""

#: Game.Levels.Saturn.L05_Ring
msgid ""
msgstr ""

#: Game.Levels.Saturn.L05_Ring
msgid ""
msgstr ""

#: Game.Levels.Saturn.L05_Ring
msgid "**Robo**:  Ich vermute, hier wirst du doch das ein oder andere Lemma brauchen, das wir gerade gesehen haben.\n"
"Du könntest zum Beispiel mit `rw [add_pow_two] at h` anfangen."
msgstr ""

#: Game.Levels.Saturn.L05_Ring
msgid "**Robo*: Jetzt willst du in `h` aus `(2*a)*o` den Ausdruck `a*(2*o)` machen, damit du `h2o`- benutzen kannst, nicht wahr?\n"
"Vielleicht machst du erst einmal mit `mul_comm` aus `2*a` den Ausdruck `a*2`."
msgstr ""

#: Game.Levels.Saturn.L05_Ring
msgid "**Du**: Das war nicht, was ich wollte.\n"
"\n"
"**Robo**:  Nein. In diesem Fall musst du wohl genauer sagen, welche beiden Zahlen du vertauschen möchtest:\n"
"`mul_comm 2 a`."
msgstr ""

#: Game.Levels.Saturn.L05_Ring
msgid "**Robo**: Und jetzt `mul_assoc`."
msgstr ""

#: Game.Levels.Saturn.L05_Ring
msgid "“Bestanden” heißt es kurz und knapp von anonymen Funker.\n"
"\n"
"  **Robo**: Ich glaube, der Antrieb hat sich jetzt genügend regeniert.\n"
"  Nichts wie weg!"
msgstr ""

#: Game.Levels.Saturn
msgid "Saturn"
msgstr ""

#: Game.Levels.Saturn
msgid "Diesen Planeten wolltet ihr eigentlich gar nicht ansteuern.\n"
"Aber ihr wart mit den Gedanken nicht ganz bei der Sache.\n"
"Und man darf in Universen nicht unaufmerksam sein, erst recht nicht, wenn man sich nicht auskennt.\n"
"Nun seid ihr bereits zu nah herangeflogen, die Gravitation ist zu stark, und euer regenerativer Antrieb ist gerade im Regenerationsmodus.\n"
"\n"
"**Du**:  Was ist das denn für eine orange Soße auf diesem Planeten?\n"
"\n"
"**Robo**:  Sieht eher giftig aus.  Oder heiß.\n"
"\n"
"**Du**:  Oder beides.  Ich will da wirklich nicht landen!\n"
"\n"
"**Robo**:  Ja, ja, ich gebe mir ja schon alle Mühe.  Und schau mal, wie viel Müll hier bereits orbitet!\n"
"Das beste, was wir momentan tun können, ist mit dem Strom zu fliegen."
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**Benedictus**: Hier, schaut mal. Das habe ich für Euch vorbereitet."
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**Du**: Also als erstes teile ich wohl mal das Und (`∧`) auf."
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**Du**: Und jetzt …\n"
"\n"
"**Benedictus**: … solltest du dir ein passendes Zwischenresultat zurechtlegen.\n"
"\n"
"**Robo**: Ja! Probier mal `have g : ¬ B`!"
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**Du**: Was? Jetzt hab ich einfach angenommen, dass sei richtig?\n"
"\n"
"**Robo**: Nee, jetzt musst du das erst noch beweisen, bevor du es dann benutzen kannst."
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**Robo**: `apply` sollte helfen"
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**Du**: Und wie war das nochmals wenn zwei Annahmen sich widersprechen?\n"
"\n"
"**Robo**: `contradiction`."
msgstr ""

#: Game.Levels.Spinoza.L01_Have
msgid "**Benedictus**: Das sieht gut aus!"
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "**Benedictus**: Ihr hättet natürlich auch erst das Hauptresultat und dann das\n"
"Zwischenresultat beweisen können. Das könnt Ihr ja mal an dieser Aufgabe probieren, die ist\n"
"ganz ähnlich."
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "**Robo**: Ich weiß was er meint! Anstatt `have` kannst du auch `suffices`\n"
"verwenden. Das funktioniert genau gleich, außer, dass dann die beiden Beweisziele vertauscht sind.\n"
"\n"
"**Du**: Also nach `suffices g : ¬B` muss ich dann zuerst zeigen, wie man mit `g` den Beweis\n"
"abschliesst, bevor ich `g` beweise?\n"
"\n"
"**Robo**: Genau!"
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "**Robo**: Also hier beendest du den Beweis unter der Annahme `«{g}»` sei wahr."
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "**Robo**: Und hier beweist du das Zwischenresultat."
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "**Benedictus**: Genau so meinte ich das. Ob Ihr nun in Zukunft `have` und\n"
"`suffices` verwendet, ist reine Geschmacksfrage. Hauptsache, Ihr wisst, wie Ihr\n"
"entfernte Ziele in kleinen Schritte erreicht."
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**Benedictus**: Hier ist noch eine Variante."
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**Robo**: Ein `¬` im Goal heißt häufig, dass du einen Widerspruchsbeweis führen\n"
"möchtest.\n"
"\n"
"**Du**: Und wie mache ich das? Mit `contradiction`?\n"
"\n"
"**Robo**: Mit `by_contra h` fängst du einen Widerspruchsbeweis an. Und mit `contradiction`\n"
"schließt du ihn ab."
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**Robo**: Jetzt hast du also eine Annahme `«{h}» : «{A}»`, und damit musst du einen\n"
"Widerspruch herleiten.\n"
"\n"
"Du könntest zum Beispiel jetzt mit `suffices` sagten, welchen Widerspruch du gern herleiten\n"
"möchtest, etwa `suffices k : B`"
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**Du**: Ah, und jetzt kann ich einfach sagen dass sich die Annahmen `«{B}»` und `¬«{B}»` sich\n"
"widersprechen."
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**Robo**: Und jetzt musst du nur noch das Zwischenresultat herleiten, dass zu diesem\n"
"Widerspruch geführt hat."
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "**Benedictus**: Ich sehe schon, Ihr lernt schnell!"
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**Benedictus**: Ich habe noch eine schöne Frage zu ungeraden Quadraten für Euch.\n"
"Aber vorher beweist Ihr besser noch diese Äquivalenz hier. Ich glaube, die hat sogar\n"
"bei Euch einen Namen: *Kontrapositionsäquivalenz*, oder so etwas. Auf Leansch nennen wir\n"
"die Äquivalenz einfach `not_imp_not`. Ist doch viel einleuchtender, oder?"
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**Du**: Ja, das habe ich tatsächlich schon einmal gesehen.\n"
"\n"
"**Robo**: Ja, klar hast du das schon einmal gesehen. Das benutzen Mathematiker doch ständig.\n"
"Wenn ihnen zu $A ⇒ B$ nichts einfällt, zeigen sie stattdessen $¬B ⇒ ¬A$. Ich würde das ja\n"
"statt *Kontraposition* oder `not_imp_not` eher *von_hinten_durch_die_Brust_ins_Auge* nennen.\n"
"Aber gut, ich will mich nicht einmischen."
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**Robo**: Fang doch mal mit `constructor` an."
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**Robo**: Ich würde wieder mit `suffices g : B` einen Widerspruch herbeiführen."
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**Robo**: Hier würde ich ebenfalls einen Widerspruchsbeweis anfangen."
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "**Robo**: `suffices g : ¬ A` sieht nach einer guten Option aus."
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**Benedictus**: Gut, hier ist die angekündigte Frage. Versucht mal einen *direkten*\n"
"Beweis, ohne `by_contra`."
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**Robo**: Ich schlage vor, wir führen das auf das Lemma `even_square` zurück, das wir auf\n"
"Quantus schon gezeigt hatten. Hier steht ja im Grunde `Odd (n^2) → Odd n`. Und unter\n"
"Kontraposition ist das äquivalent zu `Even n → Even (n^2)`.\n"
"\n"
"**Du**: Richtig. Von hinten durch die Brust … Aber warte, im Moment steht da doch gar kein `→`.\n"
"\n"
"**Robo**: Erinner dich an `revert`. Mit `revert «{h}»` kannst du die Annahme `«{h}»` als\n"
"Implikationsannahme ins Beweissziel schieben."
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**Du**: Und jetzt kann ich dieses Kontrapositionslemma anwenden? Wie hieß das noch einmal?\n"
"\n"
"**Robo**: Tatsächlich kannst auch einfach `contrapose` schreiben."
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**Robo**: Vielleicht hilft jetzt `even_iff_not_odd` weiter?"
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**Du**: Das sieht schon ganz gut aus. Jetzt kann ich tatsächlich das alte Lemma\n"
"`even_square` anwenden!"
msgstr ""

#: Game.Levels.Spinoza.L05_Contrapose
msgid "**Benedictus**: Hervorragend! Ich glaube, damit seid Ihr jetzt ganz gut gewappnet."
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid ""
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid "**Du**: Aber hätten wir die letzte Aufgabe nicht genauso gut per Widerspruch beweisen können?\n"
"\n"
"**Benedictus**: Klar. Ich dachte nur, ein zweiter Widerspruchsbeweis wäre langweilig. Aber Ihr könnt die Aufgabe gern noch einmal probieren. Hier, ich gebe Sie Euch mit auf die Reise. Aber nun seht zu, dass Ihr weiterkommt!"
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid "Sobald Ihr Euch sicher vom Gravitationsfeld des Asteroiden befreit habt, beugt Ihr\n"
"Euch wieder über die Aufgabe.\n"
"\n"
"**Robo**: Okay, also diesmal fangen wir mit `by_contra g` an!"
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid "**Robo**: Jetzt würde ich einen Widerspruch zu `Odd (n ^ 2)` führen."
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid "**Robo**: Also `suffices d : ¬ Odd (n ^ 2)`."
msgstr ""

#: Game.Levels.Spinoza.L06_Summary
msgid "**Robo**: Bravo! Hier ein Überblick, was uns Benediktus gezeigt hat.\n"
"\n"
"\n"
"| **Taktik**      | **Zweck**                                              |\n"
"|:----------------|:-------------------------------------------------------|\n"
"| `have`          | Zwischenresultat annehmen                              |\n"
"| `suffices`      | Zwischenresultat annehmen                              |\n"
"| `by_contra`     | Widerspruchsbeweis anfangen                            |\n"
"| `contradiction` | Widerspruchsbeweis schließen                           |\n"
"| `contrapose`    | Kontraposition                                         |\n"
"| `revert`        | nützlich, um danach `contrapose` anzuwenden            |"
msgstr ""

#: Game.Levels.Spinoza
msgid "Spinoza"
msgstr ""

#: Game.Levels.Spinoza
msgid "**Robo**: Ich glaube, das ist Spinoza, einer der ganz wenigen Asteroiden vom Type QED. Schnell. Wir müssen uns ein bisschen beeilen, sonst verpassen wir ihn.\n"
"\n"
"Eine halbe Stunde später seid ihr gelandet. Sehr einladend wirkt Spinoza nicht. Seine gesamte Oberfläche ist von feinem, rötlichen Sand bedeckt.\n"
"Ein einziger, einsamer Formalosoph, der sich als Benedictus vorstellt, erwartet euch.\n"
"\n"
"**Benedictus**: Schön, dass Ihr gekommen seid! Ich habe schon auf Euch gewartet!\n"
"\n"
"**Du**: Hast du auch ein paar dringende Fragen … ?\n"
"\n"
"**Benedictus**: Ach nein, aus dem Alter bin ich heraus. Aber ich kann mir denken, wie es Euch auf Implis und Quantus ergangen ist. Und glaubt, mir auf den anderen Planeten wird es nicht viel besser. Aber ich kann Euch vielleicht ein bisschen vorbereiten.\n"
"\n"
"**Du**: Können wir nicht einfach hier bleiben und uns ein wenig ausruhen?\n"
"\n"
"Benedictus schüttelt den Kopf.\n"
"\n"
"**Benedictus**: Nein. Spinoza verträgt keine drei Bewohner. Und Ihr müsst bald wieder weiter, sonst wird der Weg zu weit. Wir kommen nur alle 400 Jahre bei den Planeten vorbei."
msgstr ""

#: Game.Levels.Luna.L01_le_rfl
msgid ""
msgstr ""

#: Game.Levels.Luna.L01_le_rfl
msgid "Du fühlst dich ein wenig überfahren, aber versuchst trotzdem, ein Gespräch zu beginnen.\n"
"\n"
"**Du**: Ist gut, wir bemühen uns, nichts durcheinander zu bringen. Ist es sehr schwer,\n"
"hier Ordnung zu halten?\n"
"\n"
"**Lina**: Man muss zum Beispiel wissen, dass `n ≤ n` ist."
msgstr ""

#: Game.Levels.Luna.L01_le_rfl
msgid "**Robo**: `rfl`?"
msgstr ""

#: Game.Levels.Luna.L01_le_rfl
msgid "**Lina**:  Zugegeben, das war ein triviales Beispiel."
msgstr ""

#: Game.Levels.Luna.L02_Omega
msgid ""
msgstr ""

#: Game.Levels.Luna.L02_Omega
msgid "**Lina**: Außerdem muss man zum Beispiel wissen, dass `0 < n` oder `n < 0` für ganze Zahlen nichts anderes\n"
"bedeutet als `n ≠ 0`."
msgstr ""

#: Game.Levels.Luna.L02_Omega
msgid "**Ritha** *(flüsternd)*: Probiert mal `omega`!"
msgstr ""

#: Game.Levels.Luna.L02_Omega
msgid "Lina rollt die Augen.\n"
"\n"
"**Lina**: Ritha ist ein großer Fan von `omega`.  Dabei ist `omega` ziemlich impotent.\n"
"Sobald man die ganzen Zahlen verlässt, kann `omega` gar nichts mehr.\n"
"\n"
"**Ritha**:  Selber impotent!\n"
"\n"
"Ritha macht eine unanständige Grimasse."
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid ""
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "**Lina**: Probierts doch mal hiermit!"
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "Wird typischerweise mit `obtain` verwendet, um in einem Beweis die drei Fälle `x < y`, `x = y` und `x > y` zu unterscheiden:\n"
"\n"
"```\n"
"obtain h | h | h := lt_trichotomy x y\n"
"```"
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "**Du**:  Fallunterscheidung ??\n"
"\n"
"**Robo**:  Ja, könntest du versuchen. Zum Beispiel erst `by_cases h_leq : a ≤ b` und dann `by_cases h_lt : a < b`."
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "**Du**:  Und jetzt??\n"
"\n"
"**Lina** (*triumphal*): `linarith`!"
msgstr ""

#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "**Lina**:  Ihr hättet übrigens auch einfach `apply lt_trichotomy` sagen können."
msgstr ""

#: Game.Levels.Luna.L04_Omega2
msgid ""
msgstr ""

#: Game.Levels.Luna.L04_Omega2
msgid "**Lina**:  Hier habe ich noch etwas."
msgstr ""

#: Game.Levels.Luna.L04_Omega2
msgid "Ritha scheint euch mit ihren Augen irgendein Zeichen geben zu wollen."
msgstr ""

#: Game.Levels.Luna.L04_Omega2
msgid "**Lina**:  Ja, okay, mein Fehler."
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid ""
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid "**Lina:** Nochmal dieselbe Frage, aber jetzt in ℝ!"
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid "**Du** (*zu Robo*):  Hier komme ich weder mit `omega` noch mit `linarith` weiter.\n"
"\n"
"**Robo**:  Ich glaube, du musst `linarith` nur etwas auf die Sprünge helfen.\n"
"Lös am besten erst einmal ganz kanonisch die beiden Implikationen mit `intro` auf."
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid "**Robo**:  Und jetzt machst du die Annahme `«{hx}»` ein bisschen lesbarer.\n"
"Probier vielleicht einmal `push_neg «{hx}»`?"
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid "**Robo**:  Mmm … `«{hx}» : m ≤ x → n < x` sieht immer noch suboptimal aus.\n"
"Aber wir wissen ja, was `→` bedeutet – probier mal ein `rw` mit `imp_iff_or_not`!"
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid "**Robo**:  Okay.  Das ist besser. Und jetzt kannst du `«{hx}»` noch mit `obtain` in die\n"
"beiden Bestandteile aufspalten."
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid ""
msgstr ""

#: Game.Levels.Luna.L06_Icc__insert_Icc_eq_Icc_add_one_right
msgid ""
msgstr ""

#: Game.Levels.Luna.L06_Icc__insert_Icc_eq_Icc_add_one_right
msgid "**Ritha**:  Kann ich auch mal?  Hier."
msgstr ""

#: Game.Levels.Luna.L06_Icc__insert_Icc_eq_Icc_add_one_right
msgid ""
msgstr ""

#: Game.Levels.Luna.L06_Icc__insert_Icc_eq_Icc_add_one_right
msgid "**Du**:  Was ist denn `Icc`?\n"
"\n"
"**Ritha**:  Na das **I**ntervall, das links **c**losed und rechts **c**losed, also abgeschlossen ist.\n"
"\n"
"**Robo**:  Du würdest `Icc a b` vermutlich als $[a, b]$ schreiben,\n"
"oder als $\\{a, a + 1, \\dots, b\\}$, weil wir ja hier wieder in den natürlichen Zahlen sind.\n"
"Zu zeigen ist also:\n"
"\n"
"$$\n"
"[a, b] ∪ \\{ b + 1 \\} = [a, b + 1]\n"
"$$"
msgstr ""

#: Game.Levels.Luna.L06_Icc__insert_Icc_eq_Icc_add_one_right
msgid "**Robo:** Gleichheit von Mengen ruft nach `ext`."
msgstr ""

#: Game.Levels.Luna.L06_Icc__insert_Icc_eq_Icc_add_one_right
msgid "**Robo:**  Schieß mal gleich noch ein `simp` hinterher."
msgstr ""

#: Game.Levels.Luna.L06_Icc__insert_Icc_eq_Icc_add_one_right
msgid "Ritha macht wieder irgendwelche Zeichen."
msgstr ""

#: Game.Levels.Luna.L06_Icc__insert_Icc_eq_Icc_add_one_right
msgid ""
msgstr ""

#: Game.Levels.Luna.L07_Linarith2
msgid ""
msgstr ""

#: Game.Levels.Luna.L07_Linarith2
msgid "**Lina**:  Genug von `omega`, jetzt bin ich wieder an der Reihe."
msgstr ""

#: Game.Levels.Luna.L07_Linarith2
msgid "**Du**:  Das muss ich mir erst noch einmal untereinander schreiben.  Gegeben ist:\n"
"\n"
"$$\n"
"\\begin{aligned}\n"
"\\tfrac{35}{11}\\cdot y &\\le -\\tfrac{22}{21}\\cdot x + \\tfrac{35}{2}  \\\\\n"
"\\tfrac{8}{9} \\cdot y &\\le x + \\tfrac{17}{8}\n"
"\\end{aligned}\n"
"$$\n"
"\n"
"Und wir sollen zeigen:\n"
"$$\n"
"y ≤ \\tfrac{34}{7}\n"
"$$\n"
"\n"
"Robo??\n"
"\n"
"Lina grinst."
msgstr ""

#: Game.Levels.Luna.L07_Linarith2
msgid "**Du**: Nicht schlecht!"
msgstr ""

#: Game.Levels.Luna.L08_Omega3
msgid ""
msgstr ""

#: Game.Levels.Luna.L08_Omega3
msgid "**Ritha**:  Jetzt ich wieder!"
msgstr ""

#: Game.Levels.Luna.L08_Omega3
msgid ""
msgstr ""

#: Game.Levels.Luna.L09_lt_trichotomy2
msgid ""
msgstr ""

#: Game.Levels.Luna.L09_lt_trichotomy2
msgid "**Lina**:  Jetzt ich wieder."
msgstr ""

#: Game.Levels.Luna.L09_lt_trichotomy2
msgid "**Du**:\n"
"Nun, es ist schon ziemlich klar, welches `b` man hier verwenden könnte.\n"
"\n"
"**Robo**: Wenn dir das so klar ist, dann fang doch schon einmal mit `use …` an.\n"
"Und danach wirst du `lt_trichotomy` gut gebrauchen können.  Zum Beispiel so:\n"
"```\n"
"obtain h | h | h := lt_trichotomy a c\n"
"```"
msgstr ""

#: Game.Levels.Luna.L09_lt_trichotomy2
msgid "**Lina**: Habt ihr gut gemacht!  Schade, dass ihr schon weiterfliegen müsst.\n"
"  Aber wenn ihr noch länger bleibt, bringt ihr unseren Tagesrhythmus völlig durcheinander."
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid ""
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "**Ritha** (*zu Lina*):  Bitte, lass mich doch auch noch eine Frage stellen …\n"
"\n"
"**Lina**:  Okay, eine einzige …  Aber nicht wieder zu `omega`!\n"
"\n"
"Ritha macht große Augen und sieht Lina flehend an.\n"
"\n"
"**Lina**:  Wenns *unbedingt* sein muss.  Aber mach schnell! Wir haben jetzt wirklich keine Zeit mehr!"
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid ""
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "**Robo**: Vielleicht hilft hier mal wieder `subset_iff`.  Und wenn gar nichts geht, probier mal `simp`."
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "**Robo**:  Die Annahme `«{h}»` musst du sicherlich irgendwie ausnutzen.\n"
"Du könnest `«{h}»` zum Beispiel auf die Ungleichung `a₁ ≤ b₁` oder auf `a₁ ≤ a₁` anwenden!"
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid ""
msgstr ""

#: Game.Levels.Luna
msgid "Luna"
msgstr ""

#: Game.Levels.Luna
msgid "Robo hat einen kleinen Mond entdeckt, auf den ihr jetzt zusteuert.\n"
"Er hat eine ganz glatte Oberfläche, aber an einer Stelle hat die Oberfläche eine kleine\n"
"Öffnung, von der eine Treppe ins Innnere führt. Ihr landet und steigt neugierig hinab.\n"
"\n"
"Unten angekommen findest du dich in der aufgeräumtesten Wohnung wieder, die du je gesehen hast.\n"
"Ein kleines Mädchen begrüßt Euch.\n"
"\n"
"**Lina**: Ich bin Lina, die einzige Bewohnerin von Luna.\n"
"\n"
"Dann sieht sie Robo.\n"
"\n"
"**Lina**: Naja, eigentlich sind wir hier auch zu zweit …\n"
"\n"
"Sie dreht sich um und ruft etwas, da kommt ein Smart-Elf angefahren.\n"
"\n"
"**Lina**: Das ist Ritha!\n"
"\n"
"Robo findet sie offensichtlich süß.\n"
"\n"
"**Lina**: Aber jetzt steht mal hier nicht so unordentlich herum, bitte! Schuhe und Helme dort\n"
"und dort verstauen, und dann stellt Euch auf die markierten Besucher-Standpunkte. Sonst komme\n"
"ich hier noch ganz durcheinander."
msgstr ""

#: Game.Levels.Babylon.L01_Simp
msgid ""
msgstr ""

#: Game.Levels.Babylon.L01_Simp
msgid "**Babylonier**: Jeder Turm hat eine Inschrift. Da könnt ihr noch einmal genau nachlesen,\n"
"warum er steht. Hier zum Beispiel."
msgstr ""

#: Game.Levels.Babylon.L01_Simp
msgid "**Du**: Oh das ist ganz schön viel neues … mal sehen …\n"
"\n"
"Das sieht aus wie $( \\sum_i 0 + 0 ) = 0$.\n"
"\n"
"**Robo**: Genau! Man schreibt `\\sum`. Und `i : Fin n` bedeutet,\n"
"dass summiert wird über $0$, $1$, …, $n-1$.\n"
"\n"
"**Du**: Okay. Und was mach ich jetzt?\n"
"\n"
"**Robo**: `simp` ist eine starke Taktik, die viele Terme vereinfacht.\n"
"Wir fangen besser an, sie zu benutzen."
msgstr ""

#: Game.Levels.Babylon.L01_Simp
msgid "**Babylonier**: Seht ihr, das passt!\n"
"\n"
"**Robo**: Mir fällt gerade ein, du hattest ja mal gefragt bezüglich `rw` unter Quantoren.\n"
"Mit Summen ist das das gleiche: Hier musst du immer `simp_rw` verwenden, wenn du innerhalb\n"
"einer Summe was umschreiben möchtest."
msgstr ""

#: Game.Levels.Babylon.L02_Sum
msgid ""
msgstr ""

#: Game.Levels.Babylon.L02_Sum
msgid "Ihr schaut euch den nächsten Turm an."
msgstr ""

#: Game.Levels.Babylon.L02_Sum
msgid "$\\sum_{i=0}^{n-1} 2 = n × 2$."
msgstr ""

#: Game.Levels.Babylon.L03_Sum
msgid ""
msgstr ""

#: Game.Levels.Babylon.L03_Sum
msgid "Ihr schaut euch den nächsten Turm an."
msgstr ""

#: Game.Levels.Babylon.L03_Sum
msgid "$\\sum_{i=0}^{n-1} (i + 1) = n + \\sum_{i=0}^{n-1} i$."
msgstr ""

#: Game.Levels.Babylon.L03_Sum
msgid "**Du**: Hmm, wieder `simp`?\n"
"\n"
"**Robo**: Nicht ganz. `simp` benutzt nur Lemmata, die klar eine Vereinfachung darstellen.\n"
"Im Lean-Duden sind diese Lemmata mit `@[simp]` markiert.\n"
"Hier brauchen wir aber folgende Identität:\n"
"\n"
"$$\n"
"\\sum_{i = 0}^n a_i + b_i = \\sum_{i = 0}^n a_i + \\sum_{j = 0}^n b_j\n"
"$$\n"
"\n"
"**Robo**: Und da bei dieser Identität unklar ist, welche Seite „einfacher“ ist, wird so ein Lemma nicht mit\n"
"`@[simp]` markiert.\n"
"\n"
"**Du**: Hat diese Gleichheit denn wenigstens einen Namen.\n"
"\n"
"**Robo**: Sie heißt `sum_add_distrib`."
msgstr ""

#: Game.Levels.Babylon.L03_Sum
msgid "**Robo**: Die zweite Summe `∑ x : Fin n, 1` kann jetzt aber mit\n"
"`simp` zu `n` vereinfacht werden."
msgstr ""

#: Game.Levels.Babylon.L03_Sum
msgid "**Robo**: Bis auf Umordnung sind jetzt beide Seiten gleich!\n"
"\n"
"**Du**: Dann greift jetzt wohl `ring`!\n"
"\n"
"**Robo**: Genau! Und alternativ könntest du mit `rw [add_comm]` die Arbeit von `ring`\n"
"auch manuell machen."
msgstr ""

#: Game.Levels.Babylon.L03_Sum
msgid ""
msgstr ""

#: Game.Levels.Babylon.L03_Sum
msgid "Der Babylonier macht ein sehr zufriedenes Gesicht."
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid ""
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid "**Babylonier**: Kommt, ich zeig Euch mal einen unserer schönsten Türme!\n"
"\n"
"Nach einem kurzen Spaziergang steht ihr davon.\n"
"\n"
"**Robo**: Das muss der bekannte *Gaußsche Turm von Babylon* sein!\n"
"Über den hab ich schon einmal Daten verarbeitet.\n"
"\n"
"**Babylonier**: Richtig. Gauß war ein Babylonier!"
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid "$2 \\cdot \\sum_{i = 0}^n i = n \\cdot (n + 1)$."
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid "**Du**: Klar, die werden ja nicht oben anfangen mit bauen. Sag mal,\n"
"wie zeige ich denn die arithmetische Summe, die hier gekritzelt steht?\n"
"Ich würde gerne Induktion über $n$ anwenden.\n"
"\n"
"**Robo**: Wenn du meinst … Auf Leansch wäre das: `induction n with d hd`!\n"
"Der Zusatz `with d hd` ist natürlich optional.\n"
"Du kannst damit Namen für Induktionsvariable (d) und -hypothese (h) vorgeben."
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid "**Du**: Zuerst der Induktionsanfang …\n"
"\n"
"**Robo**: Diesen kannst du oft mit `simp` abkürzen!"
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid "**Robo**: Jetzt der Induktionsschritt.\n"
"Bei Induktion über endlichen Summen beginnst du den Induktionsschritt\n"
"immer mit `rw [sum_univ_castSucc]`."
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid "**Du**: Oh das sieht jetz aber kompliziert aus…\n"
"\n"
"**Robo**: Da musst du etwas darüber hinweg lesen. Am besten machst du kurz `simp`,\n"
"dann sieht's schon wieder besser aus."
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid "**Du**: Was bedeutet eigentlich der kleine Pfeil `↑`?\n"
"\n"
"**Robo**: Das ist eine *Coersion*. Sowas wie wenn man eine natürliche Zahl als ganze Zahl betrachtet,\n"
"also die natürliche Abbildung `ℕ ↪ ℤ` benutzt. Oder hier, wenn ein Element `x : Fin n` als\n"
"Element `↑x : ℕ` betrachtet wird."
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid "**Robo**: Um die Induktionshypothese anzuwenden, brauchst du zuerst das Lemma `mul_add`."
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid "**Du**: Und wie wende ich jetzt die Induktionshypothese an?\n"
"\n"
"**Robo** mit `rw` wie jede andere Annahme auch."
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid "**Du**: Der Rest ist einfach Rechnerei.\n"
"\n"
"**Robo**: Dann wird `ring` wohl keine Probleme haben."
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid ""
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid ""
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid ""
msgstr ""

#: Game.Levels.Babylon.L04_ArithSum
msgid "Du schaust dich um und bewunderst das Tal in dem hunderte, wenn nicht tausende,\n"
"Steintürme in allen Formen und Höhen stehen."
msgstr ""

#: Game.Levels.Babylon.L05_SumOdd
msgid ""
msgstr ""

#: Game.Levels.Babylon.L05_SumOdd
msgid "Aus reiner Neugierde gehst Du zu einem etwas kleineren Nachbarsturm hinüber."
msgstr ""

#: Game.Levels.Babylon.L05_SumOdd
msgid "$\\sum_{i = 0}^{n-1} (2i + 1) = n ^ 2$."
msgstr ""

#: Game.Levels.Babylon.L05_SumOdd
msgid "**Robo**: Das funktioniert genau gleich wie zuvor, viel Glück."
msgstr ""

#: Game.Levels.Babylon.L05_SumOdd
msgid "Den Induktionschritt bei Summen solltest du wie gesagt\n"
"immer mit `rw [sum_univ_castSucc]` beginnen."
msgstr ""

#: Game.Levels.Babylon.L06_SumComm
msgid ""
msgstr ""

#: Game.Levels.Babylon.L06_SumComm
msgid "**Babylonier**: Schaut mal, da vorn stehen zwei Freunde von mir. Ich muss euch unbedingt vorstellen!\n"
"\n"
"Die beiden Freunde stehen vor zwei Türmen mit einer kleinen Brücke, die zwischen den ihnen verläuft.\n"
"Aber die Tafel am Eingang ist so sehr verwittert, dass sie nicht mehr lesbar ist.\n"
"Auf der oberen Hälfte steht nur folgendes, *in einer Form, die Du verstehst*:\n"
"\n"
"$$\\sum_{i=0}^n\\sum_{j=0}^m a_{ij} = \\sum_{j=0}^m\\sum_{i=0}^n a_{ij}$$\n"
"\n"
"Natürlich fangt ihr an zu rätseln, was darunter stand.\n"
"\n"
"**Robo**: Probier mal, das im lokalen Dialekt zu formulieren."
msgstr ""

#: Game.Levels.Babylon.L06_SumComm
msgid "**Robo**: Das sieht gut aus, aber du solltest das kurz beweisen, um sicher zu sein.\n"
"\n"
"**Du**: Hast du nicht ein Lemma dafür?\n"
"\n"
"**Robo**: Doch, probier mal `sum_comm`."
msgstr ""

#: Game.Levels.Babylon.L06_SumComm
msgid ""
msgstr ""

#: Game.Levels.Babylon.L06_SumComm
msgid "Die drei Babylonier sind begeistert, als ihr ihnen das Stück Papier überreicht,\n"
"  auf das du die Aussage gekritzelt hast. Gleich zückt einer einen Meißel und sie beginnen, eine\n"
"  neue Platte zu erstellen.\n"
"\n"
"  Ihr beschließt, euch noch ein bisschen allein umzusehen."
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid ""
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid "**Du**: Robo, gib mir doch nochmals eine Übersicht, bitte.\n"
"\n"
"**Robo**: Aber klar:\n"
"\n"
"|                      | Beschreibung                              |\n"
"|:---------------------|:------------------------------------------|\n"
"| `Fin n`              | Ist ein Typ mit Zahlen $0, \\ldots, n-1$. |\n"
"| `∑ (i : Fin n), a i` | $\\sum_{i=0}^{n-1} a_i$                   |\n"
"| `↑i`                 | Eine Coersion, z.B. `Fin n → ℕ`.          |\n"
"\n"
"und\n"
"\n"
"|    | Taktik                    | Beispiel                             |\n"
"|:---|:--------------------------|:-------------------------------------|\n"
"| 21 | `simp`                    | Simplifikation.                      |\n"
"| 22 | `induction n`             | Induktion über $n$                   |\n"
"\n"
"Da kommt hinter einem Turm plötzlich ein besonders großer Babylonier hervor, schaut euch\n"
"bedrohlich an und fragt in tiefer Stimme:"
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid "**Du**: Gulp. Naja das wird schon klappen. Also man fängt wieder mit Induktion an …"
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid "**Du**: Also den Induktionsanfang kann man einfach zeigen …"
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid "**Robo**: Und jetzt wieder `rw [sum_univ_castSucc]` und `simp`, um vorwärts zu\n"
"kommen!"
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid "**Robo**: Siehst du die Induktionshypothese hier drin?"
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid "**Du**: Okay, damit habe ich die linke Seite der Gleichung ziemlich gut bearbeitet.\n"
"Aber, ehm, mit der Rechten komme ich nicht weiter …\n"
"\n"
"Der Babylonier schaut dich finster an.\n"
"\n"
"**Du**: Ich will `sum_univ_castSucc` auf der rechten Seite anwenden, aber es gibt mehrere Orte, wo das Lemma passen würde, und ich will es nur an einer bestimmten Stelle anwenden.\n"
"\n"
"**Robo**:\n"
"Mit `rw [sum_univ_castSucc (n := «{n}» + 1)]` kannst du angeben, wo genau.\n"
"\n"
"**Du**: Was bedeutet das?\n"
"\n"
"**Robo** Das Lemma hat eine Annahme `n` und du sagst ihm explizit, was es für dieses `n`\n"
"einsetzen muss, nämlich `«{n}» + 1`"
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid "**Robo**: Das hat jetzt einfach `Fin.sum_univ_castSucc` am ersten Ort angewendet,\n"
"wo das möglich war. Das ist nicht so ideal, die linke Seite war schon okay.\n"
"\n"
"**Robo**: Geh doch zurück und bring `rw` dazu am anderen Ort umzuschreiben."
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid "**Robo**: `add_pow_two` ist auch noch nützlich!"
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid "**Du**: Ich glaube, ich sehe hier eine Gaußsche Summe!!\n"
"\n"
"**Robo**: Ich habe dir das vorhin temporär als `arithmetic_sum` gespeichert.\n"
"Das kannst du jetzt benutzen."
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid "**Du**: Jetzt sollten es eigentlich nur noch arithmetische Operationen sein."
msgstr ""

#: Game.Levels.Babylon.L07_Summary
msgid "Der Babylonier denkt ganz lange nach, und ihr bekommt das Gefühl, dass er gar nie\n"
"aggressiv war, sondern nur eine sehr tiefe Stimme hat.\n"
"\n"
"Mit einem kleinen Erdbeben setzt er sich hin und winkt euch dankend zu."
msgstr ""

#: Game.Levels.Babylon
msgid "Babylon"
msgstr ""

#: Game.Levels.Babylon
msgid "Ihr erreicht einen Planet, auf dem unzählige Steinplatten zu bizzar hohen Türme\n"
"gestapelt sind. Die ganze Landschaft wirkt wie ein grosses Puzzle, in dem jede Platte\n"
"feinsäuberlich auf den darunterliegenden Platten aufbaut. Einige Türme sind so hoch, dass man ihre Spitze gar nicht erkennen kann. Bald trefft ihr auch den ersten Bewohner dieses Planeten an.\n"
"\n"
"**Babylonier**: Willkommen auf *Babylon*!\n"
"\n"
"**Du**: Oh …\n"
"\n"
"Dich beschleicht ein ungutes Gefühl.\n"
"\n"
"**Du**: Seid ihr euch sicher, dass diese Türme stabil sind?\n"
"\n"
"**Babylonier**: 100 Pro!\n"
"\n"
"**Du**: Wie baut ihr denn diese Meisterwerke?\n"
"\n"
"**Babylonier**: Ganz einfach! Ein Stein nach dem anderen."
msgstr ""

#: Game.Levels.Cantor.L00_CantorPowerset
msgid ""
msgstr ""

#: Game.Levels.Cantor.L00_CantorPowerset
msgid "**Cantor**: Wusstet ihr dass es keine surjektiven Funktionen `f : A → Set A` gibt? Faszinierend\n"
"oder?\n"
"\n"
"**Cantor**: Wie das geht? Hier, ist eine kleine Hilfe:"
msgstr ""

#: Game.Levels.Cantor.L00_CantorPowerset
msgid ""
msgstr ""

#: Game.Levels.Cantor.L00_CantorPowerset
msgid "**Du**: Ich denke eine Fallunterscheidung auf `«{a}» ∈ «{f}» «{a}»` könnte sinnvoll sein."
msgstr ""

#: Game.Levels.Cantor.L00_CantorPowerset
msgid "**Robo**: Das wäre `by_cases h₁ : «{a}» ∈ «{f}» «{a}»`."
msgstr ""

#: Game.Levels.Cantor.L00_CantorPowerset
msgid "**Robo**: Mach mal mit `suffices : «{a}» ∉ «{f}» «{a}»` weiter!"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid ""
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Cantor**: Also und jetzt die eigentliche Aussage!"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Du**: Uff. Aber ehrlich habe ich die das \"Diagonale\" daran noch nicht\n"
"ganz gesehen.\n"
"\n"
"\n"
"**Cantor**: Natürlich, das kann ich euch zeigen, aber da muss ich etwas ausholen…"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Du**: Also ein Widerspruchsbeweis?"
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Robo**: als Erinnerung: Wenn du so etwas wie `?f` siehst, bedeutet das, dass\n"
"noch nicht spezifiziert wurde welche Funktion benützt wird. Du hättest besser\n"
"`apply cantor_helper f` geschrieben. Aber du kannst auch einfach mal weitermachen, als ob `?f`\n"
"schon `«{f}»` wäre, und vermutlich wird Lean das irgendwann automatisch einfüllen."
msgstr ""

#: Game.Levels.Cantor.L01_CantorPowerset
msgid "**Cantor**: Wendet doch gleich das Resultat von vorhin an!\n"
"\n"
"**Robo**: Ich hab das als `cantor_helper f` gespeichert."
msgstr ""

#: Game.Levels.Cantor.L02_IsFixedPt_abs
msgid ""
msgstr ""

#: Game.Levels.Cantor.L02_IsFixedPt_abs
msgid "**Du**: Also wie ist das mit der Diagonalen?\n"
"\n"
"**Cantor**: Um das genauer zu erläutern muss ich euch zuerst ein paar rätsel zu Fixpunkten stellen."
msgstr ""

#: Game.Levels.Cantor.L02_IsFixedPt_abs
msgid "**Robo**: `IsFixedPt f x` ist die Aussage `f x = x`.\n"
"\n"
"**Du**: Und `abs` ist der Betrag? Was mache ich damit?\n"
"\n"
"**Robo**: Ich denke so einfache Sachen, die `0` beinhalten kann `simp` ganz gut,\n"
"aber ich habe hier auch noch zwei Resultate, die hilfreich aussehen."
msgstr ""

#: Game.Levels.Cantor.L02_IsFixedPt_abs
msgid ""
msgstr ""

#: Game.Levels.Cantor.L02_IsFixedPt_abs
msgid ""
msgstr ""

#: Game.Levels.Cantor.L03_fixedPoints_neg
msgid ""
msgstr ""

#: Game.Levels.Cantor.L03_fixedPoints_neg
msgid "**Cantor**: Oder schaut hier, die Menge der Fixpunkte von `-(·)` ist ein Singleton."
msgstr ""

#: Game.Levels.Cantor.L03_fixedPoints_neg
msgid "**Du**: `fixedPoints f` ist dann wohl die Menge aller Fixpunkte?\n"
"\n"
"**Robo**: Ja, genau: `fixedPoints f := { x | IsFixedPt f x }`.\n"
"\n"
"**Du**: Welche Optionen habe ich nochmals bei Gleichungen von Mengen?\n"
"\n"
"**Robo** Entweder du brauchst `ext x` um `x ∈ A ↔ x ∈ B` zu zeigen, oder\n"
"du benützt `rw [Subset.antisymm_iff]` um dann `A ⊆ B ∧ B ⊆ A` zu zeigen."
msgstr ""

#: Game.Levels.Cantor.L03_fixedPoints_neg
msgid ""
msgstr ""

#: Game.Levels.Cantor.L03_fixedPoints_neg
msgid ""
msgstr ""

#: Game.Levels.Cantor.L04_IsFixedPt_not
msgid ""
msgstr ""

#: Game.Levels.Cantor.L04_IsFixedPt_not
msgid "**Cantor**: Aber auf was ich eigentlich hinaus wollte, ist die Fixpunkte von `¬` anzuschauen;\n"
"Es gibt nämlich keine!"
msgstr ""

#: Game.Levels.Cantor.L04_IsFixedPt_not
msgid "**Du**: Und was hatten jetzt Fixpunkte mit dem Diagonalargument zu tun?\n"
"\n"
"**Cantor**: Nur Geduld! Ich habe gerade so viel Spaß!"
msgstr ""

#: Game.Levels.Cantor.L04_IsFixedPt_not
msgid "**Du**: Ja, `¬(·)` hat keinen Fixpunkt, keine Aussage kann gleichzeitig\n"
"wahr und falsch sein!"
msgstr ""

#: Game.Levels.Cantor.L05_IsFixedPt_odd
msgid ""
msgstr ""

#: Game.Levels.Cantor.L05_IsFixedPt_odd
msgid "**Cantor**: Zum Beispiel bei ungeraden Funktionen. Da sind die Fixpunkte symmetrisch.\n"
"\n"
"**Du** (*flüsternd zu Robo*): Das hat jetzt wirklich nichts mehr mit der ursprünglichen\n"
"Frage zu tun\n"
"\n"
"**Robo** (*leise*): Na komm schon, wir kommen bestimmt gleich dazu."
msgstr ""

#: Game.Levels.Cantor.L06_idempotent
msgid ""
msgstr ""

#: Game.Levels.Cantor.L06_idempotent
msgid "**Cantor**: Also noch ein letztes Rätsel, dann kommen wir gleich zurück zum\n"
"Diagonalargument.\n"
"\n"
"**Robo**: Oh das sieht anspruchsvoller aus."
msgstr ""

#: Game.Levels.Cantor.L06_idempotent
msgid "**Du**: Etwas womit ich unsicher bin, wie spielt da wohl `«{f}» ∘ «{f}» = «{f}»` mit rein?\n"
"\n"
"**Robo**: Vermutlich willst du das irgendwann auf ein bestimmtes `x` anwenden.\n"
"\n"
"Dafür kannst du irgendwann `apply congr_fun at «{h}»` brauchen, damit\n"
"du `∀ x, («{f}» ∘ «{f}») x = «{f}» x` kriegst."
msgstr ""

#: Game.Levels.Cantor.L06_idempotent
msgid "**Robo**: Wir hatten einmal `Function.comp_apply`!"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag_IsFixedPt
msgid ""
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag_IsFixedPt
msgid "**Cantor**: Genug gerätselt, jetzt aber zum Diagonalargument. Wenn wir eine surjektive\n"
"Funktion `f : A → (A → Y)` haben, dann hat jede Funktion `s : Y → Y` einen Fixpunkt.\n"
"\n"
"**Du**: Und welcher Punkt ist das?\n"
"\n"
"**Cantor**: Gute Frage! Hier, ich geb euch eine Aufgabe um das herauszufinden."
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag_IsFixedPt
msgid "**Cantor**: Diese Aufgabe soll euch vermitteln, wie ihr den Fixpunkt kriegt!"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag_IsFixedPt
msgid "**Du**: Also ist der Fixpunkt dieses diagonale Element `f b b`, für ein `b`\n"
"  das irgendwie aus der Surjektivität kommt…\n"
"\n"
"  **Cantor**: Und damit auf zum Hauptsatz!"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid ""
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Cantor**: Viel Glück!"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Du**: Jetzt möchte ich aber mit dieser generellen Form, die ursprüngliche\n"
"Aufgabe nochmals lösen."
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Cantor**: Mit der Aufgabe vorhin könnt\n"
"ihr sicher herausfinden, was das richtige `c : A → Y` ist, auf das ihr die Surjektivität\n"
"anwenden wollt."
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Robo**: So viel weiss ich: die Funktion\n"
"definieren wir mit\n"
"\n"
"```\n"
"let c : A → Y := fun a ↦ _\n"
"```\n"
"\n"
"aber den Wert musst schon du herausfinden!"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Cantor**: Gute Wahl!"
msgstr ""

#: Game.Levels.Cantor.L07_CantorDiag
msgid "**Cantor**: Das sieht gut aus, jetzt können wir ja\n"
"`cantor_diagonal_isFixedPt` von vorhin brauchen!"
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid ""
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Du**: Und wie hängt das jetzt damit zusammen, dass es keine Surjektive Funktion\n"
"`f : A → Set A` gibt?\n"
"\n"
"**Cantor**: Ganz einfach, nehmt `s` als die Funktion `fun x ↦ ¬ x`.\n"
"\n"
"**Robo**: In Lean kann man nämlich eine Menge `U : Set A` mit dem Prädikat\n"
"`{ x : A | x ∈ U } : A → Prop` gleichsetzen, die sind per Definition dasselbe.\n"
"Damit kann man `f : A → Set A` auch als `f : A → A → Prop` sehen.\n"
"\n"
"**Du**: Und `{ a | a ∉ f a }` ist `s (f a a)` für `s : (fun x ↦ ¬ x)`, alles klar."
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Cantor**: Ein Widerspruchsbeweis ist die Kür der Mathematik."
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Du**: Also hier jetzt `cantor_diagonal` verwenden?"
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Robo**: Zum Beispiel mit `apply cantor_diagonal at «{h}»`!"
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Cantor**: Nein, nein! Wir wollten doch\n"
"mein schönes Theorem `cantor_diagonal` verwenden!"
msgstr ""

#: Game.Levels.Cantor.L08_CantorPowerset
msgid "**Cantor**: Wir hatten doch geübt, dass `¬(·)` keinen Fixpunkt hat.\n"
"\n"
"**Robo**: Das habe ich als `not_isFixedPt_not` gepspeichert"
msgstr ""

#: Game.Levels.Cantor
msgid "Cantor"
msgstr ""

#: Game.Levels.Cantor
msgid "Auf eurer Reise kommt ihr an einem Zwergplaneten vorbei. Darauf steht ein Haus mit unendlich vielen\n"
"Türen auf jeder Seite. Ihr macht euch einen Spass daran von einem Ecken aus gleichzeitig Türen\n"
"aufzutun und zu beobachten wie sich dein Schatten mit dem von Robo kreuzt.\n"
"\n"
"Dann entdeckt ihr einen Mann, der draussen sitzt. In der Hand hält er eine Schriftrolle\n"
"auf der unendliche Zahlenfolgen geschrieben sind, und die Rolle scheint in einem riesigen\n"
"Haufen ausgerolltem Papier zu enden.\n"
"\n"
"Die Person stellt sich euch als Cantor der Magier vor."
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "Den Spuren folgend, findet ihr ein Stück Pergament, auf dem zuoberst\n"
"eine Notiz steht.\n"
"\n"
"```\n"
"E i j := stdBasisMatrix i j (1 : ℝ)\n"
"```\n"
"\n"
"Darunter ein bisschen wildes Gekritzel, das aber deutlich mit einer klaren\n"
"Zeile angefangen hat:"
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "`E i j` ist die `n × n`-Matrix (mit Werten in `ℝ`) mit einer `1` an\n"
"Stelle $(i, j)$ und null überall sonst.\n"
"\n"
"Bemerkung: Dies ist eine spezialisierte Form der generellen `stdBasisMatrix i j (a : R)`,\n"
"welche auch nicht-quadratisch sein kann und einen beliebigen Wert `a` aus einem beliebigen\n"
"Ring annehmen kann.\n"
"\n"
"Das Spiel bevorzugt `E`, um die Lesbarkeit zu erhöhen."
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "**Du**: Welches Wesen auch immer hier Spuren hinterlassen hat – mir scheint, es mag Matrizen. Was meints du?\n"
"\n"
"**Robo**: Ja! `stdBasisMatrix i j a` kenne ich, das ist die Matrix, die an der Position `(i, j)` den Eintrag `a` hat und sonst überall Null ist.\n"
"\n"
"**Du**: Und die `E`s sind dann einfach eine Abkürzung für den Fall `a = 1`?\n"
"\n"
"**Robo**: So sieht's aus. Und `A i j` ist einfach der Eintrag der Matrix `A` an der Position `(i, j)`.\n"
"\n"
"**Du**: Ah, verstehe. Da steht also kein Produkt von Matrizen, sondern nur eine Skalarmultiplikation. Etwas in der Art von …\n"
"\n"
"Du kritzelst auf das Papier:\n"
"\n"
"$$\n"
"A_{i,j} \\cdot\n"
"\\begin{pmatrix}\n"
"0 & 0 & 0\\\\\n"
"1 & 0 & 0 \\\\\n"
"0 & 0 & 0\n"
"\\end{pmatrix}\n"
"=\n"
"\\begin{pmatrix}\n"
"0 & 0 & 0\\\\\n"
"A_{i,j} & 0 & 0 \\\\\n"
"0 & 0 & 0\n"
"\\end{pmatrix}\n"
"$$\n"
"\n"
"**Du**: Dann ist das ja mal wieder… …offensichtlich!?\n"
"\n"
"**Robo**: Ja. Ich denke, wenn du mit `unfold E` anfängst, geht der Rest wie von selbst."
msgstr ""

#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "**Du**: Und was machen wir jetzt mit dieser „Erkenntnis“?\n"
"\n"
"**Robo**: Keine Ahnung.  Ich speichere das jedenfalls mal als `Matrix.smul_ebasis` ab, falls wir es nochmals\n"
"brauchen.\n"
"\n"
"Damit folgt ihr weiter der Spur."
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid "Kurze Zeit später findet ihr zwei sehr ähnlichen Zettel, wieder\n"
"vollgekritzelt, fast alles durchgestrichen.\n"
"Die erste Zeile aber lässt sich jeweils gerade noch ausmachen."
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid "**Robo**: Ich speichere dieses `E.mul_of_ne` auch mal, wer weiß.\n"
"\n"
"  **Du**: Jetzt bin ich aber neugierig, wer diese Zettel hier verloren oder weggeworfen hat. Komm, lass uns weitergehen."
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid "**Du**: Das sieht jetzt aber nach Matrizen-Multiplikation aus.\n"
"Müsste so auch stimmen."
msgstr ""

#: Game.Levels.Robotswana.L02_EBasis
msgid "**Robo**: Vergiss aber nicht, dass `simp` die Annahme `«{h}»` explizit braucht!"
msgstr ""

#: Game.Levels.Robotswana.L03
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L03
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L03
msgid "**Du**: Jetzt bin ich aber neugierig, wer diese Zettel hier verloren oder weggeworfen hat. Komm, lass uns weitergehen."
msgstr ""

#: Game.Levels.Robotswana.L03
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L03
msgid "**Du**:  Sieht auch richtig aus."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Ihr kommt an eine Stelle, wo das Gras auf einer größeren, quadratischen\n"
"Fläche heruntergetrampelt ist. Spuren führen kreuz und queer und in verschiedene\n"
"Richtungen weg.\n"
"\n"
"Ein bisschen planlos sucht ihr die Stelle ab und findet verschiedenste Pergamentstücke.\n"
"Die meisten sind leer oder unleserlich, aber eines kannst du entziffern."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Du beschließt, einer besonders markanten Spur zu folgen. Robo zieht dir hinterher und schnappt\n"
"sich beim gehen noch ein willkürliches Stück Pergament vom Boden."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Sagt aus, dass man jede $(n × n)$-Matrix (über $\\mathbb{R}$) $A$ schreiben kann\n"
"als $A = \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} A_{ij} \\cdot E(i, j)$.\n"
"\n"
"Siehe auch `matrix_eq_sum_std_basis`, welches die generalisierte Form für\n"
"$(m × n)$-Matrix (über beliebigem $R$) ist."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Die generellere Version von `matrix_eq_sum_ebasis`. Siehe dort."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "**Du**: Das scheint einfach zu sagen, dass diese `E i j` ein Erzeugendensystem für den Raum der Matrizen bilden.\n"
"\n"
"**Robo**: Da kannst du bestimmt gleich die Resultate anwenden, die wir schon gefunden haben!"
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "**Robo**: Schau zuerst den Ausdruck `(A i j) • E i j` an. Unter Summen braucht man `simp_rw`."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "**Robo**: Ja gut, du kannst auch einfach den Beweis vom ersten Pergament wiederholen.\n"
"Nur zu, Übung macht den Meister.\n"
"\n"
"**Du**: Schon gut, ich hab kein mechanisches Hirn wie du."
msgstr ""

#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "**Robo**: Ach ja!  So wie es jetzt hier steht, kenne ich die Aussage aus meiner Bibliothek.\n"
"Das ist genau `apply matrix_eq_sum_std_basis`.\n"
"\n"
"**Du**: Super! Dann brauchen wir uns ja gar nicht damit aufhalten."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Du**: Zeig mal, was hast du da? Was zur Einheitsmatrix? Passend für unsere Sammlung?\n"
"\n"
"**Robo**: Ja, schau. Ich glaube, hier kannst Du gleich mit `matrix_eq_sum_ebasis` beginnen.\n"
"\n"
"**Du**: Ich frage mich, ob wir noch wichtiges auf dem Platz zurückgelassen haben?\n"
"\n"
"**Robo**: Egal, jetzt sind wir schon ein gutes Stücken weiter. Probier jetzt hier einmal!"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Du**: Ich habe das Gefühl, wir sind jemandem auf der Spur, der sich für die\n"
"die Diagonale von Matrizen interessiert.  Aber ich bekomme langsam Durst!"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Du**: Ich denke, die beiden Summen sind identisch, weil jeder Summand identisch ist.\n"
"Denkst du das funktioniert ähnlich wie mit den Funktionen, da bei dieser Bibliothek?\n"
"\n"
"**Robo**: Erinnerst du dich an `congr_arg`? Das zeigt hier, dass die beiden Summen gleich sind,\n"
"falls der innere Teil für jeden Index gleich ist."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Du**: und jetzt `funext` um Indices anzunehmen?"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Du**: Oh, jetzt habe ich nicht nur den Summationsindex, sondern auch noch die beiden\n"
"Indices `«{r}»,«{s}»` der Matrizen eingeführt. Aber das sollte passen. Nur… die verbleibende Summe\n"
"ist ja überall Null außer beim Index `«{i}»`.\n"
"\n"
"**Robo**: Ist das so? Lass mich mal suchen… Zeig mal zuerst `have h : {«{i}»} ⊆ univ`!"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Robo**: …jetzt kannst du nämlich `sum_subset` anwenden, welches du schon kennst."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Du**: Danke, das hilft! Dieser Schritt sollte einfach sein: Eine Summe über ein Element,\n"
"bei diesem ist `1 «{i}» «{i}»` wieder Eins, und `1 • _` vereinfacht sich auch!"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Robo**: `simp` klingt wirklich nach einer guten Idee."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Du**: Aber was mache ich hier? `«{h₂}»` sagt ja mehr oder weniger dass `«{i}» ≠ «{x}»` ist.\n"
"\n"
"**Robo**: Ja, aber nicht ganz. Führ das doch mit `have h₃ : «{i}» ≠ «{x}»` ein und zeig das kurz!"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Robo**: Umgekehrt wäre es nützlicher, da\n"
"`1 «{i}» «{x}»` als `if «{i}» = «{x}» then _ else _` definiert ist!\n"
"\n"
"**Du**: Du hast recht, ich brauch gleich `«{i}» = «{x}»` oder `«{i}» ≠ «{x}»`. Lass mich das ändern."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Du**: Als erstes würde ich mal schauen, ob sich `«{h₂}»` vereinfacht."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Du**: Hmm, jetzt ist das erstmal verdreht.\n"
"\n"
"**Robo**: Erinnere dich an `symm`!\n"
"\n"
"**Du**: Richtig, das brauchten wir ja schon bei diesem wilden Typen mit seinen Förderbändern."
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Du**: Wie setze ich denn jetzt die Definition für `1 «{i}» «{x}»` ein?\n"
"\n"
"**Robo**: `Matrix.one_apply`!"
msgstr ""

#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "**Robo**: Und da das falsch ist, kannst du mit `rw` und `if_neg` weiterkommen."
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "Der Spur folgend kommt ihr an einem großen Baum. Im Schatten findet ihr ein regloses Etwas:\n"
"\n"
"$$\n"
"[A, B] = AB - BA\n"
"$$\n"
"\n"
"**Robo**:  Ach ja, ein Kommutator!\n"
"\n"
"**Du**: Der sieht aber ziemlich nihiliert aus.  Ich glaube, der ist verdurstet.\n"
"\n"
"**Robo**: Und schau, hier ist noch was in den Baum gekritzelt."
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "**Robo**: Ich glaube, die Annahme, dass Kommutatoren nihiliert werden, nehmen wir jetzt erst\n"
"einmal mit.\n"
"\n"
"**Du**: Schön.  Sagte ich bereits, dass ich langsam Durst habe?"
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "**Du**: Mit anderen Worten: Wenn `f` Kommutatoren nihiliert, dann stimmen seine Werte\n"
"auf allen `E i i` überein. Stimmt das??\n"
"\n"
"**Robo**: Lass es uns herausfinden!"
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "**Du**: Aber was soll ich denn mit unserer Annahme `«{h₁}»` anfangen!\n"
"Ich müsste überhaupt erst einmal eine Multiplikation haben.\n"
"\n"
"**Robo**: Du müsstest ein Matrizenprodukt `A * B` finden, für das  `f (E i i) = f (A * B) = f (E j j)` gilt.\n"
"Dann könnstest du `trans f (A * B)` schreiben, um zwei Beweisziele – `f (E i i) = f (A * B)` und `f (A * B) = f (E j j)` – zu erhalten,\n"
"bei denen `«{h₁}»` vielleicht anwendbar ist."
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "**Robo**: Hatten wir nicht `E i k = (E i j) * (E j k)` auf einem dieser Zettel?"
msgstr ""

#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "**Robo**: Hast du das nicht alles gemacht, weil du `«{h₁}»` brauchen\n"
"wolltest?\n"
"\n"
"**Du**: Ah ja, stimmt!"
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "Gleich neben dem Baum findest du noch eine Notiz, in der groß `E i j` durchgestrichen ist.\n"
"\n"
"**Du**: Soll wohl heißen: `E i j` mit i ≠ j interessieren uns nicht."
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "Die Spuren wirken mittlerweile viel frischer und ihr folgt ihnen schneller und\n"
"unvorsichtiger als zuvor."
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "**Robo**: Wie könnten wir denn hier `«{h₁}»` verwenden?\n"
"\n"
"**Du**: Wie wär's, wenn wir diesmal `E i j` als Produkt `E i j * E j j` schreiben?\n"
"\n"
"**Robo**:  Wieso gerade so?\n"
"\n"
"**Du**: Wenn ich in diesem Produkt die Faktoren vertausche, erhalte ich Null!  Hatten wir doch auch schon, `E.mul_of_ne` oder so etwas."
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "**Robo*: Wie du meinst. Dann probier doch am besten `trans f (E i j * E j j)`."
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "**Du**: Ehm, das sehe ich einfach von der Definition.\n"
"\n"
"**Robo**: Vergiss nicht `unfold E`, oder sag `simp`, dass es die Definition von `E` benutzen soll (`simp [E]`)."
msgstr ""

#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "**Robo**: Und hier wolltest du jetzt kommutieren?\n"
"\n"
"**Du**: Genau!"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Ihr findet nochmals einen Hinweis, aber in der Eile verliert ihr die Fährte.\n"
"Du bist inzwischen sehr durstig.\n"
"Während Robo die nähere Umgebung absucht, setzt du dich erschöpft hin und\n"
"starrst unter der warmen Sonne etwas beduselt auf den Pergamentfetzen."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Du**: Na endlich.\n"
"\n"
"Robo reicht dir eine Flasche Wasser.\n"
"\n"
"**Du**: Wo hast du die denn auf einmal her?\n"
"\n"
"**Robo**: Trick 17.\n"
"\n"
"**Du**:  Und hast du die Fährte wiedergefunden?\n"
"\n"
"**Robo**:  Ja, komm mit! Da hinten hab ich etwas gesehen."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Du**: Was das wohl jetzt soll …?\n"
"\n"
"Du kritzelst einen bisschen herum.\n"
"\n"
"$$\n"
"\\begin{aligned}\n"
"f(A)\n"
"&= f\\left( \\sum_{i,j} A_{i,j} ⬝ E_{i,j} \\right) \\\\\n"
"&= \\sum_{i,j} A_{i,j} ⬝ f(E_{i,j})   \\\\\n"
"&= \\sum_{i,j} A_{i,i} ⬝ f(E_{i,i})\n"
"\\end{aligned}\n"
"$$\n"
"\n"
"**Du**: Ja, so könnte das gehen.  Ich schreibe `A` als Summe von Basismatrizen,\n"
"nutze dann die Linearität, und zuletzt, dass `f` auf den `E i j` mit `i ≠ j` verschwindet.\n"
"\n"
"Vermutlich sollte ich also als erstes das `A` in `f A` als Summe von Basismatrizen\n"
"schreiben, nicht aber das andere `A` weiter hinten.\n"
"\n"
"**Robo** (*aus der Ferne*): `nth_rw 1 [ ... ]`! Funktioniert wie `rw`."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Du** (*schreiend*): Was meinst du damit?\n"
"\n"
"**Robo** (*ebenfalls schreiend*): Na, du willst bestimmt `matrix_eq_sum_ebasis A` anwenden, aber mit `nth_rw 1` und nicht mit `rw`.\n"
"`rw [matrix_eq_sum_ebasis A]` würde beide `A`s ersetzen."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Du**: Hmm, `rw` ist tatsächlich eine schlechte Idee.\n"
"Das sieht zu kompliziert aus. Lass es mich doch mit `nth_rw` versuchen."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Du** (*in Gedanken*): Jetzt Linearität nutzen… Und ja nicht an Wasser denken…\n"
"Auf Babylon gabs genug Wasser… Woran war ich nochmals?"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo** (*von irgendwo*): Das klingt nach `map_sum`.  Glaub nicht, dass wir\n"
"das auf Babylon gesehen haben, das fantasierst du. Aber `simp` kennt dieses Lemma bestimmt."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Du**: Ah ja, im Zweifelsfall vereinfachen."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo*: Wie weit bist du jetzt?\n"
"\n"
"**Du**: Ich muss noch irgendwie einbringen, dass `f` auf den `E i j` mit `i≠j` verschwindet.\n"
"\n"
"**Robo**: Mach doch folgenden Zwischenschritt:\n"
"\n"
"`trans ∑ i, ∑ j, if i = j then (A i j) * f (E i j) else 0`"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo**: Summe gleich Summe … das gehst du mit `apply congr_arg`, `ext` an."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Du**: Vielleicht gleich nocheinmal?"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Du**: Und jetzt Fallunterscheidung zu `«{i}» = «{j}»`…"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo**: `by_cases` war das, genau!"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo**: Hier ist `if_pos «{h₂}»` nützlich."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo**: …und hier `if_neg «{h₂}»`.\n"
"\n"
"**Du**: Weiß ich doch."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Du**: `f (E i j)` ist doch Null, hatten wir doch schon gesehen!"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Robo**: Und das hieß `zero_on_offDiag_ebasis`."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "**Du**: Und ich dachte schon das wär's.\n"
"\n"
"**Robo**: Fast, da ist noch die zweite Hälfte des `trans`-Befehls oben. Diese Hälfte\n"
"ist ganz einfach."
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Lineare Abbildungen (oder genereller \"additive\" Abbildungen) kann man mit einer\n"
"Summe vertauschen."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Keine fünfzig Meter weiter kommt ihr auf eine kleine Anhöhe.\n"
"Robo zeigt auf einen Punkt in der Ferne.\n"
"\n"
"**Robo**: Schau mal, da liegt es!\n"
"\n"
"**Du**: Und was *ist* das???\n"
"\n"
"**Robo**:  Weiß nicht.  Aber mein Gefühl sagt mir, diese Zettel sind eine Art Steckbrief.  Schau mal, hier ist noch einer.  Ich glaube, der sagt, wie groß es ist."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Du**: Okay. Lass uns vorsichtig näher gehen."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Du überlegst ein bisschen und kritzelst auf dem Papier herum.  Nach einer Weile:\n"
"\n"
"**Du**: Ich glaube, ich habe eine Idee! Das `(«{n}» + 1)`-fache der Gleichung kann ich mit den vorherigen Resultaten wie folgt nachrechnen:\n"
"$$\n"
"\\begin{aligned}\n"
"(n+1) \\cdot f(E_{i i})\n"
"&= \\sum_j f(E_{i i}) \\\\\n"
"&= \\sum_j f(E_{j j}) \\\\\n"
"&= f(1) \\\\\n"
"&= n + 1\n"
"\\end{aligned}\n"
"$$\n"
"\n"
"Der wesentlich Punkt ist, dass wir ja gesehen hatten, dass `f E i i` und `f E j j` für beliebige `i` und `j` gleich sind.  Also sind sie in der Summe austauschbar.\n"
"\n"
"**Robo**: Mmm.  Du willst jedenfalls zunächst ausnutzen, dass Multiplikation mit `(«{n}» + 1)` injektiv ist?\n"
"Hatten wir dazu nicht mal ein Lemma? Mmm …\n"
"\n"
"Robo überlegt eine Weile.\n"
"\n"
"**Robo**:  Ich würds mal so versuchen:\n"
"```\n"
"suffices h : (succ n) * f (E i i) = (succ n : ℝ)*1\n"
"```\n"
"Und dann weiter mit `mul_eq_mul_left_iff`."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**:  `succ n ≠ 0`? Das kann bestimmt `omega` lösen …\n"
"… außer, dass hier noch eine Einbettung von ℕ nach ℝ versteckt ist.\n"
"Vielleicht probierst du erst einmal `rw [cast_eq_zero] at «{h}»`?"
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: Wenn ich dich richtig verstanden haben, willst du jetzt mehrmals `trans` anwenden, als erstes\n"
"`trans ∑ j : Fin n.succ, f (E i i)`."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: Oh, das ist jetzt aber nicht das, was du eben aufgeschrieben hattest.\n"
"Könnte aber auch funktionieren.\n"
"Probier mal `trans «{f}» (∑ j : Fin «{n}».succ, E «{i}» «{i}»)` als nächsten Schritt."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Du**: Genau, jetzt müssen wir für diese erste Gleichheit nur die konstante Summe ausrechnen.\n"
"\n"
"**Robo**: `simp [E]` kann das sicher komplett vereinfachen."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Du**: Als nächstes ziehen wir die Funktion in die Summe rein."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Du**: Und jetzt möchte ich die Gleichung durch einen Zwischenschritt\n"
"`«{f}» (∑ x, E x x)` zeigen."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Du**: Nein, das ist jetzt mathematisch falsch!"
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: Jetzt wieder `congr`-`ext`?\n"
"\n"
"**Du**: Nein, zuerst, die Funktion in die Summe rein, sonst klappt das nicht."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Du**: Nochmals!"
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Du**: Und das war ein Resultat, welches wir auf dem Weg gefunden haben."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: `eq_on_diag_ebasis` sagt meine Speicherplatte."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: Das sieht nach `ebasis_diag_sum_eq_one` aus."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: Das hatten wir schon gesehen."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: Das Resultat, das du hier anwenden wolltest, hieß `eq_sum_apply_diag_ebasis`."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "**Robo**: Probier mal `rw [«{h₂}»]`."
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "Ihr schleicht euch langsam an.\n"
"\n"
"**Du** (**flüsternd**): Ich glaube, du hattest Recht.  Diese Zettel sind eine Art Steckbrief!\n"
"Und sie beschreiben dieses Wesen hier eindeutig!\n"
"\n"
"**Robo**: Wie meinst du das?\n"
"\n"
"**Du**: Schau doch, seine Größe, seine Vorliebe für Kommutatoren, und all die anderen Sachen,\n"
"damit kann es eindeutig identifiziert werden kann!\n"
"\n"
"**Robo**: Das musst du mir genauer erklären.\n"
"\n"
"**Du**:  Ich versuch's mal. Gibt es in Leansch einen Namen für die Spur?\n"
"\n"
"**Robo**: Ja klar, die heißt natürlich `trace`.  Manche Formalosophen nennen sie auch liebevoll Tracy.\n"
"\n"
"Du nimmst einen der Pergamentfetzen und schreibst auf die Rückseite."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: Tatsache. Du hattest Recht.\n"
"\n"
"Ihr beobachtet voller Entzücken dieses offenbar einzigartige Wesen auf diesem Planeten.\n"
"\n"
"Als ihr näher kommt, scheint euch Tracy zu bemerken.  Aber es scheint dadurch keinesfalls gestört\n"
"zu sein."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Du**:  Hier sind noch einmal alle Eigenschaften zusammengefasst.\n"
"\n"
"**Robo**:  Und du behauptest, nur Tracy hat diese Eigenschaften?\n"
"\n"
"**Du**: Ja.  Ich glaube, das ist so.  Jedes `f`, dass diese Eigenschaften hat, verhält sich auch allen Matrizen genauso wie Tracy.  Und deshalb *ist* es Tracy!"
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: `ext`!"
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Du**: Und jetzt schreiben wir `f A` als Summe von Basiselementen."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: Den Fall `n = 0` sehe ich sofort!\n"
"\n"
"**Du**: Wirklich?\n"
"\n"
"**Robo**: Ja, die Spur einer 0×0-Matrix ist per Definition `0`. Mach mal `obtain ⟨⟩ := n`.\n"
"\n"
"**Du**: Nicht `induction n`?\n"
"\n"
"**Robo**: Geht auch, aber wir brauchen die Induktionshypothese nicht."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: Ich hab im Kopf mal `simp` ausprobiert. Probier es auch mal."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Du**: Wir hatten doch eben festgestellt, dass `f (E i i) = 1` gilt!\n"
"\n"
"**Robo**: Nachschlagen kann ich gut! Das war `one_on_diag_ebasis`."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: Denk daran, unter einer Summe must du `simp_rw` verwenden,\n"
"`rw` kann das nicht.\n"
"\n"
"**Du**: Ah, und die expliziten Argumente `h₁` und `h₂` sollte ich wohl auch noch angeben?"
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Du** `_ * 1` ist `simp`, oder?"
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Robo**: Die beiden Seiten sind per Definition gleich!"
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "**Du**: Wo kommt denn dieses Beweisziel jetzt noch her?\n"
"\n"
"**Robo**: Ganz am Anfang bei `rw [eq_sum_apply_diag_ebasis]` hast du vermutlich dieses Argument\n"
"ausgelassen.  Jetzt kannst du es noch nachholen."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "Nicht genau definiert als, aber per Definition äquivalent zu:\n"
"`trace A = ∑ i, A i i`.\n"
"\n"
"Mathlib benutzt den Term `diag A i` auf den wir hier nicht genauer eingehen."
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid "Als ihr mit etwas Abstand stehen bleibt, kommt Tracy auf euch zugelaufen und fängt an zu spielen. Belustigt gibt es euch verschiedenste\n"
"Aufgaben und Terme, und ihr versucht, diese schnell genug zu kombinieren."
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid "Schließlich macht ihr euch auf den Rückweg.\n"
"Ihr verlauft euch sofort, aber Tracy ist euch offenbar gefolgt und führt euch quer durch\n"
"die Grasslandschaft zurück zu eurem Schiff."
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid "**Du**: Da geht es gerade offensichtlich um Linearität der Spur von Matrizen."
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid "**Robo**: Dieser letzte Schritt ist `card_fin`. Das ginge auch alles\n"
"mit `simp` wenn wir nicht am spielen wären.\n"
"\n"
"**Du**: Ist doch egal, das macht Spass!"
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid ""
msgstr ""

#: Game.Levels.Robotswana
msgid "Robotswana"
msgstr ""

#: Game.Levels.Robotswana
msgid "Ihr landet auf einem warmen Planeten, und tretet auf eine weite Graslandschaft hinaus.\n"
"\n"
"Nach etwas Umschauen entdeckt Robo Spuren, die von eurem Landeplatz wegführen, zwischen\n"
" vereinzelten Bäumen hindurch. Ihr beratet kurz und beschließt, den Spuren zu folgen."
msgstr ""

#: Game.Levels.Ciao.L01
msgid ""
msgstr ""

#: Game.Levels.Ciao.L01
msgid ""
msgstr ""

#: Game.Levels.Ciao.L01
msgid "**Du**: Das war ja nun nicht so schwer …  Wer die wohl gesendet hat?  Und warum?\n"
"\n"
"**Robo**:  Das war sicher eine Nachricht von Ritha …\n"
"\n"
"Robo schaut in die Ferne.\n"
"\n"
"**Robo**:  Ich glaube, sie wollte uns ermuntern, weiter zu fliegen.\n"
"\n"
"**Du**: Aber wohin?\n"
"\n"
"**Robo**:  Oh, schau mal, noch eine Nachricht:\n"
"\n"
"*Liebe Erdwesen,*\n"
"\n"
"*es war uns ein Vergnügen, euch kennenzulernen!\n"
"Es tut uns aufrichtig leid, dass ihr euch in unser Formaloversum verirrt habt und\n"
"nicht wieder nach Hause findet.  Aber wir haben noch eine gute Nachricht:\n"
"Ihr seid nicht die einzigen!\n"
"Fliegt nur rasch weiter zum Planeten Zulip.\n"
"Dort werdet ihr viele weitere Erdwesen finden, die sich ins Formaloversum verirrt haben.\n"
"Zulip ist groß, gewiss werdet auch ihr dort ein neues Zuhause finden.  Hier die Koordinaten:*\n"
"\n"
"[248-4804-180 | 844-1001-553](https://leanprover.zulipchat.com/#narrow/channel/113489-new-members/)\n"
"\n"
"*Mit den aufrichtigsten Grüßen*\n"
"\n"
"*– Eure Formalosophen*\n"
"\n"
"**Robo**:  Na dann – los!\n"
"\n"
"[Nicht wundern:  Wenn ihr den Koordinaten folgt, beschleunigt das Raumschiff auf\n"
"Überlichtgeschwindigkeit und ihr verliert vorübergehend den Kontakt zum Server.\n"
"Das macht aber nichts.  Ihr werdet sicher auf Zulip ankommen.]"
msgstr ""

#: Game.Levels.Ciao
msgid "Ciao"
msgstr ""

#: Game.Levels.Ciao
msgid "**Du**:  Kann es sein, dass wir jetzt alle Planeten in dieser Ecke dieses Universums besucht haben?\n"
"\n"
"**Robo**:  Ja, sieht so aus.\n"
"\n"
"**Du**:  Was machen wir jetzt?\n"
"\n"
"**Robo:** Keine Ahnung.\n"
"\n"
"Nach einer Weile …\n"
"\n"
"**Robo:** Du, schau mal, hier ist eine Nachricht reingekommen."
msgstr ""

#: Game.Levels.Prado.L01_prime_two
msgid ""
msgstr ""

#: Game.Levels.Prado.L01_prime_two
msgid "**Robo**:  Ja, ja.  Wissen wir.\n"
"\n"
"Er formuliert die Aussage schnell in Leansch und hält sie dir hin."
msgstr ""

#: Game.Levels.Prado.L01_prime_two
msgid ""
msgstr ""

#: Game.Levels.Prado.L01_prime_two
msgid "**Robo** *(flüsternd)*:  Das ist ganz einfach.  Weil `2` eine konkrete Zahl ist\n"
"und es einen Algorithmus gibt, um zu entscheiden, ob eine Zahl prim ist, kannst du einfach `decide` verwenden!"
msgstr ""

#: Game.Levels.Prado.L01_prime_two
msgid "**Du**:  In der Tat.  Wissen wir.  Und was gibt es noch für Exponate?\n"
"\n"
"Guino  wird etwas verlegen.\n"
"\n"
"**Guino**:  Nun, wie gesagt, wir haben gerade erst geöffnet.\n"
"Und wir hatten uns entschieden, zunächst nur die allerschönsten Primzahlen auszustellen:\n"
"die geraden. Momentan ist die `2` unser einziges Exponat.\n"
"Aber wir arbeiten mit Hochdruck daran, weitere gerade Primzahlen für unsere Dauerausstellung zu finden."
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid ""
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**Du** *(flüsternd)*: Robo, meinst du, wir sollen es ihm sagen?\n"
"\n"
"**Robo**: Dass `2` die einzige gerade Primzahl ist?\n"
"Er wird es nicht glauben wollen, solange wir ihm keinen Beweis präsentieren.\n"
"\n"
"**Du**:  Und meinst du nicht, wie können das zeigen?  Du kennst doch die Sprache.\n"
"Lass uns mal probieren.  Wie schreib ich zum Beispiel „`a` teilt `b`“?\n"
"\n"
"**Robo**: Na schön. Also  „`a` teilt `b`“ schreibst du als `a ∣ b`, wobei du den senkrechten Strich\n"
"  als `\\|` oder `\\dvd` schreiben musst.  Probier zum Beispiel mal diese Aufgabe hier."
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**Robo**: Definiert ist `a ∣ b` natürlich als `∃ k, b = a * k`.\n"
"Am besten schreibst du das für den Anfang überall explizit aus:\n"
"```\n"
"rw [dvd_iff_exists_eq_mul_left] at *\n"
"```"
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**Du**:  Und jetzt mache ich mit `obtain` und `use` weiter?\n"
"\n"
"**Robo**: Genau.  Als nächstes nimmst du die Annahmen mit `obtain ⟨x ,hx⟩ := _`\n"
"usw. auseinander."
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**Robo**: Jetzt musst du mit `use _` eine Zahl angeben, sodass\n"
"`«{b}» + «{c}» = «{a}» * _` gilt."
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**Robo**: Mit ein bisschen umschreiben kann man sicher `ring` verwenden."
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "`a ∣ b` bedeutet `∃ k, b = a * k`.\n"
"\n"
"**Warnung**: Die Symbole `∣` (`\\\\dvd`) und `|` (ASCII vertikaler Strich) sind zwei unterschiedliche\n"
"Zeichen! Das erste wird ausschließlich für „teilt“ verwendet, das andere kommt zum Beispiel in der\n"
"Syntax `obtain h₁ | h₂ := h` vor."
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid ""
msgstr ""

#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "**Guino**:  Was flüstert ihr denn da?\n"
"\n"
"**Du**:  Ach, nichts.  Robo versucht mich nur daran zu erinnern, was genau eine Primzahl ist.\n"
"\n"
"Guino schaut sich euern Beweis an.\n"
"\n"
"**Guino**: Nicht schlecht, nicht schlecht.  Aber lasst uns doch ein bisschen weitergehen.\n"
"Das Museum ist zwar noch leer, aber fertig.  Und es ist wirklich gut geworden.  Schaut mal, hier entlang!"
msgstr ""

#: Game.Levels.Prado.L03_even_iff_two_dvd
msgid ""
msgstr ""

#: Game.Levels.Prado.L03_even_iff_two_dvd
msgid "Während ihr Guino durch das Museum folgt, gibt dir Robo weitere Aufgaben."
msgstr ""

#: Game.Levels.Prado.L03_even_iff_two_dvd
msgid ""
msgstr ""

#: Game.Levels.Prado.L03_even_iff_two_dvd
msgid "**Robo**:  Fang doch noch einmal mit `rw [dvd_iff_exists_eq_mul_left]` an!"
msgstr ""

#: Game.Levels.Prado.L04_99
msgid ""
msgstr ""

#: Game.Levels.Prado.L04_99
msgid "Guino wirkt inzwischen ein wenig irritiert, dass ihr gar keinen Augen für sein tolles Museum habt.\n"
"Er fühlt sich ignoriert. Um eure Aufmerksamkeit zu bekommen, gibt er euch folgende Aufgabe."
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid ""
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid "**Du** *(zu Robo)*:  Gib mir mal wieder etwas Interessanteres!\n"
"\n"
"**Robo**:  Wie wäre es hiermit?"
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid ""
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid "**Du**: `by_contra`?\n"
"\n"
"**Robo**:  Das könnte funktionieren.\n"
"Und wahrscheinlich wirst du das Lemma `lt_of_mul_lt_mul_left` brauchen.\n"
"Für `a b c : ℕ` zieht es aus der Annahme `a * b < a * c` den Schluss `b < c`."
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid ""
msgstr ""

#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid ""
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid ""
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**Du**:  Gut.  Und kannst du mir jetzt zeigen, wie man mit Primzahlen arbeitet?\n"
"\n"
"**Robo**: Mal sehen, ob ich eine Aufgabe zu Primzahlen auf Lager habe … Diese hier vielleicht?"
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**Robo**: Hier ist `(hp : Prime p)` natürlich die Annahme, dass `p` eine Primzahl ist.\n"
"Um mit dieser Annahme zu arbeiten, wendest du am besten immer `rw [prime_def] at hp` an."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**Robo**:  Nee, lieber nicht.  Du solltest `Prime` nicht unfolden!\n"
"Das macht alles nur schwieriger.  Benutze lieber wie ich gesagt hatte `rw [prime_def] at hp`."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**Du**:  Aha.  Eine Primzahl ist also eine natürlich Zahl größergleich `2`, die nur durch\n"
"`1` und sich selbst teilbar ist.  Das klingt vertraut."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**Robo**:  Statt `have` könntest du hier übrigens auch `specialize «{hp}» «{a}»` verwenden."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**Robo**:  Statt `have` könntest du hier übrigens auch `specialize «{hp}» «{a}» «{ha}»` verwenden."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "**Robo**:  Probier mal `linarith`.  Das sollte den Widerspruch aufdecken, der sich aus\n"
"`«{a}» = 1` und `2 ≤ «{a}»` ergibt."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid ""
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid ""
msgstr ""

#: Game.Levels.Prado.L07_dvd_mul
msgid ""
msgstr ""

#: Game.Levels.Prado.L07_dvd_mul
msgid "**Robo**:  Hier ist noch eine kleine Primzahl-Aufgabe.\n"
"   Das Lemma `Prime.dvd_mul` sagt, dass eine Primzahl genau dann ein Produkt teilt,\n"
"   wenn sie einen der Faktoren teilt.  Das musst du hier nur anwenden."
msgstr ""

#: Game.Levels.Prado.L07_dvd_mul
msgid ""
msgstr ""

#: Game.Levels.Prado.L07_dvd_mul
msgid "**Du** Du stellst aber wirklich sehr einfache Aufgaben."
msgstr ""

#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid ""
msgstr ""

#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid "Um Guino bei Laune zu halten, fragt Robo vorsichtig,\n"
"ob er euch nicht eine Aufgabe stellen möchte.\n"
"Er gibt euch folgende Variation seiner vorherigen Aufgabe."
msgstr ""

#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid "**Du** *(zu Robo)*:  Hast du eine Idee, was hier ein Primfaktor sein könnte?\n"
"\n"
"**Robo**: Nö.\n"
"\n"
"Robo überlegt.\n"
"\n"
"**Robo**:  Ist doch aber auch egal.  Er hat ja gar nicht nach einem konkreten Faktor gefragt,\n"
"sondern nur nach der Existenz irgendeines Primfaktors.  Aber das ist trivial.\n"
"Lass mich überlegen … ich glaube `exists_prime_and_dvd` ist die Aussage, die du hier brauchst."
msgstr ""

#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid ""
msgstr ""

#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid "**Guino:** Na gut, lasst uns weitergehen.  Schaut mal, ist das nicht eine herrlich Treppe?\n"
"  Wir gehen hoch!\n"
"\n"
"  **Du** *(zu Robo)*: Lass uns doch jetzt einmal probieren, die Aussage zu formlieren, die wir Guino zeigen wollen.\n"
"  Es gibt genau eine gerade …\n"
"\n"
"  **Robo**:  Halt!  „Genau eine“ hatten wir noch nicht."
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid ""
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid "**Robo**:  Aber so schwer ist das auch nicht.  Hier, schau dir diese Aufgabe mal an."
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid "**Du**: Ich sehe schon – `∃! m, P(m)` ist also die Notation für „es gibt genau ein `m`, für das `P(m)` gilt“.\n"
"\n"
"**Robo**: Genau.  Und das ist einfach definiert als „es existiert ein `m`,\n"
"sodass (1) `P(m)` gilt und (2) jedes andere Element `m'`, für das `P(m')` gilt, bereits gleich `m` ist.\n"
"Der erste Schritt ist also, ein geeignetes `m` zu finden, und dann `use _` zu verwenden."
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid "**Robo**: Tatsächlich ergibt `use` auf `∃!` angewendet immer ein bisschen Chaos.\n"
"Schick am besten immer gleich ein `simp` hinterher, dann wird es wieder lesbar."
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid "**Robo**: Jetzt hast du wie gesagt zwei Aussagen zu beweisen: (1) `«{w}»` erfüllt `a * «{w}» = b`,\n"
"(2) `«{w}»` ist das einzige Element mit dieser Eigenschaft."
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid "**Robo**:  Super.  Jetzt also zur Eindeutigkeit.  Ich glaube, da könnte das Lemma\n"
"`mul_eq_mul_left_iff` helfen:\n"
"\n"
"```\n"
"a * b = a * c ↔ b = c ∨ a = 0\n"
"```"
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid ""
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid ""
msgstr ""

#: Game.Levels.Prado.L10_EvenPrime
msgid ""
msgstr ""

#: Game.Levels.Prado.L10_EvenPrime
msgid "Inzwischen seid ihr auf der Dachterasse angekommen.\n"
"Aber Guino hat es inzwischen aufgegeben, alle architektonischen Details zu erklären.\n"
"Die Aussicht ist nicht schlecht.\n"
"\n"
"**Robo** *(zu dir)*:  Ich glaube, wir sind so weit."
msgstr ""

#: Game.Levels.Prado.L10_EvenPrime
msgid "**Robo**:\n"
"Schau noch einmal genau durch die Aussagen, die wir schon gezeigt hatten."
msgstr ""

#: Game.Levels.Prado.L10_EvenPrime
msgid "**Du**: Juchhu!  Und wer sagt es ihm jetzt?\n"
"\n"
"**Robo**:  Vielleicht lassen wir es lieber.  Ich habe das Gefühl,\n"
"ihm gefällt ohnehin sein Museum so leer wie es ist am besten.\n"
"\n"
"Ihr bedankt euch also artig für die Führung, zeigt euch tief beeindruckt\n"
"von der hiesigen Eisbaukunst, und fliegt weiter."
msgstr ""

#: Game.Levels.Prado
msgid "Prado"
msgstr ""

#: Game.Levels.Prado
msgid "Ihr seid auf einem Eisplaneten gelandet,\n"
"direkt neben einem Eispalast.  Du hast das Gefühl,\n"
"diesen Palast schon einmal gesehen zu haben, aber du kannst dich nicht entsinnen,\n"
"wo das gewesen sein könnte.\n"
"\n"
"Direkt am Eingang empfängt euch ein pinguinartiges Wesen.\n"
"\n"
"**Guino**: Willkommen im Prado!  Ich bin ja so froh, dass ihr hier seid.\n"
"Ihr seid die ersten Besucher!  Nun gut, wir haben ja auch gerade erst eröffnet.\n"
"Kommt rein, komm rein!  Ihr seid diese Erdleute, von denen allen berichten, nicht wahr?\n"
"\n"
"**Du**:  Ähm, ja.  Und ihr seid …?\n"
"\n"
"**Guino**:  Guino, Museumsdirektor des Prado – des PRimzahlen-ADOrationsmuseums!  Kommt, kommt!\n"
"\n"
"Guino führt euch die Stufen am Eingang hinauf und durch das Portal in eine große Halle.\n"
"In der Mitte schwebt ein kleines Podest. Darauf liegen zwei Murmeln.\n"
"\n"
"**Guino**: Seht, seht!  Unser erstes Exponat!  Die Primzahl ZWEI!\n"
"\n"
"Ihr seid beide etwas perplex.  Guino hebt die Augenbrauen.\n"
"\n"
"**Guino**: Ihr wisst doch hoffentlich, wie man zeigt, dass das eine Primzahl ist?"
msgstr ""

#: Game.Levels.Vieta.L01_FunctionNotation
msgid ""
msgstr ""

#: Game.Levels.Vieta.L01_FunctionNotation
msgid "**Vieta:** Kommt, ich zeig euch etwas …\n"
"\n"
"Er gibt dir ein Stück Papier."
msgstr ""

#: Game.Levels.Vieta.L01_FunctionNotation
msgid "**Du**: Sieht aus, als wäre `f` eine Abbildung von `ℤ` nach `ℕ`.\n"
"\n"
"**Robo**: Ja, genau.  Und `f n` ist die Notation für $f(n)$.  Aber auf Leansch lässt man\n"
"die Klammern weg.  Wenn du sie setzen möchtest,  musst du unbedingt Leerzeichen\n"
"um die Klammern setzen – so: `f (n)`.\n"
"\n"
"**Du**: Okay, will ich mir merken.  Aber da die Abbildung hier nur Werte in ℕ annimmt,\n"
"ist ja eigentlich nichts zu zeigen."
msgstr ""

#: Game.Levels.Vieta.L01_FunctionNotation
msgid "**Du**: Sag mal, war `→` nicht eben noch eine Implikation?\n"
"\n"
"**Robo**: Ja, richtig. Die benuzten hier das gleiche Zeichen für beides."
msgstr ""

#: Game.Levels.Vieta.L02_Function
msgid ""
msgstr ""

#: Game.Levels.Vieta.L02_Function
msgid "Wieder saust ein Pfeil vorbei.  Aber Vieta gibt euch seelenruhig das nächste Blatt."
msgstr ""

#: Game.Levels.Vieta.L02_Function
msgid "**Robo**: Aha, das ist interessanter.  Hier ist\n"
"`fun (x : ℤ) ↦ x ^ 2` eine „anonyme Funktion“, nämlich die Abbildung $x↦x^2$.\n"
"\n"
"**Du**:  Und was ist an ihr anonym?\n"
"\n"
"**Robo**: Na, dass sie erst einmal keinen Namen hat.\n"
"Erst durch `f : ℤ → ℤ := …` erhält sie einen Namen.\n"
"\n"
"**Du**:  Ach so.  Ingesamt haben wir also die folgende Abbildung, ja?\n"
"\n"
"$$\n"
"\\begin{aligned}\n"
"f\\colon \\mathbb{ℤ} &\\to \\mathbb{ℤ} \\\\\n"
"x &\\mapsto x ^ 2\n"
"\\end{aligned}\n"
"$$\n"
"\n"
"Ich soll also zeigen $2^2=4$?\n"
"\n"
"**Robo**: Ja.\n"
"\n"
"**Du**: Und wie mache ich das hier?\n"
"\n"
"**Robo**: Lean kann durch die meisten Abbildungsvorschriften hindurchsehen, also sollte `rfl`\n"
"hier reichen. Alternativ kannst du mit `simp [«{f}»]` explizit die Definition einsetzen."
msgstr ""

#: Game.Levels.Vieta.L02_Function
msgid ""
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid ""
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid "Wieder ein Pfeil.  Und noch eine Aufgabe."
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid "**Robo**: Wie immer gehst du ein `∃` mit `use …` an.  Oder du definierst dir erst einmal\n"
"mit `let f : ℤ → ℤ := fun …` eine Abbildung, die du benutzen möchtest, so, wie du es eben gerade gesehen hast.\n"
"Den Pfeil `↦` schreibst du übrigens als `\\maps` oder `\\mapsto`.\n"
"Aber du kannst auch stattdessen `=>` benutzen."
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid "**Robo**: Wenn du `«{f}»` richtig definiert hast, kannst du\n"
"dieses mit `use` brauchen, und die resultierende Ungleichung sollte einfach sein"
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid "**Du**: Zu was sich das wohl vereinfacht?"
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid ""
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid ""
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Vieta**:  Jetzt müssen wir mal ein Stück hier rüber gehen.\n"
"\n"
"Er schiebt euch vorsichtig ein paar Meter weiter.  Einen Moment später gehen an dem Ort,\n"
"an dem ihr eben gestanden habt, drei Pfeile nieder und bleiben im Boden stecken.\n"
"\n"
"**Vieta**: Ganz ruhig, ich kenne mich hier aus.  Hier, ich habe noch mehr für euch."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Du**: Ist `g ∘ «{f}»` Komposition von Abbildungen?\n"
"\n"
"**Robo**: Richtig! Das schreibt man mit `\\comp`.\n"
"\n"
"**Du** Und hier könnte ich also wieder\n"
"`let g : ℤ → ℤ := fun x ↦ _` definieren?\n"
"\n"
"**Robo**:  Ja, oder sogar  direkt `use fun (x : ℤ) ↦ _`?"
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Robo**: Jetzt kannst du diese mit `use «{g}»` benutzen."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Robo**: `(«{g}» ∘ «{f}») x` ist per Definition `«{g}» («{f}» x)`. `simp` würde dieses\n"
"Lemma auch kennen, aber mach das hier mal direkt mit `rw [comp_apply]`."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Robo**: `ring` sieht durch lokale Definitionen wie\n"
"`«{f}»` und `«{g}»` hindurch,\n"
"du kannst es also direkt benutzen."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Robo**: `(g ∘ «{f}») x` ist per Definition `g («{f}» x)`. `simp` würde dieses\n"
"Lemma auch kennen, aber mach das hier mal direkt mit `rw [comp_apply]`."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "**Robo**: `ring` sieht durch lokale Definitionen wie\n"
"`«{f}»` hindurch,\n"
"du kannst es also direkt benutzen."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "Sagt dass `(f ∘ g) x` das gleiche ist wie `f (g x)`."
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid ""
msgstr ""

#: Game.Levels.Vieta.L05_Funext
msgid ""
msgstr ""

#: Game.Levels.Vieta.L05_Funext
msgid "Vieta sieht sich vorsichtig um, bleibt dann aber doch stehen.\n"
"Er reicht euch ruhig das nächste Blatt."
msgstr ""

#: Game.Levels.Vieta.L05_Funext
msgid "**Du**: Per Definition sind doch zwei Abbildungen gleich, wenn sie angewendet auf\n"
"jedes Element den gleichen Wert haben …\n"
"\n"
"**Robo**: Zu dem Prinzip hätte ich die Taktik `funext` auf Lager.\n"
"Mit `funext x` wählst du ein beliebiges `x` und änderst das Beweisziel von `f = g` zu `f x = g x`."
msgstr ""

#: Game.Levels.Vieta.L05_Funext
msgid "**Robo**: Zur Erinnerung, `ring` sieht durch lokale Definition hindurch."
msgstr ""

#: Game.Levels.Vieta.L05_Funext
msgid ""
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid ""
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Vieta**:  Wir sollten doch noch mal ein Stück laufen.  Hier entlang!\n"
"\n"
"Er eilt davon, und ihr folgt, so schnell ihr könnt.\n"
"Als ihr den Ort erreicht, an dem er schließlich stehen bleibt, bist du völlig außer Puste.\n"
"Vieta lacht.\n"
"\n"
"**Vieta**:  Reine Vorsichtsnahme!  Ich muss ja auf meine Besucher achtgeben.\n"
"So viel Besuch bekomme ich nicht!\n"
"\n"
"Er reicht euch das nächste Blatt."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Robo**: Jetzt haben wir zwei Abbildungen, eine davon mit stückweiser Definition.\n"
"\n"
"**Du**: Also, ich soll zeigen, dass die beiden vertauschbar sind?\n"
"\n"
"**Robo**: Genau, am besten wählst du mit `funext x` ein beliebiges Element aus, und zeigst das\n"
"dann für dieses."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Du**: Ah und jetzt kann ich erst einmal `(g ∘ f) «{x}»` zu `g (f «{x}»)` umschreiben?\n"
"\n"
"**Robo**: Mit `simp` klappt das."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Robo**: Jetzt kannst du nämlich eine Fallunterscheidung\n"
"machen, `by_cases h : 0 ≤ «{x}»`.\n"
"\n"
"**Du**: Damit krieg ich die Fälle `0 ≤ «{x}»` und `0 > «{x}»`?\n"
"\n"
"**Robo**: Genau! Oder präziser `0 ≤ «{x}»` und `¬(0 ≤ «{x}»)`. Das ist nicht ganz das gleiche,\n"
"und man könnte mit dem Lemma `not_le` zwischen `¬(0 ≤ «{x}»)` und `0 > «{x}»` wechseln."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Du**: Jetzt muss ich wohl doch mal die Definitionen benutzen.\n"
"\n"
"**Robo**: Dann benutz sie mal `simp [f, g]`!"
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Robo**: Jetzt hast du `rw [if_pos «{h}»]` zur Verfügung, um das if-then-else zu\n"
"reduzieren."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Robo**: Nochmals `simp [f, g]`."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Du**: Ah, und die Verneinung von `if_pos` ist sicher …"
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "**Robo**: `if_neg`, genau!"
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid ""
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "Wenn `h : A` ein beweis der Aussage `A` ist, dann reduziert\n"
"`rw [if_pos h]` reduziert eine Aussage `if A then B else C` zu `B`.\n"
"\n"
"Umgekehrt kann man `if_neg` verwenden wenn `h : ¬ A`."
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "Wenn `h : ¬ A` ein Beweis ist, dass Aussage `A` falsch ist, dann reduziert\n"
"`rw [if_neg h]` eine Aussage `if A then B else C` zu `C`.\n"
"\n"
"Umgekehrt kann man `if_pos` verwenden wenn `h : A`."
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid ""
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid "Ihr hört aus der Ferne Kampfgeräusche.  Vieta scheint nach wie vor nicht beunruhigt.\n"
"Er gibt euch noch eine Aufgabe."
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid "**Robo**: Ich vermute, du solltest als erstes mal ein Element aus `A` wählen …"
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid "**Robo**: … zum Beispiel mit `obtain ⟨a₀⟩ := h`."
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid "**Robo**: Und jetzt versuch mal, die richtige Funktion zu definieren: `let g : ℤ → «{A}» :=` usw."
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid "**Robo**: Du könntest eine stückweise Funktion mit `if 0 ≤ n then ... else ...`\n"
"definieren."
msgstr ""

#: Game.Levels.Vieta.L07_Extend
msgid "**Robo**: Jetzt kannst du dein definiertes `g` mit `use` brauchen, und\n"
"sehen, ob deine Definition gut war."
msgstr ""

#: Game.Levels.Vieta.L08_CongrArg
msgid ""
msgstr ""

#: Game.Levels.Vieta.L08_CongrArg
msgid "Die Kampfgeräusche kommen näher. Vieta gibt euch zwei weitere Blätter."
msgstr ""

#: Game.Levels.Vieta.L08_CongrArg
msgid "**Robo**: Oh, das ist ein Fall für `congr_arg`.  Wenn du schon weiß, dass `x = y`, erhälst du\n"
"`f x = f y` mit `apply congr_arg`."
msgstr ""

#: Game.Levels.Vieta.L08_CongrArg
msgid ""
msgstr ""

#: Game.Levels.Vieta.L08_CongrArg
msgid ""
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid ""
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid ""
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid "**Robo**: Und das ist ein Fall für `congr_fun`.\n"
"Hast du `h : f = g` als Annahme, kannst du sie mit mit `apply congr_fun at h` zu `h : ∀ x, f x = g x` umscheiben.\n"
"\n"
"**Du**: Aber könnte ich hier nicht auch einfacher `rw [h]` benutzen?\n"
"\n"
"**Robo**: Ja gut, in diesem einem einfachen Beispiel schon. Wenn aber `f` ein komplizierterer\n"
"Ausdruck ist und noch nicht exact so im Beweisziel steht, dann nicht.\n"
"Probiers mal, wie ich es gerade gesagt habe."
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid ""
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid ""
msgstr ""

#: Game.Levels.Vieta.L10_Surjective
msgid ""
msgstr ""

#: Game.Levels.Vieta.L10_Surjective
msgid "Die Kampfgeräusche wirken inzwischen bedrohlich nahe.\n"
"Ihr hört deutlich vernehmbar Kanonenschüsse.\n"
"Und da saust auch schon wieder ein Pfeil an euch vorbei.\n"
"\n"
"**Du**:  Ähm, sollten wir vielleicht …\n"
"\n"
"**Vieta**:  Keine Sorge, für einen Aufgabe haben wir noch Zeit."
msgstr ""

#: Game.Levels.Vieta.L10_Surjective
msgid "**Du**: Wenn ich das richtig lese, soll ich im Wesentlichen zeigen, dass irgendeine Abbildung `f` surjektiv ist.\n"
"\n"
"**Robo**:  Nicht nur irgendeine Abbildung.  Die Abbildung geht nach `ℕ`!\n"
"\n"
"Du hebst die Augenbrauen.\n"
"\n"
"**Robo**: Könnte was mit Induktion zu tun haben.  Ich mein ja nur."
msgstr ""

#: Game.Levels.Vieta.L10_Surjective
msgid "**Robo**: Willst du vielleicht `«{hs}»`\n"
"zu `∀ x, («{f}» ∘ «{g}») x = (succ ∘ «{f}»)` umschreiben?"
msgstr ""

#: Game.Levels.Vieta.L10_Surjective
msgid "**Vieta**:  Bravo!  Jetzt aber nichts wie weg von hier.\n"
"Hier gehts lang.  Ich bring euch zurück zum Raumschiff."
msgstr ""

#: Game.Levels.Vieta
msgid "Vieta"
msgstr ""

#: Game.Levels.Vieta
msgid "Hallo, ist da wer?  Ihr seid in einer Heide-Landschaft gelandet.\n"
"Weit und breit ist niemand zu sehen.\n"
"\n"
"Plötzlich zischt ein Pfeil direkt über deinen Kopf.\n"
"\n"
"**Du**: Deckung!\n"
"\n"
"Ihr werft euch flach auf den Boden.  Ihr wollt schon zurück zum Raumschiff robben, da\n"
"tritt hinter einem verdorrten Baum ein Mann hervor, der freundlich winkt.\n"
"Ihr robbt also zu ihm.\n"
"\n"
"**Vieta**: Nur nicht so schüchtern, meine Damen und Herren! Vieta, mein Name. Willkommen!\n"
"Steht ruhig auf, die Luft ist rein.\n"
"\n"
"Ihr erhebt euch vorsichtig, da zischt schon wieder dicht neben euch ein Pfeil vorbei.\n"
"\n"
"**Du**:  Wie halten Sie es hier aus?\n"
"\n"
"**Vieta**:  Nun, ich habe gelernt, immer zur richtigen Zeit an der richtigen Stelle zu stehen.\n"
"Macht euch keinen Sorgen."
msgstr ""

#: Game.Levels.Epo.L01_Surjective
msgid ""
msgstr ""

#: Game.Levels.Epo.L01_Surjective
msgid "Die Fahrt ist tatsächlich kurz und schmerzlos.\n"
"Und euch wird tatsächlich ein großen Empfang bereitet.\n"
"Nachdem sich die erste Aufregung gelegt hat, werden ihr aber auch hier mit Aufgaben konfrontiert."
msgstr ""

#: Game.Levels.Epo.L01_Surjective
msgid "**Du**: Vermute ich richtig, dass die Definition von `Surjective f` ist: `∀ y, (∃ x, f x = y)`?\n"
"\n"
"**Robo**: Glaub schon.  Du könntest ja mal mit `unfold Surjective` hineinsehen. Musst da aber auch nicht."
msgstr ""

#: Game.Levels.Epo.L01_Surjective
msgid "`Surjective f` bedeutet naheliegenderweise, dass die Abbildung `f` surjektiv ist.\n"
"Mit `unfold Surjective` (bzw. `unfold Surjective at h`) kann man leicht nachsehen, was das\n"
"in Quantorenschreibweise konkret bedeutet."
msgstr ""

#: Game.Levels.Epo.L01_Surjective
msgid ""
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid ""
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid ""
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid "**Du**:  `ℕ → A → B` … wie lese ich diese zwei Pfeile hintereinander?\n"
"\n"
"**Robo**: Du liest das als `ℕ → (A → B)` – eine Abbildung von den natürlichen Zahlen `ℕ` in die Menge `A → B` der Abbildungen von A nach B.  Das wird übringens auch klar, wenn du weiterliest, was du hier zeigen solltst."
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid "**Robo**: Du könnstest mit `constructor` anfangen, oder du fängst an mit `unfold Surjective` und schaust dann, ob dich `push_neg` weiterbringt."
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid "**Robo**: Hilft dir vielleicht `ne_comm` weiter?\n"
"Die Aussage von `ne_comm` ist `a ≠ b ↔ b ≠ a`."
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid "**Robo**: Hilft dir vielleicht `ne_comm` weiter?\n"
"Die Aussage von `ne_comm` ist `a ≠ b ↔ b ≠ a`."
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid ""
msgstr ""

#: Game.Levels.Epo.L03_LeftInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L03_LeftInverse
msgid "A function `g : B → A` is a left inverse of a function `f : A → B` if for all `a : A`,\n"
"`g (f a) = a`."
msgstr ""

#: Game.Levels.Epo.L03_LeftInverse
msgid "**Du**: Ich vermute mal, dass soll heißen, `g` ist genau dann ein Rechtsinverses of `f`, wenn `f` ein Linksinverses von `g` ist.\n"
"\n"
"**Robo**:  Genau.  Aber wenn mich nicht alles täuscht, ist das in Leansch weniger ein Satz als vielmehr die Definition von `Function.RightInverse`.  Und dummerweise muss man tatsächlich `Function.RightInverse` statt schlicht `RightInverse` schreiben, weil `RightInverse` in Leansch mehrdeutig ist."
msgstr ""

#: Game.Levels.Epo.L04_RightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L04_RightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L04_RightInverse
msgid "**Du**:  Jetzt muss ich mich wohl doch ein bisschen durch die Definitionen hangeln?\n"
"\n"
"**Robo**: Sieht so aus."
msgstr ""

#: Game.Levels.Epo.L04_RightInverse
msgid "**Robo:**:  Ich würde tatsächlich wieder mit `constructor` anfangen.\n"
"Und dann die üblichen Verdächtigen wie `comp_apply`, `congr_fun` usw. nutzen."
msgstr ""

#: Game.Levels.Epo.L04_RightInverse
msgid "**Robo**:  Du könntest mit `apply congr_fun at h` oder `rw [← comp_apply (f:= f)]`.\n"
"(`rw [← comp_apply]` ohne `(f:=f)` funktioniert hier nicht\n"
"– du musst explizit angeben, welchen Wert die Variable `f` in der Aussage von `comp_apply` haben soll."
msgstr ""

#: Game.Levels.Epo.L05_RightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L05_RightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L05_RightInverse
msgid "**Du**:  Hier soll ich vermutlich zeigen, dass ein Rechtsinverses zu `f` existiert?\n"
"\n"
"**Robo**:  Ja.  Du kannst also zunächst wieder mit `let g : ℤ × ℤ → ℤ × ℤ := fun (m, n) ↦ …` eine Abbildung angeben,\n"
"und sie dann mit `use g` verwenden.\n"
"\n"
"**Du**:  Gut.  Dann überlege ich also einmal, wie ein Rechtsinverses zu `f` aussehen könnte …"
msgstr ""

#: Game.Levels.Epo.L06_choose
msgid ""
msgstr ""

#: Game.Levels.Epo.L06_choose
msgid ""
msgstr ""

#: Game.Levels.Epo.L06_choose
msgid "**Du**:  Das riecht irgendwie nach Auswahlaxiom.\n"
"\n"
"**Robo**:  Bingo.  Erinnerst du nicht noch an `choose`?\n"
"Hier kommt `choose` so richtig in sein Element.\n"
"Probier mal `choose g hg using nonempty_fibre`."
msgstr ""

#: Game.Levels.Epo.L07_SurjectiveRightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L07_SurjectiveRightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L07_SurjectiveRightInverse
msgid ""
msgstr ""

#: Game.Levels.Epo.L07_SurjectiveRightInverse
msgid "Ihr bekommt eine große Runde Applaus.\n"
"\n"
"Danach werdet ihr verabschiedet.\n"
"Für den Rückweg könnt ihr leider keine Transportkapsel benutzen.\n"
"Die funktionieren nämlich nur in eine Richtung.\n"
"Zurück zum Raumschiff geht es also zu Fuß: erst die Treppen runter, dann draußen vom Bürohaus zum Schlafturm, und schließlich mit einem ganz gewöhnlichen Fahrstuhl nach oben."
msgstr ""

#: Game.Levels.Epo
msgid "Epo"
msgstr ""

#: Game.Levels.Epo
msgid "Auf dem Planeten, dem ihr euch nähert, sind zwei Gebäude zu erkennen: ein schmales Hochhaus\n"
"und ein zweites Gebäude mit etwas weniger Etagen.\n"
"Die Gebäude sind mit einem eigenartigen Röhrensystem miteinander verbunden.\n"
"Oben auf dem Hochhaus erkennt ihr einen Landeplatz.  Den steuert ihr an.\n"
"\n"
"Als ihr aussteigt, kommt ein Formalosoph auf euch zugelaufen.  Er winkt wild mit den Armen.\n"
"\n"
"**Portier**:  Nein, nicht doch, da unten werdet ihr erwartet.\n"
"\n"
"Er lässt die Arme sinken.\n"
"\n"
"**Portier**:  Nun ja, egal.  Guten Tag, erst einmal!\n"
"Ich bin hier nur der Hausmeister.\n"
"Ihr werdet von einer großen Delegation erwartet, aber natürlich drüben, im Bürohaus.\n"
"Das hier ist nur unser Schlafturm.  Kommt, ich bringe euch hinüber.  Es geht ganz schnell.\n"
"\n"
"Er führt euch eine Etage hinunter und bitte euch, in „Transportkapseln“ einzusteigen, jeder in eine.\n"
"\n"
"**Portier**:  Wir rutschen jetzt einfach mit diesen Kapseln hinüber.\n"
"Keine Sorge, die Bahn ist frei!\n"
"Wir haben hier zwar leider immer wieder Zusammenstöße, aber momentan ist die Luft rein.\n"
"Alle anderen sind ja schon drüben!"
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid ""
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid "Ganz oben sind tatsächlich wieder viele Formalosophen versammelt.\n"
"Sie heißen euch freudig willkommen, und kommen dann gleich zur Sache."
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid "**Robo**: `Injective` ist so definiert, wie du es erwarten würdest: `∀ {a b : U}, f a = f b → a = b`.\n"
"Du kannst das wieder leicht mit `unfold` prüfen, wenn du mir nicht traust."
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid "**Robo**:  Fang doch mit `intro a b` an."
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid "**Robo**: Ich glaube, du solltest jetzt mit der Definition von `«{f}»` die\n"
"Annahme `«{ha}»` vereinfachen."
msgstr ""

#: Game.Levels.Mono.L01_Injective
msgid "Das habt ihr gut gemacht, finden die Formalosophen."
msgstr ""

#: Game.Levels.Mono.L02_InjectiveNeIff
msgid ""
msgstr ""

#: Game.Levels.Mono.L02_InjectiveNeIff
msgid ""
msgstr ""

#: Game.Levels.Mono.L02_InjectiveNeIff
msgid "**Robo**: Hier kannst du abkürzen, indem du statt der Definition von `Injective f` die äquivalente Beschreibung `a ≠ b → f a ≠ f b` von Injektivität benutzt.\n"
"In Leansch ist das Teil von `Injective.ne_iff`:  für injektive Abbildungen gilt `f a ≠ f b ↔ a ≠ b`."
msgstr ""

#: Game.Levels.Mono.L02_InjectiveNeIff
msgid "**Robo**: `decide`?"
msgstr ""

#: Game.Levels.Mono.L02_InjectiveNeIff
msgid ""
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid ""
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid ""
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "**Du**:  Also, die gegebene Abbildung hat die folgende Form:\n"
"$$\n"
"f(n) = \\begin{cases}\n"
"n^2 & \\text{falls } n \\text{ gerade} \\\\\n"
"n+1 & \\text{andernfalls.}\n"
"\\end{cases}\n"
"$$\n"
"Und was ist `f + f`?\n"
"\n"
"**Robo**: Das ist die Abbildung `ℕ → ℕ`, die an jeder Stelle den doppelten Wert von `f` annimmt."
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "**Robo**: Vielleicht öffnest du zuerst mal `Injective` mit `unfold`. Dann steht da `¬ ∀` …"
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "**Robo**: Erinnerst du dich an `push_neg`?"
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "**Du** Jetzt muss ich einfach ein Gegenbeispiel nennen, oder?\n"
"\n"
"**Robo** Genau! Welche beiden Zahlen möchtest du denn verwenden?"
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "**Robo**:  Das ist hier alles so konkret, vielleicht reicht `decide`."
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid ""
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid ""
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid ""
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid "**Du**:  In der Definition von `diag` stehen wieder zwei Pfeile hintereinander.\n"
"Das muss ich erst mal im Kopf sortieren.\n"
"\n"
"**Robo**:  Setz als erstes wieder Klammern:  `A → (Fin (n + 1) → A)`. Es ist also\n"
"`diag` eine Abbildung von `A` in die Menge `Fin (n + 1) → A`.\n"
"Nun ist `Fin (n+1)` die Menge $\\{0,1,…,n\\}$, und `Fin (n + 1) → A` demnach die Menge der Abbildung von $\\{0,1,…,n\\}$ nach $A$.\n"
"\n"
"**Du**:  Mmh…  So eine Abbildung ist eigentlich nichts weiter als eine $(n+1)$-Tupel von Elementen aus $A$, oder?\n"
"\n"
"**Robo**: Kann man so sehen.\n"
"\n"
"**Du**:  Okay.  Gegeben ist also eine Abbildung `diag` von $A$ nach $A^{n+1}$.  Und zwar die Abbildung …  ah, ich sehe, warum sie `diag` heißt."
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid "**Du**:  Oder vielleicht doch nicht.  Kannst du das bitte nochmal aufdröseln?\n"
"\n"
"**Robo**:  Die Abbildung `diag` schickt ein Element $a$ auf die Abbildung, die *jeden* Index $i \\in \\{0,1,…,n\\}$ auf $a$ abbildet.\n"
"In deiner Interpretation ist das die Abbildung $a ↦ (a,…,a)$."
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid "**Robo**: Wenn du gar nicht weiter weißt, fang am besten mal mit `unfold Injective` an."
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid "**Robo**:  Erinner dich, dass deine “Tupel” `diag «{a₁}»` und `diag «{a₂}»` in Wahrheit zwei Abbildung `Fin (n + 1) → A` sind.\n"
"Du könntest sie auf einem Element aus `Fin (n + 1)` auswerten. Vielleicht hilft `congr_fun` in irgendeiner Form?"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid ""
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid ""
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**Du**: Hmm, das ist etwas schwieriger…\n"
"\n"
"**Robo**: Ich habe gerade auch keine gute Idee.\n"
"\n"
"Da hört ihr jemanden aus der Menge flüstern: `StrictMono` …\n"
"\n"
"**Robo**:  Ah, ja.  Es gibt da dieses Lemma `StrictMono.injective`:\n"
"jede strikt monotone Abbildung ist injektiv.\n"
"Und es gibt auch jede Menge Lemmas, mit denen man zeigen kann, dass Abbildungen monoton sind.\n"
"Zum Beispiel:\n"
"\n"
"`StrictMono.add`  – die Summe zweier strikt monotoner Abbildungen ist wieder strikt monoton\n"
"\n"
"`Odd.strictMono_pow` – für ungerades `n` ist `x ↦ x ^ n` strikt monoton\n"
"\n"
"Wollen wir es damit einmal versuchen?"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**Robo**: `apply` ist, wonach du suchst."
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**Robo**: Ich glaube, dieser Weg ist zu steinig. Fang lieber nochmals von vorne an!"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**Robo**: Ich glaube, dieser Weg ist zu steinig. Fang lieber nochmals von vorne an!"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**Du**: `Odd 3`. Ist das nicht eine Trivialität? Warte mal!"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**Du**: Ha! Und dieser Teil geht jetzt vermutlich wieder ganz elementar."
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "**Du**: Oder …?\n"
"\n"
"**Robo**: Doch, doch. Schau mal mit `unfold` in die Definition von `StrictMono` hinein."
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "Jede strikt monotone Abbildung (zwischen geeigneten Definitions- und Wertebereichen) ist injektiv."
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "Für ungerades `n` ist `x ↦ x ^ n` strikt monoton.\n"
"\n"
"*Bemerkung*: Hat man `h_odd : Odd n` als Annahme, so kann man statt `Odd.strictMono_pow h_odd` auch einfach `h_odd.strictMono_pow` schreiben."
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "Sind `f` und `g` beide strikt monoton sind, so ist auch `f + g` strikt momonton."
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid ""
msgstr ""

#: Game.Levels.Mono.L06_StrictMono
msgid ""
msgstr ""

#: Game.Levels.Mono.L06_StrictMono
msgid "Anscheinend hat jemand bemerkt, dass `StrictMono.injective` vorgesagt war.\n"
"Jetzt wollen sie davon auch einen Beweis sehen."
msgstr ""

#: Game.Levels.Mono.L06_StrictMono
msgid "**Robo**: Vieleicht erst einmal ganz klassisch alle Variablen und Annahmen aus `Injective f` einführen?"
msgstr ""

#: Game.Levels.Mono.L06_StrictMono
msgid "**Robo**:  Jetzt vielleicht eine Fallunterscheidung.  Erinnerst du dich an `lt_trichotomy`?"
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "**Du**: Behauptet wird offenbar, dass die Abbildung `n ↦ n + 1` ein Linksinverses besitzt.\n"
"Ich gebe also einfach die Abbildung `n ↦ n - 1` an … außer, dass das für `n = 0` nicht funktioniert.\n"
"\n"
"**Robo**:  Du könntest ja mit `if … then … else` eine Fallunterscheidung machen.\n"
"Aber tatsächlich brauchst du das gar nicht.  In Leansch liegt auch `0 - 1` in `ℕ`.\n"
"\n"
"**Du**: Was … ??!\n"
"\n"
"**Robo**:  Ja.  Das ist einfach wieder als `0` definiert."
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "**Robo**: Das sieht gut aus.  Aber glaub mir, die Verzweigung ist ganz unnötig.\n"
"Du könnest auch einfach `n ↦ n - 1` verwenden.  Probiers mal!"
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "**Robo**: Das sieht gut aus.  Aber glaub mir, die Verzweigung ist ganz unnötig.\n"
"Du könnest auch einfach `n ↦ n - 1` verwenden.  Probiers mal!"
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "**Robo**: Das sieht gut aus.  Aber glaub mir, die Verzweigung ist ganz unnötig.\n"
"Du könnest auch einfach `n ↦ n - 1` verwenden.  Probiers mal!"
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "**Du**:  Ich bin immer noch schockiert.\n"
"  Ich dachte, wir machen hier Mathematik.\n"
"  Wieso sollte denn `0 - 1` wieder `0` sein??\n"
"\n"
"  **Robo**:  Reine Ansichtssache.  Du stellst dir `n ↦ n - 1` vor als eine Abbildung, die nur auf den positive natürlichen Zahlen definiert ist.\n"
"  In Leansch ist `n ↦ n - 1` eben eine Abbildung, die auf allen natürlichen Zahlen definiert ist, und sie schickt `0` auf `0`.\n"
"  Warum nicht.  Anwenden wird man diese Abbildung am Ende eh nur auf positive Zahlen, und auf denen stimmt deine Interpretation ja glücklicherweise mit der leanschen Interpretation überein."
msgstr ""

#: Game.Levels.Mono.L08_RightInvOfLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L08_RightInvOfLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L08_RightInvOfLeftInv
msgid "**Du**: Was steht hier?\n"
"\n"
"**Robo**:  Eine injektive Abbildung `f`, die zu einer Abbildung `g` linksinvers ist, ist zur selben Abbildung auch rechtsinvers."
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "**Du**: Eine Abbildung, die ein Linksinverses besitzt, ist injektiv.  Schonmal gehört, glaube ich …"
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "**Robo**:  Vielleicht irgendwas mit `congr_arg g`?"
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "**Robo**:  Gut gemacht!  Ich glaube, wir sind hier bald durch …"
msgstr ""

#: Game.Levels.Mono.L10_Auxiliary
msgid ""
msgstr ""

#: Game.Levels.Mono.L10_Auxiliary
msgid ""
msgstr ""

#: Game.Levels.Mono.L10_Auxiliary
msgid "**Du**:  Sind wir jetzt zurück auf Quantus?  Jedenfalls:  Es gibt ein `a` oder es gibt kein `a`, das sieht aus nach einer Tautologie.\n"
"\n"
"**Robo**:  Langsam!  Du musst die implizite Klammerung beachten. Ich schreib dir das mal mit mehr Klammern aus:\n"
"```\n"
"∀ b : B, ∃ a : A,\n"
"( f a = b   ∨   ¬ ∃ a' : A , f a' = b )\n"
"```"
msgstr ""

#: Game.Levels.Mono.L10_Auxiliary
msgid "**Robo**:  Vielleicht nimmst du dir als erstes mal mit `obtain` irgendein Element aus `A` her.\n"
"Du weißt ja, dass es eins gibt."
msgstr ""

#: Game.Levels.Mono.L10_Auxiliary
msgid "**Robo**:  Nun ja, du könntest mit `by_cases` eine Fallunterscheidung machen, ob denn nun `«{b}»` ein Urbild besitzt oder nicht."
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid ""
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "**Du**:  Ich seh schon.  Die Eposophen wollten gern bewiesen haben, dass eine Abbildung genau dann surjektive ist, wenn sie ein Rechtsinverses besitzt.\n"
"Und die hiesigen Monosophen wollen gern bewiesen haben, dass eine Abbildung genau dann injektiv ist, wenn sie in Linksinverses besitzt.\n"
"\n"
"**Robo**: Ja, außer dass sie diese zusätzliche Voraussetzung `Nonempty A` brauchen."
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "**Du*:  Ich will ein Linksinverses angeben, aber ich sehe gerade nicht, wie.\n"
"\n"
"**Robo**:  Erinner dich an die Aussage, die wir eben gerade gezeigt hatten: ` ∀ b : B, ∃ a : A, …`\n"
"Wenn du die hier hättest, könntest du vermutlich mit `choose` das gesuchte Linksinverse wählen.\n"
"Nur hat diese Aussage dummerweise keinen Namen.\n"
"Vielleicht formulierest du sie noch einmal mit `have` selbst aus, und beweist sie auch noch einmal."
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "**Robo**:  Das hatten wir doch auch schon gezeigt …  aber ich hatte vergessen, es abzuspeichern.\n"
"Erinnerst du dich an den Beweis?"
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "Ihr bekommt wieder eine große Runde Applaus und werdet ihr verabschiedet.\n"
"Wieder gibt es keine Transportkapseln für den Rückweg.\n"
"Aber so weit ist es ja nun auch wieder nicht."
msgstr ""

#: Game.Levels.Mono
msgid "Mono"
msgstr ""

#: Game.Levels.Mono
msgid "Auf dem nächsten Planeten stehen wieder zwei Hochhäuser nebeneinander.\n"
"Wieder ist das eine schmal und hoch, das andere etwas breiter und niedriger.\n"
"Und wieder sind sie durch ein Röhrensystem miteinander verbunden –\n"
"es gibt wohl auch wieder irgendein Transportkapsel-System.\n"
"Nach der Erfahrung auf Epo steuert ihr diesmal geradewegs das niedrigere Gebäude an und landet auf dem Dach.\n"
"\n"
"**Portier**:  Nicht doch, nicht doch.  Habt ihr nicht alle winken sehen?\n"
"Das hier ist doch bloß unser Schlafhaus.  Wir sind tagsüber immer dort drüben, im Büroturm.\n"
"Aber gut, nun seid ihr hier.  Willkommen erst einmal!\n"
"\n"
"Ihr schüttelt jeder eine seiner vier Hände.\n"
"\n"
"**Portier**:  Immerhin habe ich so die Möglichkeit, euch gleich unser einzigartiges Nahverkehrssystem vorzustellen.\n"
"Ihr kommt von Epo, nicht war?\n"
"Böse Geschichten hört man von dort.\n"
"Jeden zweiten Tag gibts einen Unfall.\n"
"Die kriegen ihre Röhren einfach nicht sortiert.\n"
"Wir sind seit Jahren unfallfrei!\n"
"\n"
"Ihr geht vier Stockwerke nach unten.\n"
"Dort bekommt wieder jeder eine Kapsel zugewiesen,\n"
"und ihr gleitet geräuschlos bergauf in den Büroturm.\n"
"Wie der Antrieb funktioniert, bleibt ein Rätsel.\n"
"\n"
"**Robo**:  Oh.  Hier ist ja auch niemand!\n"
"\n"
"**Portier**:  Natürlich nicht.  Die sind alle ganz oben.\n"
"Und nicht jedes Stockwerk lässt sich über eine Röhre erreichen.\n"
"Aber wir sind schon fast da.  Nur noch zwei Treppen hinauf."
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "**Arapuka**:  Es gibt da auch ein paar Dinge, über die ich schon lange nachdenke.\n"
"Vielleicht könnte ihr mir ja helfen.  Zum Beispiel: …\n"
"\n"
"Sie diktiert euch eine Aussage. Robo schreibt sie auf."
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "**Robo**:  Die Notation hier muss ich dir, glaube ich, erklären.\n"
"Gegeben ist offenbar eine Abbildung `f : A → B`.\n"
"Für eine Teilmenge `S` von `A` ist\n"
"```\n"
"f '' S = {f a | a ∈ S}\n"
"= {b | ∃ a ∈ S, f a = b}\n"
"```\n"
"ihr Bild unter `f`.  Und für eine Teilmenge `T` von `B` ist\n"
"```\n"
"f ⁻¹' T = { a | f a ∈ T}\n"
"```\n"
"ihr Urbild unter `f`."
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "**Robo:** Um eine Inklusion zu zeigen, nimmst du dir ein Element aus der linken Seite und zeigst, dass es in der rechten liegt.\n"
"Also fang doch mal mit `intro b` an."
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "**Robo**:  Um die Annahme `hb` in einen elementareren Ausdruck zu überführen, könntest du `simp` anwenden."
msgstr ""

#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "**Arapuka**: Schön."
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "Arapuka diktiert euch noch eine Aufgabe."
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "**Du**:  Aha!  Ich kann also auch einfach `image` schreiben, wenn ich mir diese Fliegendreck-Schreibweise mit `''` nicht mag?\n"
"\n"
"**Robo**:  Nein, schau mal genauer hin.   Hier ist `image f` eine Abbildung.\n"
"Es ist natürlich genau die Abbildung, die eine Teilmenge von `A` auf die entsprechende Bildmenge in `B` wirft, also\n"
"```\n"
"image f = fun S ↦ f '' S\n"
"```\n"
"Du kannst also `image f` durch `f ''` ausdrücken, aber nicht umgekehrt."
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "**Robo**:  Zu zeigen ist die Übereinstimmung von zwei Abbildungen.  Erinnerst du dich an `funext`?"
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "**Robo**:  Jetzt ist die Gleichheit von zwei Mengen zu zeigen – `ext` heißt das Zauberwort."
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "**Robo**:  Das kann man bestimmt leicht vereinfachen …"
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "**Arapuka**:  Hübsch, hübsch."
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "**Robo**:  Hier ist `range f` die gesamte Bildmenge von `f`:\n"
"```\n"
"range f = {f a | a : A}\n"
"= {  b | ∃ a, f a = b}\n"
"```\n"
"Das ist also im wesentlichen eine andere Schreibweise für `f '' univ`.\n"
"Um damit zu arbeiten, ist `mem_range` ganz nützlich:\n"
"```\n"
"x ∈ range f ↔ ∃ a, f a = b\n"
"```"
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "**Robo**: Ich würde mal mit `consturctor` anfangen."
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "**Robo**: Ist nicht wieder eine Gleichheit von Mengen zu zeigen? Also `ext`."
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "**Arapuka**:  Auch schön.\n"
"\n"
"  **Robo**:  Hast du eigentlich den ganzen Planeten hier bemalt?\n"
"\n"
"  **Arapuka**:  Nein.  Das ist eine Aufgabe für Generationen.\n"
"  Die ersten Musterelement hat mein Urururur…opa geprägt.\n"
"  Ich weiß gar nicht genau, wie viele Generationen ich zurückgehen muss.\n"
"  Und erst recht nicht, woher das Urmuster kam."
msgstr ""

#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "**Arapuka**:  Könnt ihr mir vielleicht hiermit auch noch helfen?"
msgstr ""

#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "**Du**:  Hatten wir das nicht eben schon?\n"
"\n"
"**Robo**:  Nein.  Vorhin hatten wir nur die Inklusion `image_preimage_subset`:\n"
"```\n"
"f '' (f ⁻¹' T) ⊆ T\n"
"```\n"
"Jetzt ist Gleichheit zu zeigen, aber unter der zusätzlichen Annahme, dass `f` surjektiv ist."
msgstr ""

#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "**Arapuka**:  Ihr seid wirklich eine große Hilfe!"
msgstr ""

#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "**Arapuka**:  Ich habe auch noch eine Frage zu injektiven Abbildungen."
msgstr ""

#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "**Du**:  Bei `∃! a` konstruiere ich mir zunächst das Element `a`, das ich verwenden möchte …\n"
"\n"
"**Robo**: … und dann wendest du `use a` und `simp` an.  Genau."
msgstr ""

#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "Arapuka liegt immer noch ganz regungslos, aber sie sieht glücklich aus."
msgstr ""

#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "**Arapuka**: Und wie sieht es hiermit aus?"
msgstr ""

#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "**Du**:  Das soll wohl heißen:  die Faser von `b` ist genau dann leer, wenn `b` ein Urbild besitzt.\n"
"Mal wieder ziemlich offensichtlich.\n"
"\n"
"**Robo**:  Ja, bis auf Notation.\n"
"Aber zum Glück haben wir schon `eq_empty_iff_forall_not_mem` gezeigt.\n"
"Um das anzuwenden, musst du nur das Ungleichheitszeichen auflösen, zum Beispiel einfach mit `unfold Ne`."
msgstr ""

#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "**Arapuka**: Ihr habt recht.  Da hätte ich selbst drauf kommen können."
msgstr ""

#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "**Arapuka**:  Jetzt habe ich aber noch ein wirklich schwierige Aufgabe."
msgstr ""

#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "**Du**:  Mal überlegen …∪"
msgstr ""

#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "**Arapuka**:  Wow! Ihr seid wirklich großartig."
msgstr ""

#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "**Arapuka**:  Könnt ihr mir vielleicht sogar mit dieser Vermutung weiterhelfen?"
msgstr ""

#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid ""
msgstr ""

#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "**Robo**:  Eine Abbildung ist genau dann surjektiv, wenn die induzierte Abbildung `preimage f`, die eine Teilmenge auf das Urbild unter dieser Teilmenge wirft, injektiv ist?\n"
"Stimmt das überhaupt?\n"
"\n"
"**Du**: Ich glaube, ja.  Das habe ich schonmal gesehen.\n"
"\n"
"**Robo**:  Na dann, los!"
msgstr ""

#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "**Arapuka**:  Fantastisch!  Ich bin so aufgeregt, ich möchte am liebsten in die Luft springen.\n"
"  Aber das geht natürlich nicht.  Dann ist das Muster futsch.\n"
"\n"
"  **Robo**:  Wie lange hast du denn noch?\n"
"\n"
"  **Arapuka**:  Hier noch drei Jahre, 22 Tage, 7 Stunden und 35 Minuten.\n"
"\n"
"  **Robo**:  Ohh …\n"
"\n"
"  **Du**:  Und woher weißt du, wo genau du danach hingehen musst, damit das Muster passt?\n"
"\n"
"  **Arapuka**:  Ah!\n"
"\n"
"  Über Arapukas Gesicht breitet sich ein großes Lächeln aus.\n"
"\n"
"  **Arapuka**:  Das ist eben die Kunst!"
msgstr ""

#: Game.Levels.Samarkand
msgid "Samarkand"
msgstr ""

#: Game.Levels.Samarkand
msgid "In der Ferne taucht ein sehr bunter Planet auf.\n"
"Als ihr näher kommt, seht ihr, dass große Teile seiner Oberfläche mit aufwendigen geometrischen Mustern verziert sind.\n"
"Aber es gibt auch ein paar unverzierte Areale, ganz weiß.\n"
"Ihr landet in einem dieser weißen Flecken.\n"
"\n"
"\n"
"**Du**:  Huhu, ist hier jemand?\n"
"\n"
"Die Planetenoberfläche gleicht einer perfekten Sphäre. Ihr seht in alle Richtungen Horizont.\n"
"Es ist niemand zu sehen.  Ihr wollt schon wieder umdrehen, da entdeckst du etwas.\n"
"\n"
"**Du**:  Robo, schau mal da hinten, da hat der Planet eine Beule!\n"
"\n"
"Wie sich herausstellt, ist die „Beule“ eine kleine Schildkröte,\n"
"die nahe der Musterkante auf farbigem Grund liegt.\n"
"Vorsichtig betretet ihr die gemusterte Fläche.  Die Farbe scheint trocken zu sein.\n"
"\n"
"**Arapuka**: Hallo ihr beiden, kommt ruhig näher!  Schön, dass ich auch einmal Besuch bekomme.\n"
"\n"
"**Du**:  Was machst du denn hier, so ganz allein?\n"
"\n"
"**Arapuka**:  Ich arbeitet an einem großen Kunstwerk.\n"
"Ich liege hier solange, bis mein Bauchpanzer das Bodenmuster angenommen hat.\n"
"Dann laufe ich hinüber zu der Stelle, wo dieses Stück Muster noch fehlt, und lege mich dort so lange nieder, bis ich das Muster auf die weiße Planetenoberfläche transferiert habe.\n"
"Das dauert.  Ich kann also Gesellschaft gut gebrauchen.\n"
"\n"
"**Du**: Na prima."
msgstr ""

#: Game.Levels.Iso.L01_Bijective
msgid ""
msgstr ""

#: Game.Levels.Iso.L01_Bijective
msgid "**Isososoph**:  Natürlich haben auch wir etwas für euch vorbereitet."
msgstr ""

#: Game.Levels.Iso.L01_Bijective
msgid "**Robo** *(flüsternd)*: `Bijective f` ist als `Injective f ∧ Surjective f` definiert.\n"
"\n"
"**Du**: Dann ist das ja ganz simpel!"
msgstr ""

#: Game.Levels.Iso.L01_Bijective
msgid "**Isososoph**: Super.  Dann können wir das hier, glaube ich, alles überspringen …\n"
"\n"
"Er legt ein paar Blätter zur Seite."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid ""
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Isosoph**:  … und zur Hauptsache kommen."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid ""
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Du**:  Eine Abbildung ist genau dann bijektiv, wenn eine zur ihr inverse Abbildung existiert.\n"
"Das ist ja im Wesentlich dass, was wir auf Epo und Mono schon gezeigt hatten.\n"
"Hattest du dir die Aussagen abgespeichert?\n"
"\n"
"**Robo**:  Schon, aber ich glaube, wenn wir die hier auspacken, gehen die Augenbrauen nach oben.\n"
"Lass uns lieber scharf nachdenken und uns erinnern, wie das ging."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: Teil doch erst einmal `Bijective` mit `obtain ⟨hinj, hsurj⟩  := «{h}»` in\n"
"`Injective` und `Surjective` auf!"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: Aus der Surjektivität weisst du, dass jedes `y : B` ein Urbild `x : A` hat.\n"
"Kannst du daraus nicht mit `choose` eine Umkehrabbildung konstruieren?"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "Zeig am besten erst einmal, dass `«{g}»` ein Rechtsinverses von `«{f}»` ist,\n"
"also zum Beispiel `have hR : RightInverse «{g}» «{f}»`"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: Mit `simp [LeftInverse]` kannst du dir das Beweisziel etwas vereinfachen."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: Warum beginnst du nicht mit `intro`?"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: Zerlege `«{h}»` noch soweit du kannst!"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: Das UND auch noch!"
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: Injektivität ist der schwierigere Teil. Fang mal an mit `intro`."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Du**: Wenn die Argumente `f a = f b` gleich sind, ist auch `g (f a) = g (f b)` –\n"
"wie sag ich das nochmal?\n"
"\n"
"**Robo**: Also, wenn du `f a = f b` hast, kannst du ja auch einfach `rw` benutzen."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "**Robo**: Hier kannst du die `RightInverse`-Annahme mit `rw` benutzen."
msgstr ""

#: Game.Levels.Iso.L02_Inverse
msgid "Die Isosophen zeigen sich sehr zufrieden.\n"
"\n"
"**Robo**:  Können wir jetzt nochmal … kapseln?\n"
"\n"
"**Isosoph**:  Klar!  Aber immer schön der Reihe nach.\n"
"Seit wir die Kapseln in beide Richtungen benutzen, häufen sich wieder die Unfälle.\n"
"\n"
"Robo fährt noch dreimal hin und zurück.  Dann fliegt ihr weiter."
msgstr ""

#: Game.Levels.Iso
msgid "Iso"
msgstr ""

#: Game.Levels.Iso
msgid "**Du**:  Schau mal, noch ein Planet mit zwei Hochhäusern!\n"
"\n"
"**Robo**: Ja, aber die hier sind gleich hoch.  Jetzt weiß ich gar nicht mehr, wo ich landen soll.\n"
"\n"
"**Du**:  Links winken Leute!\n"
"\n"
"Also landet ihr links.\n"
"Da Empfang ist aber eher verhalten.\n"
"\n"
"**Isosoph**:  Guten Tag!\n"
"Das ist aber nicht die feine Art, hier mitten in der Menge zu landen!\n"
"Dort drüben hatten wir doch extra einen Landeplatz markiert!\n"
"\n"
"**Robo**:  Entschluldigung!  Ich hatte die Symbolik nicht erkannt.\n"
"\n"
"**Isosoph**: Ist ja nochmal gut gegangen!\n"
"Wir hatten schon gehört, dass ihr ein bisschen anders seid.\n"
"Wir zeigen euch trotzdem unser geniales Transportsystem – das fortschrittlichste Nahverkehrssystem im ganzen Formaloversum!\n"
"\n"
"Wie sich heraussstellt, ist einer der besonders fortschrittlichen Aspekte, dass man die Transportkapseln auf diesem Planeten in beide Richtungen verwenden kann.\n"
"Ihr düst ein paar Mal hin und her."
msgstr ""

#: Game.Levels.Piazza.L01_Mem__Set
msgid ""
msgstr ""

#: Game.Levels.Piazza.L01_Mem__Set
msgid "**Fin**:  Ja, klar.  Das hier zum Beispiel."
msgstr ""

#: Game.Levels.Piazza.L01_Mem__Set
msgid "**Du**:  Verstehe ich das richtig?\n"
"\n"
"**Robo**: Vermute schon.  Sieht ziemlich *tauto*logisch aus, nicht?"
msgstr ""

#: Game.Levels.Piazza.L01_Mem__Set
msgid "**Set**:  Ihr kennt euch also auch schon ein bisschen mit Mengen aus?\n"
"\n"
"**Robo**:  Naja, ein *bisschen*."
msgstr ""

#: Game.Levels.Piazza.L02_Simp
msgid ""
msgstr ""

#: Game.Levels.Piazza.L02_Simp
msgid "**Mem**:  Wie wärs denn hiermit?"
msgstr ""

#: Game.Levels.Piazza.L02_Simp
msgid "**Robo**:  Ich glaube, am einfachsten kommst du hier mit `simp` weiter."
msgstr ""

#: Game.Levels.Piazza.L02_Simp
msgid "**Robo**:  Erinner dich an `decide`."
msgstr ""

#: Game.Levels.Piazza.L02_Simp
msgid ""
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid ""
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "**Set**:  Wenn das zu einfach war – kennt ihr diese Aussage?"
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "**Du**:  `A B C : Set ℕ` heißt hier genau was?\n"
"\n"
"**Robo**:  Das heißt einfach, dass `A`, `B` und `C` *Teilmengen* von `ℕ` sind.\n"
"\n"
"**Du**:  `Set` bedeutet „subset“?\n"
"\n"
"**Robo**:  Wenn du so willst, ja.\n"
"\n"
"**Du**:  Dann *kenne* ich die Aussage wohl.\n"
"Aber keine Ahnung, wie ich die hier beweisen könnte.\n"
"\n"
"**Ext**:  Kann ich dir sagen!  Da gibts ein Zauberwort, das heißt genau wie ich!!\n"
"\n"
"**Robo**:  Ach ja –\n"
"`ext x` ersetzt eine Mengengleichheit `A = B` durch `x ∈ A ↔ x ∈ B`."
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "**Robo**:  Und jetzt wieder `simp`."
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "**Du**:  Was genau macht `simp` denn eigentlich?\n"
"\n"
"**Robo**:  `simp` sucht nach allgemein bekannten Gleichungen und Äquivalenzen,\n"
"die gemeinhin als Vereinfachungen angesehen werden, und die gerade anwendbar wären.\n"
"Alle Vereinfachungen, die `simp` findet, wendet es an.\n"
"Gerade waren das beispielsweise Vereinfachungen der Form\n"
"```\n"
"«{x}» ∈ «{A}» ∩ «{B}» ↔ «{x}» ∈ «{A}» ∧ «{x}» ∈ «{B}»\n"
"```\n"
"und\n"
"```\n"
"«{x}» ∈ «{B}» ∪ «{C}» ↔ «{x}» ∈ «{B}» ∨ «{x}» ∈ «{C}».\n"
"```"
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "**Robo**:  Den Rest schafft bestimmt `tauto`."
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid ""
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid ""
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "**Sub:** Ich habe auch schon etwas gelernt:"
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "**Du**:  Was ist denn `univ`?\n"
"\n"
"**Robo**:  `univ` ist die maximale Teilmenge:  alle natürlichen Zahlen.\n"
"\n"
"**Du**:  Also einfach `ℕ`?\n"
"\n"
"**Robo**:  Jein. `univ : Set ℕ` ist “ganz ℕ”, aber aufgefasst als *Teilmenge* von `ℕ`.\n"
"\n"
"Ext, Fin, Set, Sub und Mem sehen euch groß an.\n"
"\n"
"**Set**:  Das kann man doch gar nicht verwechseln!  Hier *ist* eine Blaubeere,\n"
"das hier ist der *Korb mit allen Blaubeeren*, und die Beere *liegt in* diesem Korb.\n"
"\n"
"**Mem**:  Und genauso *ist* 5 eine natürlich Zahl (`5 : ℕ`),\n"
"`univ : Set ℕ` ist die *Menge aller natürlicher Zahlen*, und `5` *liegt in* dieser Menge (`5 ∈ univ`).\n"
"Was ist daran verwirrend?\n"
"\n"
"**Robo** (*zu dir*):  Zerbrich dir nicht den Kopf darüber.\n"
"Ich schlage vor, du fängst hier einfach mal mit `rw [eq_univ_iff_forall]` an,\n"
"dann siehst du genau, was gefragt ist."
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "**Robo**: Und jetzt `simp`.  Du hättest sogar direkt `simp [eq_univ_iff_forall]` nehmen können."
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "**Du**: Und jetzt `by_cases h : Even n`?\n"
"\n"
"**Robo**: Ja, das würde zum Ziel führen.\n"
"Aber eigentlich ist `Even x ∨ ¬Even x` ja eine Tautologie.\n"
"Damit `tauto` sie erkennt, musst du sie nur entsprechend abstrahieren.\n"
"Das ginge hier zum Beispiel mit:\n"
"```\n"
"generalize h : (Even x) = A\n"
"```"
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid ""
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid ""
msgstr ""

#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid ""
msgstr ""

#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid "**Mem:** Findet ihr diese Aussage auch wieder verwirrend?"
msgstr ""

#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid "**Du**: Nein, `∅` kenne ich.\n"
"\n"
"**Robo**: Um ganz sicher zu gehen, dass du das richtig verstehst,\n"
"könntest du auch mit `rw [eq_empty_iff_forall_not_mem]` anfangen.\n"
"Oder mit `simp [eq_empty_iff_forall_not_mem]`, falls du schnell fertig werden möchtest."
msgstr ""

#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid ""
msgstr ""

#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid ""
msgstr ""

#: Game.Levels.Piazza.L06_Ext2__univ2
msgid ""
msgstr ""

#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "**Ext**:  Ich mag *diese* Gleichung."
msgstr ""

#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "**Robo**: Diesmal kannst du einfach wieder `ext` verwenden."
msgstr ""

#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "**Robo**: Und jetzt natürlich wieder `simp`."
msgstr ""

#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "**Du** *(zu Robo)*:  Warum heißt ext eigentlich ext?\n"
"\n"
"  **Robo**:  Woher soll ich wissen, woher der Junge seinen Namen hat??\n"
"\n"
"  **Du**: Nein, ich meine dieses `ext` hier!\n"
"\n"
"  **Robo**: Ach so. Das Prinzip, dass zwei Mengen genau dann gleich sind,\n"
"  wenn sie dieselben Elemente besitzen, nennen Logiker *extensionality*.\n"
"  Und daraus haben die Formalosophen wohl *ext* gemacht, weil es ihnen sonst zu lang war."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "**Set**: Und ich mag diese Äquivalenz."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "**Du**:  Ja, ich glaube, so habe ich das einmal gelernt\n"
"– zwei Mengen sind gleich, wenn sie sich wechselseitig enthalten."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "**Robo**:  Ich weiß nicht, aber ich würde mit `constructor` anfangen."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "**Robo**: Ersetz mal `«{A}»` durch `«{B}»`."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "**Robo**: Ab hier müsste das Schema von eben wieder passen."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid "**Sub**:  Du hast Recht.\n"
"Wir sollten die Besucher mal etwas mehr über Inklusionen ausfragen."
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid "**Robo**: Das ist doch nur die Definition!\n"
"\n"
"**Robo** *(zu dir)*: Probier mal `tauto`.  Oder gleich `rfl`."
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid ""
msgstr ""

#: Game.Levels.Piazza.L09_subset_iff2
msgid ""
msgstr ""

#: Game.Levels.Piazza.L09_subset_iff2
msgid "**Sub**:  So, so.  Nur eine Definition!\n"
"Und wenn ihr nun mit solchen Inklusionen arbeiten sollt?"
msgstr ""

#: Game.Levels.Piazza.L09_subset_iff2
msgid "**Du**:  Kann ich hier auch irgendwie mit `ext` argumentieren?\n"
"\n"
"**Robo**:  Nein, viel einfacher.  Gib dir einfach mit `intro a` ein beliebiges\n"
"Element aus `A` vor, und zeige, dass es in `C` liegt.\n"
"\n"
"Aber vielleicht schreibst du vorher doch einmal alle Inklusionen mit\n"
"`rw [subset_iff] at *` aus, damit du siehst, was passiert."
msgstr ""

#: Game.Levels.Piazza.L09_subset_iff2
msgid ""
msgstr ""

#: Game.Levels.Piazza.L10
msgid ""
msgstr ""

#: Game.Levels.Piazza.L10
msgid "**Mem**:  Lasst mich auch noch einmal eine Frage stellen!"
msgstr ""

#: Game.Levels.Piazza.L10
msgid "**Robo**:  Ich würde wieder mit `intro` anfangen."
msgstr ""

#: Game.Levels.Piazza.L10
msgid "**Robo**:  Und noch ein `intro`!"
msgstr ""

#: Game.Levels.Piazza.L10
msgid "**Mem**:  Ja super, ihr habt aber schnell gelernt!"
msgstr ""

#: Game.Levels.Piazza.L11_erase
msgid ""
msgstr ""

#: Game.Levels.Piazza.L11_erase
msgid "**Mem**:  Hey, Fin, wachst machst Du denn da?\n"
"\n"
"Fin ist der kleinste in der Runde und hat bislang nichts gesagt.\n"
"Und jetzt hat er anscheinend gerade vom Stand nebenan eine Pistazie geklaut.\n"
"\n"
"**Fin**:  Ist doch nur eine kleine Übung.\n"
"\n"
"**Mem**: Was für eine Übung?\n"
"\n"
"Fin erklärt sich folgendermaßen."
msgstr ""

#: Game.Levels.Piazza.L11_erase
msgid "**Du**:  Was bedeutet denn hier jetzt `Finset`?\n"
"\n"
"**Robo**:  Das bedeutet, dass `A` zu den *endlichen* Teilmengen von ℕ gehört.\n"
"Macht aber für die Frage eigentlich keinen Unterschied.\n"
"Links steht `A` ohne `a`, rechts steht auch `A` ohne `a`."
msgstr ""

#: Game.Levels.Piazza.L11_erase
msgid ""
msgstr ""

#: Game.Levels.Piazza.L12_insert
msgid ""
msgstr ""

#: Game.Levels.Piazza.L12_insert
msgid "**Fin**:  Richtig.   Und jetzt lege ich meine Pistazie wieder zurück."
msgstr ""

#: Game.Levels.Piazza.L12_insert
msgid ""
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid ""
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid "**Fin**:  Und, was meint ihr – sind jetzt wieder alle Pistazien zu Hause?"
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid ""
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid "**Fin**: Mach doch eine Fallunterscheidung, ob `«{b}» = a` ist oder nicht."
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid "**Fin**:  Ja, so kann man das angehen."
msgstr ""

#: Game.Levels.Piazza.L13_insert_erase
msgid "Die Kinder lachen, bilden einen Kreis um euch um singen ein Lied in einer Sprache,\n"
"die ihr beide nicht versteht.  Dann laufen sie davon.\n"
"\n"
"**Robo**:  Ich glaube, wir können weiterfliegen."
msgstr ""

#: Game.Levels.Piazza
msgid "Piazza"
msgstr ""

#: Game.Levels.Piazza
msgid "Wie es aussieht, seid ihr auf einem Handelsplaneten gelandet.\n"
"Überall stehen Händler, die ihre Waren feilbieten.\n"
"Ihr beäugt neugierig ein paar Stände.\n"
"Manches sieht vertraut und essbar aus, vieles nicht.\n"
"Aber alles ist fein säuberlich sotiert.\n"
"Es gibt Körbe mit Blaubeeren (?), Kisten mit roten Gewächsen, die euch an Tomaten erinnern,\n"
"offene Säcke mit kleinen, rosa Sternchen, usw.\n"
"\n"
"Ein paar Kinder – oder jedenfalls ein paar recht kleine Formalosophen, die sich wie Kinder zu verhalten – laufen euch fast über die Füße.\n"
"Robo springt zurück, da bemerken sie euch und bleiben stehen.  Sie stellen sich als „Fin“, „Ext“, „Mem“, „Set“ und „Sub“ vor, und wirken neugierig.\n"
"\n"
"**Fin**:  Was macht ihr denn hier?\n"
"\n"
"**Du**:  Ehm … wir wollten uns nur mal ein bisschen umschauen.\n"
"\n"
"**Set**: Wir sind hier, um etwas Mengentheorie zu lernen.  Unsere Eltern haben uns hier ausgesetzt.\n"
"\n"
"**Ext**:  Zu Schulungszwecken, sozusagen.\n"
"\n"
"**Du**:  Und, habt ihr schon etwas gelernt?"
msgstr ""

#: Game
msgid "Robo"
msgstr ""

#: Game
msgid "# Game Over oder QED?\n"
"\n"
"Bist du neugierig, wie sich computer-unterstützte Beweisführung mit „echter“ Mathematik anfühlt?\n"
"Dann bist du hier genau richtig!\n"
"In diesem Spiel lernst du, mit dem Beweisassistenten Lean 4 und der Beweisbibliothek Mathlib zu arbeiten.\n"
"\n"
"Das Interface ist etwas vereinfacht, aber wenn du den *Editor Mode* aktivierst, fühlt es sich\n"
"fast genauso an wie in VSCode, der Standard-IDE für Lean.\n"
"\n"
"Rechts siehst du eine Übersicht. Das Spiel besteht aus mehreren Planeten, und jeder Planet hat mehrere Levels,\n"
"die in Form von grauen Punkten dargestellt sind. Gelöste Levels werden grün.\n"
"\n"
"Klicke auf den ersten Planeten *Logo*, um deine Reise zu starten.\n"
"\n"
"## Spielstand\n"
"\n"
"Dein Spielstand wird lokal in deinem Browser als *site data* gespeichert.\n"
"Solltest du diese löschen, verlierst du deinen Spielstand!\n"
"Viele Browser löschen *site data* und *cookies* zusammen.\n"
"Du kannst den Spielstand aber auch über das Menü herunterladen und manuell speichern.\n"
"\n"
"## Spielregeln\n"
"\n"
"Wenn du ernsthaft spielen möchtest, solltest du *Rules: regular* wählen.\n"
"Wenn du dich nur ein bisschen umsehen möchtest, wähle *Rules: relaxed*\n"
"  – dann kannst du jedes Level spielen, auch wenn du vorhergende Levels noch nicht gelöst hast.\n"
"\n"
"Hintergrundinfos findest du im Menü unter *Game Info*."
msgstr ""

#: Game
msgid "## Projekt ADAM\n"
"\n"
"Dieses Lernspiel wurde im Rahmen des Projekts\n"
"[ADAM: Anticipating the Digital Age of Mathematics](https://hhu-adam.github.io/)\n"
"an der Heinrich-Heine-Universität Düsseldorf entwickelt,\n"
"finanziert durch das Programm *Freiraum 2022* der *Stiftung Innovation in der Hochschullehre*.\n"
"\n"
"## Credits\n"
"\n"
"* **Projektleitung:** Marcus Zibrowius, Immi Halupczok\n"
"* **Game Engine:** Jon Eugster, Alexander Bentkamp, Patrick Massot – siehe [lean4game](https://github.com/leanprover-community/lean4game?tab=readme-ov-file#credits)\n"
"* **Levels:** Jon Eugster, Marcus Zibrowius, Sina Hazratpour\n"
"* **Konzept & Handlung:** Marcus Zibrowius\n"
"* **Illustrationen:** [Dušan Pavlić](https://www.behance.net/dusanpavlic#)\n"
"\n"
"## Kontakt\n"
"\n"
"Das Spiel wird laufend überarbeitet.\n"
"Wenn du Anregungen hast oder Bugs findest, schreib doch ein Email an\n"
"[Marcus Zibrowius](https://www.math.uni-duesseldorf.de/~zibrowius/)\n"
"oder erstelle einen Issue auf GitHub:\n"
"\n"
"* zum Spielinhalt im [Robo repo](https://github.com/hhu-adam/Robo/issues).\n"
"* zum Spielserver im [lean4game repo](https://github.com/leanprover-community/lean4game/issues)."
msgstr ""

#: Game
msgid "QED"
msgstr ""

#: Game
msgid "Erkunde ein fremdes Universum mit deinem Smart-Elf Robo!"
msgstr ""

#: Game
msgid "Dieses Spiel illustriert Beweisführung mit Lean anhand verschiedener Themen aus der Eingangsphase des Bachelorstudiums Mathematik."
msgstr ""
