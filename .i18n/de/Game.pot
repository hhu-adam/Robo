msgid ""
msgstr "Project-Id-Version: Game v4.22.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-21\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: de\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L13_insert_erase
msgid "ยง0 Intro Piazza L13"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L03_Apply
msgid "ยง0 Conclusion Implis L03"
msgstr ""

#. ยง0: `apply congr_fun at h`
#. ยง1: `rw [โ comp_apply (f:= f)]`
#. ยง2: `rw [โ comp_apply]`
#. ยง3: `(f:=f)`
#. ยง4: `f`
#. ยง5: `comp_apply`
#: Game.Levels.Epo.L04_RightInverse
msgid "Try ยง0 or ยง1.\n"
"ยง2 without ยง3 does not work. You must explicitly point out which value\n"
"the variable ยง4 should have in statment ยง5."
msgstr ""

#. ยง0: `TITLE`
#: Game
msgid "ยง0 Robo"
msgstr ""

#. ยง0: `(g โ f) ยซ{x}ยป`
#. ยง1: `g (f ยซ{x}ยป)`
#. ยง2: `simp`
#: Game.Levels.Vieta.L06_Piecewise
msgid "Rewrite ยง0 to ยง1 via ยง2"
msgstr ""

#. ยง0: `constructor`
#. ยง1: `โข A โง B`
#. ยง2: `โข A`
#. ยง3: `โข B`
#. ยง4: `โข A โ B`
#. ยง5: `โข A โ B`
#. ยง6: `โข B โ A`
#. ยง7: `obtain`
#. ยง8: `A โจ B`
#. ยง9: `left`
#. ยง10: `right`
#: Game.Doc.Tactic
msgid "The ยง0 tactic breaks down a proof goal into its constituent parts:\n"
"\n"
"| before | after                |\n"
"|:------------ |:----------------------- |\n"
"| ยง1    | ยง2 and ยง3         |\n"
"| ยง4    | ยง5 and ยง6 |\n"
"\n"
"## Friends and relatives\n"
"\n"
"* You can break down an *assumption* into its components using ยง7.\n"
"* If you want to prove ยง8, you have to choose one side using ยง9 or ยง10."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Spinoza.L03_ByContra
msgid "ยง0 Conclusion Spinoza L03"
msgstr ""

#. ยง0: `ยซ{f}ยป`
#. ยง1: `ยซ{ha}ยป`
#: Game.Levels.Mono.L01_Injective
msgid "Use ยง0 to simplify assumption ยง1"
msgstr ""

#. ยง0: `rw [ยซ{h}ยป]`
#. ยง1: `apply (ยซ{h}ยป.mp)`
#. ยง2: `obtain โจmp, mprโฉ := ยซ{h}ยป`
#: Game.Levels.Implis.L11_Iff
msgid "Instead of ยง0 and ยง1 try ยง2"
msgstr ""

#. ยง0: `congr_arg`
#. ยง1: `x = y`
#. ยง2: `f x = f y`
#. ยง3: `apply congr_arg`
#: Game.Levels.Vieta.L08_CongrArg
msgid "Try ยง0. If ยง1, then ยง2 when using ยง3"
msgstr ""

#. ยง0: `preimage f`
#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "Explain surcetivity by ยง0"
msgstr ""

#. ยง0: `A โจ B`
#. ยง1: `right`
#. ยง2: `left`
#: Game.Doc.Tactic
msgid "If the proof target is of the form ยง0, you choose ยง1 to show the right side.\n"
"\n"
"## Friends and relatives\n"
"\n"
"With ยง2, you choose the left side accordingly."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Saturn.L02_Ring_add_pow_two
msgid "ยง0 Intro Saturn L02"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L09_PushNeg
msgid "ยง0 Conclusion Quantus L09"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "ยง0 Conclusion Samarkand L07"
msgstr ""

#. ยง0: `push_neg`
#. ยง1: `DOC`
#: Game.Levels.Quantus.L09_PushNeg
msgid "In lieu of this theorem you can use ยง0. ยง1"
msgstr ""

#. ยง0: `Function.RightInverse f g`
#. ยง1: `LeftInverse g f`
#. ยง2: `โ x, g (f x) = x`
#. ยง3: `Function.RightInverse`
#. ยง4: `RightInverse`
#. ยง5: `RightInverse`
#: Game.Doc.Definition
msgid "ยง0 is defined as ยง1.\n"
"In other words: ยง2.\n"
"\n"
"You have to write ยง3  instead of ยง4,\n"
"as ยง5 is ambigous in Leanic."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "ยง0 Conclusion Mono L09"
msgstr ""

#. ยง0: `f ยซ{A}ยป`
#: Game.Levels.Robotswana.L10_Characterize
msgid "Rewrite ยง0 as sum of basis elements"
msgstr ""

#. ยง0: `omega`
#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "Intro Luna L10: Use ยง0 again"
msgstr ""

#. ยง0: `ยซ{b}ยป`
#. ยง1: `a`
#. ยง2: `intro`
#: Game.Levels.Euklid.L02_prod_insert
msgid "Goal: if ยง0 divides factor ยง1 of a product then it also divides the product.\n"
"Try ยง2"
msgstr ""

#. ยง0: `obtain โจhโ, hโโฉ := ยซ{h}ยป`
#. ยง1: `\\<>`
#: Game.Levels.Logo.L13_Or
msgid "Try ยง0. Write brackets as ยง1"
msgstr ""

#. ยง0: `(A : Prop)`
#. ยง1: `(True : Prop)`
#. ยง2: `(False : Prop)`
#: Game.Doc.Definition
msgid "ยง0 is any statement, without further specification as to whether it is true, false, or\n"
"unprovable.\n"
"\n"
"See also ยง1 and ยง2 for the unconditionally true and false\n"
"statements, respectively."
msgstr ""

#. ยง0: `rw [hโ]`
#. ยง1: `rw [โ hโ]`
#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "Try if ยง0 and ยง1 can be used as in Implis"
msgstr ""

#. ยง0: `ยฌ`
#: Game.Levels.Quantus.L09_PushNeg
msgid "Remind about ยง0"
msgstr ""

#. ยง0: `A ร A`
#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
msgid "Intro Cantor L08: Mapping defined on product ยง0 with diagonal"
msgstr ""

#. ยง0: `f`
#. ยง1: ```
#. โ โฆa bโฆ, a < b โ f a < f b
#. ```
#: Game.Doc.Definition
msgid "A mapping ยง0 is strictly monotonous, if:\n"
"\n"
"ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L10
msgid "ยง0 Intro Piazza L10"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L01_Mem__Set
msgid "ยง0 Intro Piazza L01"
msgstr ""

#. ยง0: `x โ y`
#. ยง1: `ยฌ x = y`
#. ยง2: `unfold Ne`
#: Game.Doc.Definition
msgid "Inequality ยง0 is defined as ยง1.  You can see this with ยง2."
msgstr ""

#. ยง0: `by_contra g`
#: Game.Levels.Spinoza.L06_Summary
msgid "This time start with ยง0"
msgstr ""

#. ยง0: `โ! a`
#. ยง1: `a`
#. ยง2: `use a`
#. ยง3: `simp`
#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "Try ยง0 to construct ยง1, Try ยง2 and ยง3"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "ยง0 Conclusion Robotswana L04"
msgstr ""

#. ยง0: `ext`
#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "Again show equality of sets by using ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "ยง0 Conclusion Samarkand L01"
msgstr ""

#. ยง0: `apply sum_congr`
#: Game.Levels.Babylon.L03_sum_congr
msgid "try ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "ยง0 Intro Piazza L04"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Luna.L07_Linarith2
msgid "ยง0 Conclusion Luna L07"
msgstr ""

#. ยง0: `ยซ{h}ยป : ยซ{A}ยป`
#. ยง1: `suffices`
#. ยง2: `suffices k : B`
#: Game.Levels.Spinoza.L03_ByContra
msgid "Apply contradiction with ยง0 via ยง1 with ยง2"
msgstr ""

#. ยง0: `lt_trichotomy`
#: Game.Levels.Mono.L06_StrictMono
msgid "Try case distinction. Use ยง0"
msgstr ""

#: Game
msgid "Dieses Spiel illustriert Beweisfรผhrung mit Lean anhand verschiedener Themen aus der Eingangsphase des Bachelorstudiums Mathematik."
msgstr ""

#: Game.Levels.Iso
msgid "Iso"
msgstr ""

#. ยง0: `if โฆ then โฆ else`
#. ยง1: `fun x โฆ if 0 โค x then x else -x`
#. ยง2: `h : A`
#. ยง3: `rw [if_pos h]`
#. ยง4: `if A then B else C`
#. ยง5: `B`
#. ยง6: `h : ยฌ A`
#. ยง7: `rw [if_neg h]`
#. ยง8: `if A then B else C`
#. ยง9: `C`
#: Game.Doc.Tactic
msgid "With ยง0, you can define mappings with two branches of definition.\n"
"\n"
"For example, ยง1 defines the absolute value function.\n"
"\n"
"## Friends and relatives\n"
"\n"
"* If you have ยง2 as an assumption, you can use\n"
"ยง3 to reduce the expression ยง4 to ยง5.\n"
"* If you have ยง6 as an assumption, you can use\n"
"ยง7 to reduce the expression ยง8 to ยง9."
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Piazza.L01_Mem__Set
msgid "ยง0 try tauto"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "ยง0 Intro Robotswana L08"
msgstr ""

#. ยง0: `a โฃ b`
#. ยง1: `โ k, b = a * k`
#. ยง2: ```
#. rw [dvd_iff_exists_eq_mul_left] at *
#. ```
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "ยง0 is defined as ยง1. State is explicitly with\n"
"ยง2\n"
""
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Mono.L03_NotInjective
msgid "ยง0 Provide a counter example"
msgstr ""

#. ยง0: `have h : P`
#. ยง1: `suffices h : P`
#: Game.Doc.Tactic
msgid "With ยง0, you introduce an intermediate result.\n"
"You must then prove this intermediate result\n"
"before you can continue with the actual proof.\n"
"\n"
"## Friends and relatives\n"
"ยง1 works in exactly the same way, except that you can continue with the main proof first and\n"
"only have to prove your intermediate result at the very end."
msgstr ""

#. ยง0: `1 ยซ{i}ยป ยซ{i}ยป`
#. ยง1: `1 โข _`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Explain simplification of ยง0 and ยง1"
msgstr ""

#. ยง0: `(ยซ{A}ยป โง ยซ{B}ยป) โจ ยซ{A}ยป`
#. ยง1: `obtain โฆ`
#. ยง2: `obtain โจhโ, hโโฉ := ยซ{h}ยป`
#. ยง3: `obtain h | h := ยซ{h}ยป`
#: Game.Levels.Logo.L13_Or
msgid "Observe goal as ยง0.\n"
"Do not try ยง1 as ยง2 but as ยง3"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Epo
msgid "ยง0 Intro Epo"
msgstr ""

#. ยง0: `โง`
#. ยง1: `โจ`
#. ยง2: `obtain โจhโ, hโโฉ := h`
#. ยง3: `obtain h \\| h := h`
#. ยง4: `constructor`
#. ยง5: `left`
#. ยง6: `right`
#: Game.Levels.Logo.L14_Summary
msgid "Intro Logo L14: The most important tactics of this chapter concerning ยง0 and ยง1.\n"
"For both logical operations the tactis ยง2 and ยง3 can be used respectivelly.\n"
"Analogously, when working with the goal ยง4 and ยง5/ยง6 can be used respectivelly as well."
msgstr ""

#. ยง0: `f`
#. ยง1: `A`
#. ยง2: `A`
#. ยง3: `A`
#. ยง4: `f`
#: Game.Levels.Cantor.L01_CantorPowerset
msgid "Intro Cantor L01: Mapping ยง0 from ยง1 to the power set of ยง2, and the set\n"
"of all elements in ยง3, which are not located in its image under ยง4"
msgstr ""

#. ยง0: `suffices g : B`
#: Game.Levels.Spinoza.L04_ByContra
msgid "Provoce contradiction by using ยง0"
msgstr ""

#. ยง0: `y : B`
#. ยง1: `x : A`
#. ยง2: `choose`
#: Game.Levels.Iso.L02_Inverse
msgid "Surjectivity states that each ยง0 possesses a preimage ยง1.\n"
"Try to construct a inverse mapping via ยง2"
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.Euklid.L02_prod_insert
msgid "Disect ยง0 into its constituents"
msgstr ""

#. ยง0: `(hp : Prime p)`
#. ยง1: `p`
#. ยง2: `rw [prime_def] at hp`
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "ยง0 is the assumption that ยง1 is prime. Use ยง2"
msgstr ""

#. ยง0: `push_neg`
#: Game.Levels.Mono.L03_NotInjective
msgid "Remind yourself of ยง0"
msgstr ""

#. ยง0: `f a = f b`
#. ยง1: `g (f a) = g (f b)`
#. ยง2: `f a = f b`
#. ยง3: `rw`
#: Game.Levels.Iso.L02_Inverse
msgid "Try to state that if ยง0 then also ยง1.\n"
"When ยง2 available use ยง3."
msgstr ""

#. ยง0: `โ`
#. ยง1: `โ`
#. ยง2: `intro`
#. ยง3: `revert`
#. ยง4: `intro`
#. ยง5: `apply`
#. ยง6: `apply at`
#. ยง7: `symm`
#. ยง8: `A โ B`
#. ยง9: `B โ A`
#. ยง10: `trans`
#. ยง11: `A โ C`
#. ยง12: `A โ B`
#. ยง13: `B โ C`
#. ยง14: `rw [h] `
#. ยง15: `h`
#. ยง16: `rw [h] at hโ`
#. ยง17: `hโ`
#. ยง18: `h`
#. ยง19: `by_cases h : P`
#. ยง20: `P`
#. ยง21: `ยฌP`
#: Game.Levels.Implis.L14_Summary
msgid "Intro Implis L14: This chapter used the following operations:\n"
"ยง0, ยง1, ยง2, ยง3 (reversal of ยง4), ยง5, ยง6, ยง7 (changes ยง8 to ยง9),\n"
"ยง10 (changes ยง11 to ยง12 and ยง13), ยง14 (rewrite goal with ยง15), ยง16 (rewrite\n"
"assumption ยง17 using ยง18) and ยง19 (introduce cases ยง20 and ยง21)"
msgstr ""

#. ยง0: `induction n`
#. ยง1: `n`
#. ยง2: `induction n with d dh`
#. ยง3: `d`
#. ยง4: `hd`
#. ยง5: `n = 0`
#. ยง6: `hd`
#. ยง7: `induction`
#. ยง8: `induction'`
#. ยง9: `0`
#. ยง10: `Nat.zero`
#. ยง11: `d + 1`
#. ยง12: `Nat.succ d`
#. ยง13: `zero_eq`
#. ยง14: `Nat.succ_eq_add_one`
#: Game.Doc.Tactic
msgid "The tactic ยง0 performs an inductive proof over ยง1.\n"
"With ยง2, you can specify names for the induction variable (here: ยง3)\n"
"and the induction assumption (here: ยง4).\n"
"The tactic thus replaces the original proof goal with two new proof goals:\n"
"* an induction start, in which ยง5 is set, and\n"
"* an induction step, in which the induction assumption ยง6 is available to you.\n"
"\n"
"## Modifications in this game\n"
"\n"
"Outside of this game, ยง7 is called ยง8,\n"
"ยง9 is initially written as ยง10 and ยง11 as ยง12.\n"
"These terms are identical in definition, but occasionally need to be explicitly rewritten with\n"
"ยง13 and ยง14."
msgstr ""

#. ยง0: `arithmetic_sum`
#: Game.Levels.Babylon.L09_Boss
msgid "Use ยง0 as its already proven"
msgstr ""

#. ยง0: `Odd 3`
#: Game.Levels.Mono.L05_StrictMono
msgid "ยง0 is trivial"
msgstr ""

#. ยง0: `Set A`
#. ยง1: `A`
#. ยง2: `A`
#: Game.Levels.Cantor.L01_CantorPowerset
msgid " ยง0 is akin to the power set of ยง1, more precisely, it is the type of all subsets of ยง2."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L08_PushNeg
msgid "ยง0 Intro Quanus L08"
msgstr ""

#. ยง0: `HasRightInverse f`
#. ยง1: `f`
#. ยง2: `HasLeftInverse f`
#. ยง3: `f`
#: Game.Doc.Definition
msgid "ยง0 means, that ยง1 has a right inverse.\n"
"\n"
"ยง2 means, that ยง3 has left inverse."
msgstr ""

#. ยง0: `COMMENT-2`
#: Game.Levels.Implis.L11_Iff
msgid "ยง0 Start with implication"
msgstr ""

#. ยง0: `use r`
#. ยง1: `use 2 * s^2`
#: Game.Levels.Quantus.L04_Exists
msgid "Try ยง0 or instead ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L05_Apply
msgid "ยง0 Conclusion Implis L05"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Logo.L09_Contradiction
msgid "ยง0 Try the Contradiction tactic"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L02_Revert
msgid "ยง0 Intro Implis L02"
msgstr ""

#. ยง0: `โ! m, P(m)`
#. ยง1: `m`
#. ยง2: `P(m)`
#. ยง3: `m`
#. ยง4: `P(m)`
#. ยง5: `m'`
#. ยง6: `P(m')`
#. ยง7: `m`
#. ยง8: `m`
#. ยง9: `use _`
#: Game.Levels.Prado.L09_ExistsUnique
msgid "ยง0 is notation for 'there exists exactly one ยง1 for which ยง2 holds'.\n"
"It is defined as 'There exists a ยง3 , s.t., ยง4 holds, and each other element ยง5, for which\n"
"ยง6 holds, is equal to ยง7'. Try finding an appropriate ยง8 and apply ยง9"
msgstr ""

#. ยง0: `sum_insert`
#. ยง1: $[0,ยซ{d}ยป]$
#. ยง2: $ยซ{d}ยป+1$
#. ยง3: `rw [sum_insert]`
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "ยง0 will divide sum as wished: a sum over ยง1 and an additional summand for ยง2.\n"
"Try ยง3"
msgstr ""

#: Game.Levels.Luna
msgid "Luna"
msgstr ""

#. ยง0: `generalize`
#. ยง1: `generalize h : a = b`
#. ยง2: `a`
#. ยง3: `b`
#. ยง4: `h : a = b`
#. ยง5: ```
#. Even x โจ ยฌEven x
#. ```
#. ยง6: ```
#. generalize h : (Even x) = A
#. ```
#. ยง7: ```
#. A โจ ยฌA
#. ```
#. ยง8: `tauto`
#: Game.Doc.Tactic
msgid "With ยง0, you can generalize a proof goal\n"
"in the hope that a higher level of abstraction will allow for a simpler proof.\n"
"More precisely, ยง1 replaces all occurrences of ยง2 in the proof goal with ยง3\n"
"(and adds the assumption ยง4).\n"
"\n"
"## Example\n"
"\n"
"A goal of the form\n"
"ยง5\n"
"can be converted with\n"
"ยง6\n"
"into\n"
"ยง7\n"
"(and then simply proven with ยง8)."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L11_Linearity
msgid "ยง0 Conclusion Robotswana L11"
msgstr ""

#: Game.Levels.Epo
msgid "Epo"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
msgid "ยง0 Conclusion Euklid L04"
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.Spinoza.L04_ByContra
msgid "Start trying with ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "ยง0 Intro Samarkand L05"
msgstr ""

#. ยง0: `=`
#. ยง1: `โ`
#. ยง2: `rw`
#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "Explain that ยง0 and ยง1 with ยง2 can be used as in Implis"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L03_sum_congr
msgid "ยง0 Intro Babylon L03"
msgstr ""

#. ยง0: `IN_HINT 3`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "ยง0 Try again"
msgstr ""

#. ยง0: `ring`
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "Rewrite so you can use ยง0"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Luna.L04_Omega2
msgid "ยง0 Try omega"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Prado.L10_EvenPrime
msgid "ยง0 Conclusion Prado L10"
msgstr ""

#. ยง0: `Finset`
#. ยง1: `A`
#. ยง2: `A`
#. ยง3: `a`
#. ยง4: `A`
#. ยง5: `a`
#: Game.Levels.Piazza.L11_erase
msgid "ยง0 here means that ยง1 belongs to the finite subsets of โ.\n"
"Left it states ยง2 without ยง3 and on the right it also says ยง4 without ยง5"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Euklid.L01_prod_pos
msgid "ยง0 Intro Euklid L01"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L06_Not
msgid "ยง0 Conclusion Logo L06"
msgstr ""

#. ยง0: `funext r s`
#. ยง1: $(r,s)$
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Try ยง0 to focus on position ยง1."
msgstr ""

#. ยง0: `simp`
#. ยง1: `simp`
#. ยง2: `simp`
#. ยง3: ```
#. ยซ{x}ยป โ ยซ{A}ยป โฉ ยซ{B}ยป โ ยซ{x}ยป โ ยซ{A}ยป โง ยซ{x}ยป โ ยซ{B}ยป
#. ```
#. ยง4: ```
#. ยซ{x}ยป โ ยซ{B}ยป โช ยซ{C}ยป โ ยซ{x}ยป โ ยซ{B}ยป โจ ยซ{x}ยป โ ยซ{C}ยป.
#. ```
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "Explain ยง0: ยง1 looks for known equations and equivalences which would be currently\n"
"applicable. ยง2 uses all simplifications it can find. Currently the following simplifications\n"
"were performed:\n"
"ยง3\n"
"and\n"
"ยง4\n"
""
msgstr ""

#. ยง0: `Injective`
#. ยง1: `unfold`
#. ยง2: `ยฌ โ`
#: Game.Levels.Mono.L03_NotInjective
msgid "Open ยง0 via ยง1 to see ยง2 ..."
msgstr ""

#. ยง0: `Prime.dvd_mul`
#: Game.Levels.Prado.L07_dvd_mul
msgid "Intro Prado L07: Use lemma ยง0"
msgstr ""

#. ยง0: `INFO`
#: Game
msgid "ยง0\n"
"## Project ADAM\n"
"\n"
"This educational game was developed as part of the project\n"
"[ADAM: Anticipating the Digital Age of Mathematics](https://hhu-adam.github.io/)\n"
"at Heinrich Heine University Dรผsseldorf,\n"
"funded by the *Freiraum 2022* program of the *Stiftung Innovation in der Hochschullehre* (Foundation for Innovation in Higher Education).\n"
"\n"
"## Game content\n"
"\n"
"**Spoiler alert** You can find an overview of the rough mathematical content of all planets on [Github](https://github.com/hhu-adam/Robo?tab=readme-ov-file#overview-over-existing-content).\n"
"\n"
"## Credits\n"
"\n"
"* **Project management:** Marcus Zibrowius, Immi Halupczok\n"
"* **Game engine:** Jon Eugster, Alexander Bentkamp, Patrick Massot โ see [lean4game](https://github.com/leanprover-community/lean4game?tab=readme-ov-file#credits)\n"
"* **Levels:** Jon Eugster, Marcus Zibrowius, Sina Hazratpour\n"
"* **Concept & Story:** Marcus Zibrowius\n"
"* **Illustrations:** [Duลกan Pavliฤ](https://www.behance.net/dusanpavlic#)\n"
"\n"
"## Contact\n"
"\n"
"The game is constantly being revised.\n"
"We welcome your feedback, suggestions, and criticism,\n"
"for example, by email to\n"
"[Marcus Zibrowius](https://www.math.uni-duesseldorf.de/~zibrowius/).\n"
"If you have specific change requests or find errors, you are also welcome to create an issue on GitHub:\n"
"\n"
"* for game content in the [Robo repo](https://github.com/hhu-adam/Robo/issues)\n"
"* for the game server in the [lean4game repo](https://github.com/leanprover-community/lean4game/issues)."
msgstr ""

#. ยง0: $I \\subseteq \\{-1,0,1\\}$
#. ยง1: `trans โ i โ I, 0`
#. ยง2: `\\sum`
#: Game.Levels.Babylon.L03_sum_congr
msgid "Remind that goal looks like ยง0. Try ยง1. The sum sign is written\n"
"as ยง2."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "ยง0 Conclusion Robotswana L06"
msgstr ""

#. ยง0: `ยซ{f}ยป`
#. ยง1: `use`
#: Game.Levels.Vieta.L03_Let
msgid "If ยง0 correctly defind try ยง1"
msgstr ""

#. ยง0: `choose`
#. ยง1: `choose`
#. ยง2: `choose g hg using nonempty_fibre`
#: Game.Levels.Epo.L06_choose
msgid "Remember ยง0. This here is a good setting for ยง1. Try ยง2"
msgstr ""

#. ยง0: `matrix_eq_sum_ebasis A`
#. ยง1: `nth_rw 1`
#. ยง2: `rw`
#. ยง3: `rw [matrix_eq_sum_ebasis A]`
#. ยง4: `A`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Explain why to use ยง0 with ยง1 instead of ยง2. ยง3 replaces both ยง4"
msgstr ""

#. ยง0: `unfold Injective`
#: Game.Levels.Mono.L04_Diagonal
msgid "If unsure start with ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "ยง0 Conclusion Prado L02"
msgstr ""

#. ยง0: `Icc_subset_Icc_iff`
#: Game.Levels.Babylon.L04_sum_subset
msgid "ยง0 is useful here"
msgstr ""

#. ยง0: `by_cases h : P`
#. ยง1: `P`
#. ยง2: `by cases h : a = b`
#. ยง3: `a = b`
#. ยง4: `a โ b`
#. ยง5: `(h : P)`
#. ยง6: `(h : ยฌP)`
#: Game.Doc.Tactic
msgid "The tactic ยง0 begins a case distinction as to whether ยง1 is true or false.\n"
"For example, ยง2 distinguishes between the cases ยง3 and ยง4.\n"
"\n"
"The proof goal is duplicated for this purpose, and\n"
"the assumption ยง5 is added to the first โcopy,โ\n"
"while the assumption ยง6 is added to the second โcopy.โ"
msgstr ""

#. ยง0: `CONC`
#: Game
msgid "ยง0 QED"
msgstr ""

#. ยง0: `INTRO-1`
#: Game.Levels.Cantor.L09_CantorDiag
msgid "ยง0Intro Cantor L09 - 1"
msgstr ""

#. ยง0: `2`
#: Game.Levels.Prado.L01_prime_two
msgid "Conclusion Prado L01: Present ยง0 as prime number"
msgstr ""

#. ยง0: `tauto`
#. ยง1: `DOC`
#: Game.Levels.Implis.L14_Summary
msgid "This kind of logical expression can often be solved via ยง0. ยง1"
msgstr ""

#. ยง0: `rw [if_pos ยซ{h}ยป]`
#: Game.Levels.Vieta.L06_Piecewise
msgid "Try ยง0 to reduce if-then-else"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Mono.L01_Injective
msgid "ยง0 Conclusion Mono L01"
msgstr ""

#. ยง0: `fun (x : โค) โฆ x ^ 2`
#. ยง1: $xโฆx^2$
#. ยง2: `f : โค โ โค := โฆ`
#. ยง3: $$
#. \\begin{aligned}
#. f\\colon \\mathbb{โค} &\\to \\mathbb{โค} \\
#. x &\\mapsto x ^ 2
#. \\end{aligned}
#. $$
#. ยง4: $2^2=4$
#. ยง5: `rfl`
#. ยง6: `simp [ยซ{f}ยป]`
#: Game.Levels.Vieta.L02_Function
msgid "Explain anonymous function ยง0 as mapping ยง1.\n"
"Only ยง2 the anon. function would receive a name. The goal is for\n"
"ยง3\n"
"to show that ยง4.\n"
"You can try ยง5 or ยง6\n"
""
msgstr ""

#. ยง0: `univ : Set T`
#. ยง1: `T`
#. ยง2: `rw [eq_univ_iff_forall]`
#. ยง3: `S = univ`
#. ยง4: `โ (x : T), x โ S`
#: Game.Doc.Definition
msgid "ยง0 is the โsubsetโ consisting of *all* elements of type ยง1.\n"
"\n"
"With ยง2, you convert an equation of the form ยง3 into the\n"
"statement ยง4."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Babylon.L01_Sum_Simp_Card
msgid "ยง0 Conclusion Babylon L01"
msgstr ""

#. ยง0: `intro`
#: Game.Levels.Implis.L11_Iff
msgid "Exactly, try ยง0"
msgstr ""

#. ยง0: `if_pos ยซ{hโ}ยป`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Try ยง0."
msgstr ""

#. ยง0: `ยซ{hx}ยป`
#. ยง1: `push_neg at ยซ{hx}ยป`
#: Game.Levels.Luna.L05_Linarith2
msgid "Increase readability of ยง0. Try ยง1"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `S`
#. ยง3: `A B : Set S`
#. ยง4: `A โช B`
#. ยง5: `โช`
#. ยง6: `\\union`
#: Game.Doc.Definition
msgid "For two subsets ยง0 and ยง1 of ยง2 (i.e. ยง3), ยง4 is their union.\n"
"ยง5 is written as ยง6."
msgstr ""

#. ยง0: `A : Set T`
#. ยง1: `Set.Finite A`
#. ยง2: `A`
#. ยง3: `h : Set.Finite A`
#. ยง4: `h.toFinset : Finset T`
#. ยง5: `A`
#: Game.Doc.Definition
msgid "For a subset ยง0, ยง1 means that ยง2 has only a finite number of elements.\n"
"If ยง3 is given as an assumption, then ยง4 is the same subset ยง5,\n"
"but now explicitly understood as a finite subset."
msgstr ""

#. ยง0: `โ a โ A, a`
#. ยง1: `A`
#. ยง2: `apply prod_pos`
#: Game.Levels.Euklid.L01_prod_pos
msgid "ยง0 is Leanic for the product over all numbers in ยง1. Try ยง2"
msgstr ""

#. ยง0: `ring`
#. ยง1: `ยซ{f}ยป`
#: Game.Levels.Vieta.L04_Let
msgid "Try ยง0 as it sees through defintion ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "ยง0 Intro Luna L03"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L01_Intro
msgid "ยง0 Conclusion Implis L01"
msgstr ""

#. ยง0: `intro a b`
#: Game.Levels.Mono.L01_Injective
msgid "Try starting with ยง0"
msgstr ""

#. ยง0: `h`
#. ยง1: `obtain`
#: Game.Levels.Implis.L14_Summary
msgid "To divide assumption ยง0 use ยง1"
msgstr ""

#. ยง0: `(A B : Set T)`
#. ยง1: `A\\B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `A`
#. ยง5: `B`
#: Game.Doc.Definition
msgid "For two subsets ยง0, ยง1 is the difference between ยง2 and ยง3,\n"
"consisting of all elements of ยง4 that are not in ยง5."
msgstr ""

#. ยง0: `(f โ g) x`
#. ยง1: `f (g x)`
#: Game.Levels.Vieta.L04_Let
msgid "Sagt dass ยง0 das gleiche ist wie ยง1."
msgstr ""

#. ยง0: `Odd (n ^ 2)`
#: Game.Levels.Spinoza.L06_Summary
msgid "Derive contradiction for ยง0"
msgstr ""

#. ยง0: `ยซ{g}ยป`
#: Game.Levels.Spinoza.L02_Suffices
msgid "End proof with assumption that ยง0 is true"
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "Try ยง0 afterwards"
msgstr ""

#. ยง0: `a โฃ b`
#. ยง1: `โ k, b = a * k`
#. ยง2: `โฃ`
#. ยง3: `\\dvd`
#. ยง4: `|`
#. ยง5: `obtain hโ | hโ := h`
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "ยง0 bedeutet ยง1.\n"
"\n"
"**Warnung**: Die Symbole ยง2 (ยง3) und ยง4 (ASCII vertikaler Strich) sind zwei unterschiedliche\n"
"Zeichen! Das erste wird ausschlieรlich fรผr โteiltโ verwendet, das andere kommt zum Beispiel in der\n"
"Syntax ยง5 vor."
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Cantor.L01_CantorPowerset
msgid "ยง0"
msgstr ""

#. ยง0: $$
#. f(n) = \\begin{cases}
#. n^2 & \\text{falls } n \\text{ gerade} \\
#. n+1 & \\text{andernfalls.}
#. \\end{cases}
#. $$
#. ยง1: `f + f`
#. ยง2: `โ โ โ`
#. ยง3: `f`
#: Game.Levels.Mono.L03_NotInjective
msgid "The given mapping has the form\n"
"ยง0\n"
"\n"
"and ยง1 is the mapping ยง2, that for each input return the doubeled value of ยง3.\n"
""
msgstr ""

#. ยง0: `1`
#. ยง1: `matrix_eq_sum_ebasis`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Intro Robotswana L05: ยง0 indicates unit matrix. Begin with ยง1"
msgstr ""

#. ยง0: `g`
#. ยง1: `f`
#. ยง2: `f`
#. ยง3: `g`
#. ยง4: `Function.RightInverse`
#. ยง5: `Function.RightInverse`
#. ยง6: `RightInverse`
#. ยง7: `RightInverse`
#: Game.Levels.Epo.L03_LeftInverse
msgid "Goal says that ยง0 is righ inverse of ยง1 iff ยง2 is left inverse of ยง3.\n"
"Try ยง4. It has to be written as ยง5 instead of ยง6\n"
"because ยง7 is ambigous in Leanic."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Epo.L07_SurjectiveRightInverse
msgid "ยง0 Conclusion Epo L07"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L09_PushNeg
msgid "ยง0 Intro Quantus L09"
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#: Game.Levels.Implis.L12_ByCases
msgid "Proof consists now of two parts. First assumes that ยง0 is true. Second assumes that ยง1\n"
"is false"
msgstr ""

#. ยง0: `g`
#. ยง1: `use`
#: Game.Levels.Vieta.L07_Extend
msgid "Insert ยง0 via ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Iso
msgid "ยง0 Intro Iso"
msgstr ""

#. ยง0: ```
#. A = B
#. ```
#. ยง1: `T`
#. ยง2: `A B : Set T`
#. ยง3: `ext x`
#. ยง4: ```
#. x โ A โ x โ B
#. ```
#: Game.Doc.Tactic
msgid "Two subsets of a given set are equal if they have the same elements.\n"
"If the proof goal is\n"
"ยง0\n"
"for two subsets of ยง1 (i.e., for ยง2),\n"
"then ยง3 converts the proof goal into the equivalence\n"
"ยง4"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L06_Piecewise
msgid "ยง0 Intro Vieta L06"
msgstr ""

#. ยง0: `have`
#. ยง1: `suffices`
#. ยง2: `suffices g : ยฌB`
#. ยง3: `g`
#. ยง4: `g`
#: Game.Levels.Spinoza.L02_Suffices
msgid "Instead of ยง0, ยง1 can be used. After ยง2, you have to show how to\n"
"prove goal by ยง3 before proving ยง4 itself."
msgstr ""

#. ยง0: `COMMENT-2`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "ยง0 return to topic at hand"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L07_Extend
msgid "ยง0 Intro Vieta L07"
msgstr ""

#. ยง0: `omega`
#: Game.Levels.Luna.L07_Linarith2
msgid "Intro Luna L07: Enough of ยง0"
msgstr ""

#. ยง0: `f (E i i) = 1`
#. ยง1: `one_on_diag_ebasis`
#: Game.Levels.Robotswana.L10_Characterize
msgid "Remind former result for ยง0. Try ยง1"
msgstr ""

#. ยง0: `sum_congr`
#: Game.Levels.Babylon.L05_sum_subset2
msgid "Now oyu can use ยง0"
msgstr ""

#. ยง0: `True : Prop`
#. ยง1: `True`
#. ยง2: `tauto`
#. ยง3: `decide`
#. ยง4: `True`
#. ยง5: `True`
#. ยง6: `True`
#: Game.Doc.Definition
msgid "The statement ยง0 is always true.\n"
"\n"
"## ยง1 as a proof target\n"
"\n"
"The tactics ยง2 and ยง3 conclude every proof with ยง4 as the proof target.\n"
"\n"
"## ยง5 as an assumption\n"
"\n"
"As an assumption, ยง6 is not helpful at all."
msgstr ""

#. ยง0: `have`
#. ยง1: `suffices`
#: Game.Levels.Spinoza.L02_Suffices
msgid "Conclusion Spinoza L02: The use of ยง0 or ยง1 is up to personal preference."
msgstr ""

#. ยง0: `n โฆ n + 1`
#. ยง1: `n โฆ n - 1`
#. ยง2: `n = 0`
#. ยง3: `if โฆ then โฆ else`
#. ยง4: `0 - 1`
#. ยง5: `โ`
#. ยง6: `0`
#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "It conjected that ยง0 has left inverse. One would assume that ยง1 would\n"
"not work for ยง2. Tackling this by case distinction e.g. ยง3 is unecessary as\n"
"in Leanic ยง4 is in ยง5. It is simply defined as ยง6"
msgstr ""

#. ยง0: `not_imp_not`
#: Game.Levels.Spinoza.L04_ByContra
msgid "Intro Spinoza L04: introduce contraposition equivalence with ยง0"
msgstr ""

#. ยง0: `ยซ{i}ยป = ยซ{j}ยป`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Prove by cases for ยง0"
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `ยซ{B}ยป`
#: Game.Levels.Piazza.L07_antisymm_iff
msgid "Try replacing ยง0 by ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L08_Rw
msgid "ยง0 Conclusion Implis L08"
msgstr ""

#. ยง0: `IN_HINT 2`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "ยง0 Simplify"
msgstr ""

#. ยง0: `ยซ{A}ยป โง ยซ{B}ยป`
#. ยง1: `ยซ{A}ยป`
#: Game.Levels.Logo.L13_Or
msgid "Prove goal once for ยง0 and once for ยง1"
msgstr ""

#. ยง0: `IsEmpty.false`
#. ยง1: `M`
#. ยง2: `โ (m : M), False`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Try ยง0. It states for the empty set ยง1 that ยง2"
msgstr ""

#. ยง0: `decide`
#: Game.Levels.Quantus.L03_Decide
msgid "Remind that ยง0 solves every task where a simple algorithm is available to solve them"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L01_Tauto
msgid "ยง0 Intro Logo L01"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Piazza.L01_Mem__Set
msgid "ยง0 Conclusion Piazza L01"
msgstr ""

#. ยง0: `simp`
#. ยง1: `mathlib`
#. ยง2: `@[simp]`
#. ยง3: `simp [h]`
#. ยง4: `h`
#. ยง5: `h`
#. ยง6: `simp [F]`
#. ยง7: `F`
#. ยง8: `simp only [h,f,g]`
#. ยง9: `h`
#. ยง10: `f`
#. ยง11: `g`
#. ยง12: `simp?`
#: Game.Doc.Tactic
msgid "The ยง0 tactic attempts to apply a large number of lemmas to simplify a given expression.\n"
"(Technically, these are all lemmas in ยง1 that are marked with ยง2.)\n"
"\n"
"## Variants\n"
"\n"
"* ยง3 additionally uses the assumption ยง4 or the lemma ยง5 for simplification\n"
"* ยง6 additionally uses the definition of ยง7\n"
"* ยง8 exclusively uses the assumptions/lemmas/definitions ยง9, ยง10, and ยง11\n"
"* ยง12 shows you which lemmas were used"
msgstr ""

#. ยง0: $$ \\sum_{i = 0}^n (2i + 1) = n^2 $$
#: Game.Levels.Babylon.L08_Induction3_sub_insert3
msgid "Try solving ยง0 by induction"
msgstr ""

#. ยง0: $(n ร n)$
#. ยง1: $\\mathbb{R}$
#. ยง2: $A$
#. ยง3: $A = \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} A_{ij} \\cdot E(i, j)$
#. ยง4: `matrix_eq_sum_single`
#. ยง5: $(m ร n)$
#. ยง6: $R$
#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Sagt aus, dass man jede ยง0-Matrix (รผber ยง1) ยง2 schreiben kann\n"
"als ยง3.\n"
"\n"
"Siehe auch ยง4, welches die generalisierte Form fรผr\n"
"ยง5-Matrix (รผber beliebigem ยง6) ist."
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "ยง0 is always available"
msgstr ""

#. ยง0: `COMMENT-2`
#: Game.Levels.Cantor.L02_CantorPowerset
msgid "ยง0 Try simp [ยซ{s}ยป]"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L08_CongrArg
msgid "ยง0 Intro Vieta L08"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "ยง0 remember proof"
msgstr ""

#. ยง0: `s : ยซ{Y}ยป โ ยซ{Y}ยป`
#. ยง1: $n โฆ n + 1$
#. ยง2: $โ$
#. ยง3: $โ$
#. ยง4: $\\{0,1\\}$
#. ยง5: `Y`
#: Game.Levels.Cantor.L09_CantorDiag
msgid "The goal is that each self mapping ยง0 possess a fixed point.\n"
"Does not every set have a self mapping without fixed points? E.g. ยง1 in ยง2\n"
"or ยง3 โฆ or the non-trivial permutations in ยง4. Thought: if ยง5 is not a set with\n"
"a single element then there should be a fixed-point-free self mapping."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L01_FunctionNotation
msgid "ยง0 Intro Vieta L01"
msgstr ""

#. ยง0: $B \\iff A \\iff D \\iff C$
#. ยง1: `rw [hโ]`
#. ยง2: `C`
#. ยง3: `D`
#: Game.Levels.Implis.L08_Rw
msgid "Rewrite ยง0. Start with ยง1 to replace ยง2 with ยง3"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Robotswana.L10_Characterize
msgid "ยง0 Observe equality"
msgstr ""

#. ยง0: `have`
#. ยง1: `have g : ยฌ B`
#: Game.Levels.Spinoza.L01_Have
msgid "Try ยง0 in form of ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L03_Assumption
msgid "ยง0 Conclusion Logo L03"
msgstr ""

#. ยง0: `A : Finset T`
#. ยง1: `a : T`
#. ยง2: `insert a A`
#. ยง3: `A โช {a}`
#. ยง4: `a`
#. ยง5: `A`
#. ยง6: `insert a A = A`
#: Game.Doc.Definition
msgid "For a finite subset ยง0 and an element ยง1,\n"
"ยง2 is another way of writing ยง3.\n"
"If ยง4 is already in ยง5, then obviously ยง6."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Iso.L02_Inverse
msgid "ยง0 Intro Iso L02"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "ยง0 so far so good"
msgstr ""

#. ยง0: `ยซ{hx}ยป : m โค x โ n < x`
#. ยง1: `โ`
#. ยง2: `rw`
#. ยง3: `imp_iff_or_not`
#: Game.Levels.Luna.L05_Linarith2
msgid "We now have ยง0. Knowing what ยง1 means, try ยง2 with ยง3"
msgstr ""

#. ยง0: `simp`
#. ยง1: `simp`
#. ยง2: `all_primes`
#. ยง3: `simp [all_primes]`
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "If ยง0 alone does not work, try giving ยง1\n"
"the definition of ยง2. Try ยง3"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "ยง0 explain that a mapping, which is left inverse ..."
msgstr ""

#. ยง0: `apply`
#: Game.Levels.Spinoza.L01_Have
msgid "ยง0 should help"
msgstr ""

#. ยง0: `linarith`
#. ยง1: `ยซ{a}ยป = 1`
#. ยง2: `2 โค ยซ{a}ยป`
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "Try ยง0 to show contradiction between ยง1 and ยง2"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L01_prime_two
msgid "ยง0 Intro Prado L01"
msgstr ""

#. ยง0: `if_neg`
#: Game.Levels.Vieta.L06_Piecewise
msgid "Use the negation ยง0"
msgstr ""

#. ยง0: `simp [LeftInverse]`
#: Game.Levels.Iso.L02_Inverse
msgid "Simplify goal with ยง0"
msgstr ""

#. ยง0: `tauto`
#. ยง1: `generalize`
#. ยง2: `tauto`
#: Game.Doc.Tactic
msgid "The tactic ยง0 proves logical tautologies.\n"
"\n"
"# Friends and relatives\n"
"\n"
"Sometimes the proof target must first be abstracted with ยง1 so that ยง2 recognizes the tautology."
msgstr ""

#. ยง0: `zero_on_offDiag_ebasis`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "This was called ยง0"
msgstr ""

#. ยง0: `ยซ{n}ยป`
#. ยง1: $$
#. \\begin{aligned}
#. n \\cdot f(E_{i i})
#. &= \\sum_j f(E_{i i}) \\
#. &= \\sum_j f(E_{j j}) \\
#. &= f(1) \\
#. &= n
#. \\end{aligned}
#. $$
#. ยง2: `f E i i`
#. ยง3: `f E j j`
#. ยง4: `i`
#. ยง5: `j`
#. ยง6: `ยซ{n}ยป`
#. ยง7: ```
#. suffices h : n * f (E i i) = n * 1
#. ```
#. ยง8: `mul_eq_mul_left_iff`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "\n"
"ยง0-th multiplication of the equation can be calculated with the former results as:\n"
"ยง1\n"
"\n"
"Keep in mind that ยง2 and ยง3 are equal for arbitrary ยง4 and ยง5. Use fact that\n"
"multiplications with ยง6 are injective. Try\n"
"ยง7\n"
"and then continue with ยง8.\n"
""
msgstr ""

#. ยง0: `Icc`
#. ยง1: `Icc a b`
#. ยง2: $[a, b]$
#. ยง3: $\\{a, a + 1, \\dots, b\\}$
#. ยง4: $$ [a, b] โช \\{ b + 1 \\} = [a, b + 1] $$
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "Remind that ยง0 is an interval which is closed to both sides. You could write ยง1\n"
"as ยง2 or ยง3, because we are in the natual numbers. Therfore, the\n"
"goal is: ยง4"
msgstr ""

#. ยง0: `ยซ{f}ยป`
#. ยง1: `ยซ{A}ยป โ ยซ{Y}ยป`
#. ยง2: ``` let c : ยซ{A}ยป โ ยซ{Y}ยป := fun a โฆ _ ```
#. ยง3: `c`
#: Game.Levels.Cantor.L09_CantorDiag
msgid "exploit the surjectivity of ยง0 somehow. It was already told\n"
"which of mapping ยง1 the preimage has to be considered. One could define ยง2\n"
"and then observe the preimage of ยง3."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado
msgid "ยง0 Intro Prado"
msgstr ""

#. ยง0: `ne_comm`
#. ยง1: `ne_comm`
#. ยง2: `a โ b โ b โ a`
#: Game.Levels.Epo.L02_CurrySurjective
msgid "Try ยง0. ยง1 says that ยง2"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Robotswana.L02_EBasis
msgid "ยง0 looks like matrix multiplication"
msgstr ""

#. ยง0: `StrictMono.injective`
#: Game.Levels.Mono.L06_StrictMono
msgid "Intro Mono L06: Prove ยง0"
msgstr ""

#. ยง0: `by_cases`
#. ยง1: `ยซ{b}ยป`
#: Game.Levels.Mono.L10_Auxiliary
msgid "Try ยง0 to see if ยง1 has preimage"
msgstr ""

#. ยง0: `STORY`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "ยง0 explanation of equal sums"
msgstr ""

#. ยง0: `ยฌยฌ`
#. ยง1: `rw`
#. ยง2: `ยฌยฌC`
#. ยง3: `ยฌยฌB`
#: Game.Levels.Implis.L13_Rw
msgid "Only two of three ยง0 are rewritten. ยง1 only rewrites only first found occurance i.e. ยง2.\n"
"As ยง3 is considered to be something 'different' the lemma has to be applied again"
msgstr ""

#. ยง0: `not_not`
#. ยง1: `โ`
#. ยง2: `=`
#. ยง3: `rw [not_not]`
#: Game.Levels.Implis.L13_Rw
msgid "A lemma like ยง0 that contains ยง1 or ยง2 in its statements can also be used with ยง3"
msgstr ""

#. ยง0: `apply lt_trichotomy`
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "Conclusion Luna L03: Alternatively ยง0 could have been used."
msgstr ""

#. ยง0: `f`
#: Game.Levels.Cantor.L02_CantorPowerset
msgid "Is there a set, which is not hit by ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "ยง0 Intro Robotswana L09"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Spinoza.L02_Suffices
msgid "ยง0 Prove intermediate result"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L03
msgid "ยง0 Conclusion Robotswana L03"
msgstr ""

#. ยง0: `use`
#. ยง1: `โ!`
#. ยง2: `simp`
#: Game.Levels.Prado.L09_ExistsUnique
msgid "Applying ยง0 onto ยง1 is usually badly readable. Try ยง2 directly afterwards"
msgstr ""

#. ยง0: `COMMENT-2`
#: Game.Levels.Piazza.L07_antisymm_iff
msgid "ยง0 reminder of set equality"
msgstr ""

#. ยง0: `2`
#. ยง1: `1`
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "A prime number is a natural number greater or equal to ยง0, which is only divisible by ยง1\n"
"and itself"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "ยง0 Conclusion Robotswana L05"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "ยง0 Conclusion Quantus L02"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Saturn.L03_mul_comm
msgid "ยง0 Intro Saturn L03"
msgstr ""

#. ยง0: `n : โค`
#. ยง1: `n.toNat : โ`
#. ยง2: `n : โค`
#. ยง3: `n.toNat : โ`
#. ยง4: `n : โ`
#. ยง5: `(n : โค)`
#. ยง6: `โn`
#: Game.Doc.Definition
msgid "If ยง0 is an integer greater than or equal to 0, then ยง1 is the same number, interpreted as a natural number.\n"
"(If ยง2 is a negative integer, then ยง3 is also defined, but its value has no mathematical meaning.)\n"
"\n"
"## Friends and relatives\n"
"\n"
"A natural number ยง4 can always be interpreted as an integer.\n"
"To do this, you either write it explicitly as ยง5 or as ยง6."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "ยง0 Conclusion Samarkand L04"
msgstr ""

#. ยง0: `LeftInverse g f`
#. ยง1: `g โ f = id`
#. ยง2: `โ x, g (f x) = x`
#. ยง3: `unfold`
#: Game.Doc.Definition
msgid "ยง0 means ยง1, or more exactly:\n"
"ยง2, as can be seen with ยง3."
msgstr ""

#. ยง0: `ยซ{P}ยป`
#. ยง1: `ยซ{P}ยป`
#. ยง2: `ยซ{X}ยป`
#. ยง3: `ยซ{X}ยป`
#. ยง4: `ยซ{P}ยป x`
#. ยง5: `x`
#. ยง6: `x`
#. ยง7: `x`
#. ยง8: `ยซ{P}ยป`
#. ยง9: `x : ยซ{X}ยป`
#. ยง10: `push_neg`
#: Game.Levels.Quantus.L08_PushNeg
msgid "Explain ยง0: ยง1 is an expression over the type ยง2. ยง3 could e.g. be the natural\n"
"numbers. ยง4 could be the expression: ยง5 is even. Or: ยง6 has seven prime factors. Or: ยง7 is\n"
"a favorite number. In other words: ยง8 is a mapping that takes ยง9 and maps it onto an expression.\n"
"Try ยง10."
msgstr ""

#. ยง0: `(A i j) โข E i j`
#. ยง1: `Matrix.smul_ebasis`
#. ยง2: `rw [โฆ]`
#. ยง3: `simp [โฆ]`
#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Expression ยง0 can be simplified with ยง1.\n"
"ยง2 can not be used under a sum. ยง3 can work.\n"
""
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Luna.L01_le_rfl
msgid "ยง0 Conclusion Luna L01"
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `โ! a : A, P a`
#. ยง2: `a`
#. ยง3: `A`
#. ยง4: `A`
#. ยง5: `P a`
#. ยง6: `a`
#. ยง7: `a`
#. ยง8: `โ!`
#. ยง9: `โ! a : A, โฆ`
#. ยง10: `a`
#. ยง11: `use`
#. ยง12: `use a`
#. ยง13: `simp`
#. ยง14: `P a โง โ a' : A, P a' โ a' = a`
#. ยง15: `P a`
#. ยง16: `a`
#. ยง17: `a`
#. ยง18: `โ!`
#. ยง19: `h : โ! a : A, P a`
#. ยง20: ```
#.   obtain โจa, h_exists, h_uniqueโฉ := h
#.   simp at h_unique
#. ```
#. ยง21: ```
#.    a : A
#.    h_exists : P a
#.    h_unique : โ (y : A), P y โ y = a
#. ```
#: Game.Doc.Definition
msgid "Existential quantifier: If ยง0 is a predicate, then\n"
"ยง1 is the statement that *exactly one* element ยง2 in ยง3 (more precisely: of type ยง4)\n"
"exists for which the statement ยง5 is true.\n"
"The statement therefore has two parts: first, such an ยง6 exists, and second, ยง7 is unique.\n"
"## ยง8 as a proof goal\n"
"\n"
"To prove a statement of the form ยง9, first construct a suitable element ยง10 and\n"
"then use the ยง11 tactic (ยง12), usually immediately followed by ยง13.\n"
"The proof goal should then have the following form:\n"
"\n"
"ยง14\n"
"\n"
"On the left is ยง15: you still have to show that ยง16 has the required property.\n"
"On the right is the uniqueness statement: every element with this property is equal to ยง17.\n"
"\n"
"## ยง18 as an assumption\n"
"\n"
"You can prove an assumption of the form ยง19 with\n"
"\n"
"ยง20\n"
"into its components\n"
"ยง21\n"
"."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L12_Or
msgid "ยง0 Intro Logo L12"
msgstr ""

#. ยง0: `obtain โจโฉ := ยซ{h}ยป`
#: Game.Levels.Logo.L14_Summary
msgid "Divide assumption ยซ{h}ยป using ยง0"
msgstr ""

#. ยง0: `โง`
#: Game.Levels.Spinoza.L01_Have
msgid "Try to split ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L12_Or
msgid "ยง0 Conclusion Logo L12"
msgstr ""

#. ยง0: `ยซ{w}ยป`
#. ยง1: `a * ยซ{w}ยป = b`
#. ยง2: `ยซ{w}ยป`
#: Game.Levels.Prado.L09_ExistsUnique
msgid "Show two statements: (1) ยง0 satisfies ยง1 and (2) ยง2 is the only element with\n"
"such a property"
msgstr ""

#. ยง0: `linarith`
#. ยง1: ```
#. h : m โค x โ n < x
#. ```
#. ยง2: ```
#. rw [imp_iff_or_not] at h
#. ```
#. ยง3: ```
#. h : n < x โจ ยฌm โค x
#. ```
#. ยง4: `linarith`
#: Game.Doc.Tactic
msgid "The tactic ยง0 can show that a linear equation or inequality follows from given equations or inequalities.\n"
"It is quite flexible and works just as well in โ as in โ.\n"
"However, the (in)equations must be given individually, not logically linked.\n"
"An assumption of the form\n"
"ยง1\n"
"must first be rewritten with\n"
"ยง2\n"
"to\n"
"ยง3\n"
"so that ยง4 can do something with it."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "ยง0 Intro Piazza L06"
msgstr ""

#. ยง0: `simp`
#. ยง1: `ยซ{h}ยป`
#: Game.Levels.Robotswana.L02_EBasis
msgid "Try ยง0 with ยง1"
msgstr ""

#. ยง0: `simp`
#. ยง1: `omega`
#: Game.Levels.Babylon.L04_sum_subset
msgid "Try ยง0 & ยง1"
msgstr ""

#. ยง0: `f`
#. ยง1: `g`
#. ยง2: `f + g`
#: Game.Levels.Mono.L05_StrictMono
msgid "Sind ยง0 und ยง1 beide strikt monoton sind, so ist auch ยง2 strikt momonton."
msgstr ""

#. ยง0: `congr_fun`
#. ยง1: `h : f = g`
#. ยง2: `apply congr_fun at h`
#. ยง3: `h : โ x, f x = g x`
#. ยง4: `rw [h]`
#. ยง5: `f`
#: Game.Levels.Vieta.L09_CongrFun
msgid "Try ยง0. Given assumption ยง1 rewrite it via ยง2 to ยง3.\n"
"ยง4 not applicable to more complex ยง5"
msgstr ""

#. ยง0: `A โจ B`
#. ยง1: `left`
#. ยง2: `right`
#: Game.Doc.Tactic
msgid "If the proof target is of the form ยง0, you choose ยง1 to show the left side.\n"
"\n"
"## Friends and relatives\n"
"\n"
"With ยง2, you choose the right side accordingly."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.Iso.L02_Inverse
msgid "Disect ยง0"
msgstr ""

#: Game.Levels.Piazza
msgid "Piazza"
msgstr ""

#. ยง0: `ยซ{h}ยป : ยซ{n}ยป = 0`
#. ยง1: `obtain ยซ{h}ยป | ยซ{h}ยป := ยซ{h}ยป`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Observe ยง0 seperatly. Prove by cases with ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L14_Summary
msgid "ยง0 Conclusion Implis L14"
msgstr ""

#. ยง0: `A`
#. ยง1: `ยฌA`
#. ยง2: `by_cases h : A`
#: Game.Levels.Implis.L12_ByCases
msgid "Either ยง0 or ยง1 is true. Try ยง2"
msgstr ""

#. ยง0: `โ โ A โ B`
#. ยง1: `โ โ (A โ B)`
#. ยง2: `โ`
#. ยง3: `A โ B`
#: Game.Levels.Epo.L02_CurrySurjective
msgid "Explaination of ยง0: it can be read as ยง1, a mapping of ยง2 into the set ยง3"
msgstr ""

#. ยง0: `A โ Set A`
#. ยง1: `Set A`
#. ยง2: `A โ Prop`
#. ยง3: `S : Set A`
#. ยง4: `A โ Prop`
#. ยง5: `a : A`
#. ยง6: `a โ S`
#: Game.Levels.Cantor.L10_CantorPowerset
msgid "Intro Cantor L10: Show that there are no surjective mappings ยง0 by interpreting\n"
"ยง1 as ยง2. Sub set ยง3 can be seen as ยง4, which casts ยง5 on statement ยง6"
msgstr ""

#. ยง0: `suffices d : ยฌ Odd (n ^ 2)`
#: Game.Levels.Spinoza.L06_Summary
msgid "Conclude with ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L01_CantorPowerset
msgid "ยง0 Conclusion Cantor L01"
msgstr ""

#. ยง0: `A : Set T`
#. ยง1: `a`
#. ยง2: `T`
#. ยง3: `T`
#. ยง4: `a โ A`
#. ยง5: `a`
#. ยง6: `A`
#. ยง7: `A = { a : T | P a }`
#. ยง8: `a โ A`
#. ยง9: `simp`
#. ยง10: `P a`
#: Game.Doc.Definition
msgid "For a subset ยง0 and an element ยง1 from ยง2 (more precisely: of type ยง3), ยง4 means that\n"
"ยง5 is in ยง6.\n"
"For subsets of the form ยง7, you can simplify the statement\n"
"ยง8 with ยง9 to ยง10."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#. ยง1: `obtain`
#. ยง2: `ยซ{h}ยป`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "We have assumption ยง0. Try applying ยง1 on ยง2."
msgstr ""

#. ยง0: `f (E i j)`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "See that ยง0 is zero"
msgstr ""

#. ยง0: `โ`
#. ยง1: `\\l`
#. ยง2: `rw [โ hโ]`
#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "Remind of rewrite via ยง0 as ยง1. Try ยง2"
msgstr ""

#. ยง0: `Matrix.smul_ebasis`
#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "Conclusion Robotswana L01: Save result as ยง0"
msgstr ""

#. ยง0: `False : Prop`
#. ยง1: `False`
#. ยง2: `False`
#. ยง3: `contradiction`
#. ยง4: `False`
#. ยง5: `h : ยฌ A`
#. ยง6: `apply h`
#. ยง7: `A`
#. ยง8: `ยฌ A`
#. ยง9: `A โ False`
#. ยง10: `False`
#. ยง11: `False`
#. ยง12: `contradiction`
#: Game.Doc.Definition
msgid "The statement ยง0 is always false.\n"
"\n"
"## ยง1 as proof target\n"
"\n"
"If ยง2 is your proof target, you can try to find a contradiction in your assumptions, for example.\n"
"Once the contradiction is sufficiently evident, ยง3 concludes such a proof.\n"
"\n"
"If ยง4 is your proof goal and you have an assumption or lemma of the form ยง5 available,\n"
"you can use ยง6 to change the proof goal to ยง7\n"
"(because ยง8 means ยง9).\n"
"\n"
"## ยง10  as an assumption\n"
"\n"
"If you have ยง11 as an assumption, you can immediately end the proof with ยง12\n"
"โ because, as is well known, any other statement follows from a false statement."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L10_And
msgid "ยง0 Conclusion Logo L10"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
msgid "ยง0Conclusion Cantor L08"
msgstr ""

#. ยง0: `ext`
#. ยง1: `intro a`
#. ยง2: `A`
#. ยง3: `C`
#. ยง4: `rw [subset_iff] at *`
#: Game.Levels.Piazza.L09_subset_iff2
msgid "Using ยง0 would be too complicated. It is simpler to use ยง1 to introduce\n"
"an arbitrary element from ยง2 and show that it is also in ยง3. Firstly, write all inclusions\n"
"exolicitly with ยง4"
msgstr ""

#. ยง0: ` โ b : B, โ a : A, โฆ`
#. ยง1: `choose`
#. ยง2: `have`
#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "One could choose left inverse on the previous proven statement ยง0 by using ยง1.\n"
"As proven statement has no name formulate statement again with ยง2 and prove it again."
msgstr ""

#. ยง0: `unfold range fixedPoints IsFixedPt`
#. ยง1: `ยซ{h}ยป`
#. ยง2: `congr_fun`
#: Game.Levels.Cantor.L07_idempotent
msgid "Try ยง0 and rewrite assumption ยง1 firstly by ยง2"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Euklid.L02_prod_insert
msgid "ยง0 The rest should be easy"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L11_Iff
msgid "ยง0 Conclusion Implis L11"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Cantor.L02_CantorPowerset
msgid "ยง0Intro Cantor L02"
msgstr ""

#. ยง0: `Nonempty A`
#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "Intorduce new prerequisite ยง0"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Mono.L05_StrictMono
msgid "ยง0 the next part is elementary"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "ยง0 Try constructor"
msgstr ""

#. ยง0: `ยซ{hโ}ยป`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Try to simplify ยง0."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L06_Not
msgid "ยง0 Intro Logo L06"
msgstr ""

#. ยง0: `ยซ{hx}ยป`
#. ยง1: `obtain`
#: Game.Levels.Luna.L05_Linarith2
msgid "Divide ยง0 with ยง1"
msgstr ""

#. ยง0: `exists_prime_and_dvd`
#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid "Apply ยง0 to prove existence of prime factor"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Piazza.L10
msgid "ยง0 Conclusion Piazza L10"
msgstr ""

#. ยง0: `use _`
#. ยง1: `ยซ{b}ยป + ยซ{c}ยป = ยซ{a}ยป * _`
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "Try ยง0 such that ยง1"
msgstr ""

#: Game.Levels.Vieta
msgid "Vieta"
msgstr ""

#. ยง0: `ยซ{hb}ยป`
#. ยง1: `simp`
#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "Transform ยง0 by using ยง1"
msgstr ""

#. ยง0: `StrictMono`
#. ยง1: `StrictMono.injective`
#. ยง2: `StrictMono.add`
#. ยง3: `Odd.strictMono_pow`
#. ยง4: `n`
#. ยง5: `x โฆ x ^ n`
#: Game.Levels.Mono.L05_StrictMono
msgid "ยง0 is useful. ยง1 says that each strictly monotone mapping\n"
"is injective. To show that a mapping is monotone one can use e.g. ยง2 or ยง3,\n"
"which says that for uneven ยง4, ยง5 is monotone."
msgstr ""

#. ยง0: `P : MvPolynomial (Fin n) R`
#. ยง1: `P`
#. ยง2: `n`
#. ยง3: `X 0`
#. ยง4: `X (n-1)`
#. ยง5: `R`
#: Game.Doc.Definition
msgid "ยง0 means that ยง1 is a polynomial in ยง2 indeterminates\n"
"ยง3, โฆ, ยง4 with coefficients in ยง5."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand
msgid "ยง0 Intro Samarkand"
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `left`
#. ยง2: `right`
#: Game.Levels.Logo.L12_Or
msgid "Try to proof ยง0 by using ยง1 | ยง2"
msgstr ""

#. ยง0: `ยซ{B}ยป`
#: Game.Levels.Logo.L10_And
msgid "Now there is goal ยง0. This goal is part of the assumption"
msgstr ""

#. ยง0: `unfold IsFixedPt`
#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid "Try again with ยง0"
msgstr ""

#. ยง0: `decide`
#. ยง1: `True`
#. ยง2: `Even 4`
#. ยง3: `2 โค 5`
#. ยง4: `4 โ 6`
#. ยง5: `Prime 7`
#: Game.Doc.Tactic
msgid "With ยง0, you can prove statements that can be decided using a simple algorithm.\n"
"These include, in particular, ยง1 and statements about concrete numbers such as:\n"
"- ยง2\n"
"- ยง3\n"
"- ยง4\n"
"- ยง5"
msgstr ""

#. ยง0: `Bijective`
#. ยง1: `obtain โจhinj, hsurjโฉ  := ยซ{h}ยป`
#. ยง2: `Injective`
#. ยง3: `Surjective`
#: Game.Levels.Iso.L02_Inverse
msgid "Divide ยง0 via ยง1 into\n"
"ยง2 and ยง3"
msgstr ""

#. ยง0: `contrapose`
#. ยง1: `A โ B`
#. ยง2: `ยฌB โ ยฌA`
#. ยง3: `revert h`
#. ยง4: `contrapose`
#: Game.Doc.Tactic
msgid "The tactic ยง0 changes a proof goal of the form ยง1 to ยง2, thereby\n"
"initiating a proof by contraposition.\n"
"\n"
"## Friends and relatives\n"
"\n"
"The tactic ยง3 can be useful for writing an assumption as an implication premise\n"
"before you use ยง4."
msgstr ""

#. ยง0: `specialize ยซ{hf}ยป ยซ{s}ยป`
#. ยง1: `simp`
#. ยง2: `simp [ยซ{s}ยป]`
#. ยง3: `simp`
#: Game.Levels.Cantor.L02_CantorPowerset
msgid "Try ยง0. When you apply ยง1 later, ยง2 allows ยง3 to look through\n"
"your defintions"
msgstr ""

#. ยง0: `E i j`
#. ยง1: `E i j`
#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "intro Robotswana L07: Introduce new consideration for ยง0: do not consider ยง1 with i โ j"
msgstr ""

#. ยง0: `apply`
#. ยง1: ```
#. lemma not_not (A : Prop) : ยฌยฌA โ A
#. ```
#: Game.Levels.Implis.L13_Rw
msgid "Intro Implis L13: Do not use ยง0. Try it with\n"
"ยง1"
msgstr ""

#. ยง0: ```
#. f = g
#. ```
#. ยง1: `f g : X โ Y`
#. ยง2: `funext x`
#. ยง3: ```
#. f x = g x
#. ```
#: Game.Doc.Tactic
msgid "Two mappings with the same range and domain are equal if\n"
"they take the same values on all elements of the domain.\n"
"A proof goal of the form\n"
"ยง0\n"
"for mappings ยง1 is converted by ยง2\n"
"into the equation\n"
"ยง3."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana.L11_Linearity
msgid "ยง0 Intro Robotswana L11"
msgstr ""

#. ยง0: `DOC`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "ยง0\n"
"Linear mapping, or 'additive' mappings in general, can be exchanged with a sum."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Iso.L01_Bijective
msgid "ยง0 Intro Iso L01"
msgstr ""

#. ยง0: `-1 + -ยซ{d}ยป`
#. ยง1: `-ยซ{d}ยป - 1`
#. ยง2: `have`
#. ยง3: `โค`
#. ยง4: ``` have : -1 + (-d : โค)  = -d - 1 ```
#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid "Rewrite ยง0 to ยง1. Formulate equation using ยง2.\n"
"Also, specify that equation is in ยง3. Try e.g. ยง4"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Prado.L03_even_iff_two_dvd
msgid "ยง0 Intro Prado L03"
msgstr ""

#. ยง0: `f`
#. ยง1: `let g : โค ร โค โ โค ร โค := fun (m, n) โฆ โฆ`
#. ยง2: `use g`
#. ยง3: `f`
#: Game.Levels.Epo.L05_RightInverse
msgid "Show that there is right inverse to ยง0. You could again set mapping ยง1\n"
"and then apply ยง2. Think how right inverse of ยง3 could look like."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Mono
msgid "ยง0 Intro Mono"
msgstr ""

#. ยง0: `intro b`
#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "Explain inclusion. Try ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "ยง0 Conclusion Robotswana L09"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Logo.L11_And
msgid "ยง0 Try Assumption tactic"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid "ยง0 Intro Prado L08"
msgstr ""

#. ยง0: `i`
#. ยง1: `by_cases h : Even i`
#: Game.Levels.Quantus.L06_not_even_iff_odd
msgid "Try case distinction if ยง0 is even or uneven. Try ยง1."
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Spinoza.L03_ByContra
msgid "ยง0 Derive intermediate result that lead to the conclusion"
msgstr ""

#: Game.Doc.Definition
msgid "A mapping ist bijectiv, if it is injektiv and surjektiv."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L09_ExistsUnique
msgid "ยง0 Intro Prado L09"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid "ยง0 Intro Babylon L07"
msgstr ""

#. ยง0: `I : Finset T`
#. ยง1: `โ i โ I, f i`
#. ยง2: $\\prod_{i\\in I} f(i)$
#. ยง3: `\\prod`
#: Game.Doc.Definition
msgid "For a finite index set ยง0, ยง1 is the Leanic notation for the product\n"
"ยง2.  You write the product symbol as ยง3."
msgstr ""

#. ยง0: `f`
#: Game.Levels.Cantor.L06_IsFixedPt_odd
msgid "Assumption says that ยง0 is an 'uneven' function is"
msgstr ""

#. ยง0: `\\to`
#. ยง1: `ยซ{B}ยป`
#. ยง2: `ยซ{A}ยป`
#. ยง3: `ยซ{A}ยป und ยซ{B}ยป`
#. ยง4: `tauto`
#. ยง5: `ยซ{A}ยป`
#. ยง6: `h`
#. ยง7: `intro h`
#: Game.Levels.Implis.L01_Intro
msgid "Proof the implication (ยง0), that assuming ยง1 is true, ยง2 implies ยง3\n"
"is also true. You cannot use ยง4. Begin by assumption that ยง5 is true. For this choose\n"
"name ยง6 for assumption and introduce it via ยง7"
msgstr ""

#. ยง0: `assumption`
#: Game.Levels.Logo.L04_Assumption
msgid "Use ยง0 as goal is in assumptions"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L06_IsFixedPt_odd
msgid "ยง0Conclusion Cantor L06"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "ยง0 Intro Piazza L03"
msgstr ""

#. ยง0: `ext`
#: Game.Levels.Robotswana.L10_Characterize
msgid "Use ยง0!"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "ยง0 Intro Saturn L01"
msgstr ""

#. ยง0: `use`
#. ยง1: `not_odd_iff_even`
#. ยง2: `not_odd_iff_even`
#. ยง3: `rw`
#. ยง4: `use`
#: Game.Levels.Quantus.L09_PushNeg
msgid "Try ยง0 with a number and then ยง1. You can not use ยง2\n"
"directly, as ยง3 cannot be applied inside of quantors. Try ยง4 with a number."
msgstr ""

#. ยง0: `symm`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Try ยง0 to fix skewed order"
msgstr ""

#. ยง0: `apply congr_arg`
#. ยง1: `ext`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Try using ยง0 and ยง1"
msgstr ""

#. ยง0: `r`
#. ยง1: `n ^ 2 = r + r`
#. ยง2: `let r := โฆ`
#: Game.Levels.Quantus.L04_Exists
msgid "Find ยง0 such that ยง1. Try ยง2"
msgstr ""

#: Game.Levels.Logo.L01_Tauto
#: Game.Levels.Logo.L01_Tauto
#: Game.Levels.Logo.L02_Rfl
#: Game.Levels.Logo.L03_Assumption
#: Game.Levels.Logo.L04_Assumption
#: Game.Levels.Logo.L05_True
#: Game.Levels.Logo.L06_Not
#: Game.Levels.Logo.L07_Contradiction
#: Game.Levels.Logo.L08_Contradiction
#: Game.Levels.Logo.L08_Contradiction
#: Game.Levels.Logo.L09_Contradiction
#: Game.Levels.Logo.L09_Contradiction
#: Game.Levels.Logo.L10_And
#: Game.Levels.Logo.L10_And
#: Game.Levels.Logo.L11_And
#: Game.Levels.Logo.L12_Or
#: Game.Levels.Logo.L13_Or
#: Game.Levels.Logo.L13_Or
#: Game.Levels.Logo.L14_Summary
#: Game.Levels.Implis.L01_Intro
#: Game.Levels.Implis.L02_Revert
#: Game.Levels.Implis.L03_Apply
#: Game.Levels.Implis.L04_Apply
#: Game.Levels.Implis.L05_Apply
#: Game.Levels.Implis.L06_Iff
#: Game.Levels.Implis.L07_Symm
#: Game.Levels.Implis.L08_Rw
#: Game.Levels.Implis.L09_Trans
#: Game.Levels.Implis.L10_Iff
#: Game.Levels.Implis.L11_Iff
#: Game.Levels.Implis.L12_ByCases
#: Game.Levels.Implis.L13_Rw
#: Game.Levels.Implis.L14_Summary
#: Game.Levels.Quantus.L01_NonemptyUse
#: Game.Levels.Quantus.L02_NonemptyObtain
#: Game.Levels.Quantus.L03_Decide
#: Game.Levels.Quantus.L04_Exists
#: Game.Levels.Quantus.L05_neg_pow
#: Game.Levels.Quantus.L05_neg_pow
#: Game.Levels.Quantus.L05_neg_pow
#: Game.Levels.Quantus.L05_neg_pow
#: Game.Levels.Quantus.L06_not_even_iff_odd
#: Game.Levels.Quantus.L06_not_even_iff_odd
#: Game.Levels.Quantus.L06_not_even_iff_odd
#: Game.Levels.Quantus.L07_Forall
#: Game.Levels.Quantus.L08_PushNeg
#: Game.Levels.Quantus.L09_PushNeg
#: Game.Levels.Quantus.L10_DrinkersParadox
#: Game.Levels.Saturn.L01_Rewrite_equality
#: Game.Levels.Saturn.L02_Ring_add_pow_two
#: Game.Levels.Saturn.L02_Ring_add_pow_two
#: Game.Levels.Saturn.L03_mul_comm
#: Game.Levels.Saturn.L03_mul_comm
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L05_Ring
#: Game.Levels.Saturn.L05_Ring
#: Game.Levels.Spinoza.L01_Have
#: Game.Levels.Spinoza.L02_Suffices
#: Game.Levels.Spinoza.L03_ByContra
#: Game.Levels.Spinoza.L04_ByContra
#: Game.Levels.Spinoza.L04_ByContra
#: Game.Levels.Spinoza.L05_Contrapose
#: Game.Levels.Spinoza.L06_Summary
#: Game.Levels.Luna.L01_le_rfl
#: Game.Levels.Luna.L01_le_rfl
#: Game.Levels.Luna.L02_Omega
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
#: Game.Levels.Luna.L04_Omega2
#: Game.Levels.Luna.L05_Linarith2
#: Game.Levels.Luna.L05_Linarith2
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L07_Linarith2
#: Game.Levels.Luna.L08_Omega3
#: Game.Levels.Luna.L08_Omega3
#: Game.Levels.Luna.L09_lt_trichotomy2
#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
#: Game.Levels.Babylon.L01_Sum_Simp_Card
#: Game.Levels.Babylon.L02_Card2
#: Game.Levels.Babylon.L03_sum_congr
#: Game.Levels.Babylon.L03_sum_congr
#: Game.Levels.Babylon.L04_sum_subset
#: Game.Levels.Babylon.L04_sum_subset
#: Game.Levels.Babylon.L05_sum_subset2
#: Game.Levels.Babylon.L05_sum_subset2
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L07_Induction2_sum_insert2
#: Game.Levels.Babylon.L07_Induction2_sum_insert2
#: Game.Levels.Babylon.L08_Induction3_sub_insert3
#: Game.Levels.Babylon.L09_Boss
#: Game.Levels.Cantor.L01_CantorPowerset
#: Game.Levels.Cantor.L01_CantorPowerset
#: Game.Levels.Cantor.L02_CantorPowerset
#: Game.Levels.Cantor.L03_IsFixedPt_abs
#: Game.Levels.Cantor.L04_fixedPoints_neg
#: Game.Levels.Cantor.L05_IsFixedPt_not
#: Game.Levels.Cantor.L05_IsFixedPt_not
#: Game.Levels.Cantor.L06_IsFixedPt_odd
#: Game.Levels.Cantor.L06_IsFixedPt_odd
#: Game.Levels.Cantor.L07_idempotent
#: Game.Levels.Cantor.L07_idempotent
#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
#: Game.Levels.Cantor.L09_CantorDiag
#: Game.Levels.Cantor.L09_CantorDiag
#: Game.Levels.Cantor.L10_CantorPowerset
#: Game.Levels.Cantor.L11_SequenceUncountable
#: Game.Levels.Robotswana.L01_SMulEBasis
#: Game.Levels.Robotswana.L01_SMulEBasis
#: Game.Levels.Robotswana.L02_EBasis
#: Game.Levels.Robotswana.L02_EBasis
#: Game.Levels.Robotswana.L03
#: Game.Levels.Robotswana.L03
#: Game.Levels.Robotswana.L03
#: Game.Levels.Robotswana.L04_MatrixEqSum
#: Game.Levels.Robotswana.L04_MatrixEqSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
#: Game.Levels.Robotswana.L08_EvalOnEBasis
#: Game.Levels.Robotswana.L08_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L10_Characterize
#: Game.Levels.Robotswana.L10_Characterize
#: Game.Levels.Robotswana.L11_Linearity
#: Game.Levels.Robotswana.L11_Linearity
#: Game.Levels.Robotswana.L11_Linearity
#: Game.Levels.Robotswana.L11_Linearity
#: Game.Levels.Robotswana.L11_Linearity
#: Game.Levels.Ciao.L01
#: Game.Levels.Ciao.L01
#: Game.Levels.Prado.L01_prime_two
#: Game.Levels.Prado.L01_prime_two
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
#: Game.Levels.Prado.L03_even_iff_two_dvd
#: Game.Levels.Prado.L03_even_iff_two_dvd
#: Game.Levels.Prado.L04_99
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
#: Game.Levels.Prado.L07_dvd_mul
#: Game.Levels.Prado.L07_dvd_mul
#: Game.Levels.Prado.L08_exists_prime_and_dvd
#: Game.Levels.Prado.L08_exists_prime_and_dvd
#: Game.Levels.Prado.L09_ExistsUnique
#: Game.Levels.Prado.L09_ExistsUnique
#: Game.Levels.Prado.L09_ExistsUnique
#: Game.Levels.Prado.L10_EvenPrime
#: Game.Levels.Euklid.L01_prod_pos
#: Game.Levels.Euklid.L01_prod_pos
#: Game.Levels.Euklid.L02_prod_insert
#: Game.Levels.Euklid.L02_prod_insert
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
#: Game.Levels.Vieta.L01_FunctionNotation
#: Game.Levels.Vieta.L02_Function
#: Game.Levels.Vieta.L02_Function
#: Game.Levels.Vieta.L03_Let
#: Game.Levels.Vieta.L03_Let
#: Game.Levels.Vieta.L04_Let
#: Game.Levels.Vieta.L04_Let
#: Game.Levels.Vieta.L05_Funext
#: Game.Levels.Vieta.L05_Funext
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Vieta.L07_Extend
#: Game.Levels.Vieta.L08_CongrArg
#: Game.Levels.Vieta.L08_CongrArg
#: Game.Levels.Vieta.L08_CongrArg
#: Game.Levels.Vieta.L09_CongrFun
#: Game.Levels.Vieta.L09_CongrFun
#: Game.Levels.Vieta.L09_CongrFun
#: Game.Levels.Vieta.L09_CongrFun
#: Game.Levels.Vieta.L10_Surjective
#: Game.Levels.Epo.L01_Surjective
#: Game.Levels.Epo.L01_Surjective
#: Game.Levels.Epo.L02_CurrySurjective
#: Game.Levels.Epo.L02_CurrySurjective
#: Game.Levels.Epo.L02_CurrySurjective
#: Game.Levels.Epo.L03_LeftInverse
#: Game.Levels.Epo.L03_LeftInverse
#: Game.Levels.Epo.L04_RightInverse
#: Game.Levels.Epo.L04_RightInverse
#: Game.Levels.Epo.L05_RightInverse
#: Game.Levels.Epo.L05_RightInverse
#: Game.Levels.Epo.L06_choose
#: Game.Levels.Epo.L06_choose
#: Game.Levels.Epo.L07_SurjectiveRightInverse
#: Game.Levels.Epo.L07_SurjectiveRightInverse
#: Game.Levels.Epo.L07_SurjectiveRightInverse
#: Game.Levels.Mono.L01_Injective
#: Game.Levels.Mono.L02_InjectiveNeIff
#: Game.Levels.Mono.L02_InjectiveNeIff
#: Game.Levels.Mono.L02_InjectiveNeIff
#: Game.Levels.Mono.L03_NotInjective
#: Game.Levels.Mono.L03_NotInjective
#: Game.Levels.Mono.L03_NotInjective
#: Game.Levels.Mono.L04_Diagonal
#: Game.Levels.Mono.L04_Diagonal
#: Game.Levels.Mono.L05_StrictMono
#: Game.Levels.Mono.L05_StrictMono
#: Game.Levels.Mono.L05_StrictMono
#: Game.Levels.Mono.L06_StrictMono
#: Game.Levels.Mono.L07_SuccHasLeftInv
#: Game.Levels.Mono.L07_SuccHasLeftInv
#: Game.Levels.Mono.L08_RightInvOfLeftInv
#: Game.Levels.Mono.L08_RightInvOfLeftInv
#: Game.Levels.Mono.L09_InjOfHasLeftInv
#: Game.Levels.Mono.L09_InjOfHasLeftInv
#: Game.Levels.Mono.L09_InjOfHasLeftInv
#: Game.Levels.Mono.L10_Auxiliary
#: Game.Levels.Mono.L10_Auxiliary
#: Game.Levels.Mono.L11_InjHasLeftInv
#: Game.Levels.Mono.L11_InjHasLeftInv
#: Game.Levels.Mono.L11_InjHasLeftInv
#: Game.Levels.Samarkand.L01_ImagePreimage
#: Game.Levels.Samarkand.L01_ImagePreimage
#: Game.Levels.Samarkand.L02_ImageMap
#: Game.Levels.Samarkand.L03_SurjectiveRange
#: Game.Levels.Samarkand.L03_SurjectiveRange
#: Game.Levels.Samarkand.L03_SurjectiveRange
#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
#: Game.Levels.Samarkand.L05_InjectiveFibre
#: Game.Levels.Samarkand.L05_InjectiveFibre
#: Game.Levels.Samarkand.L06_PreimageNonempty
#: Game.Levels.Samarkand.L07_LeftInvPreimage
#: Game.Levels.Samarkand.L08_Preimage_Injective
#: Game.Levels.Samarkand.L08_Preimage_Injective
#: Game.Levels.Iso.L01_Bijective
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Piazza.L01_Mem__Set
#: Game.Levels.Piazza.L02_Simp
#: Game.Levels.Piazza.L02_Simp
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
#: Game.Levels.Piazza.L06_Ext2__univ2
#: Game.Levels.Piazza.L07_antisymm_iff
#: Game.Levels.Piazza.L07_antisymm_iff
#: Game.Levels.Piazza.L07_antisymm_iff
#: Game.Levels.Piazza.L08_subset_iff
#: Game.Levels.Piazza.L08_subset_iff
#: Game.Levels.Piazza.L08_subset_iff
#: Game.Levels.Piazza.L08_subset_iff
#: Game.Levels.Piazza.L09_subset_iff2
#: Game.Levels.Piazza.L09_subset_iff2
#: Game.Levels.Piazza.L10
#: Game.Levels.Piazza.L11_erase
#: Game.Levels.Piazza.L11_erase
#: Game.Levels.Piazza.L12_insert
#: Game.Levels.Piazza.L12_insert
#: Game.Levels.Piazza.L13_insert_erase
#: Game.Levels.Piazza.L13_insert_erase
msgid ""
msgstr ""

#. ยง0: `โโโฒโฌโโผโขฆโฝชโโซโฝญโโโฏโซโขโโโฎโโงโถคโโงโโธโฉโชโโฉโฅโตโฎโชณโโโฟฉโโกโดโธโโฎโฃโนโชโพโผฐโฐโฆโโบโโดโฌโพโโโฐโฑโทโคโพโฝฌโฏโณโงญโธโตนโพโกโพโขโจโโผญโปโดฒโฆโฎโโกโงโโฌโโโโฝโโโ โฆ`
#: Game.Levels.Euklid
msgid "Intro Euklid: shows encrypted message ยง0"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Euklid.L01_prod_pos
msgid "ยง0 The expression itself seems to be correct"
msgstr ""

#. ยง0: `ยซ{hB}ยป : ยซ{B}ยป`
#: Game.Levels.Implis.L04_Apply
msgid "Now assumption ยง0 is available"
msgstr ""

#: Game.Levels.Quantus
msgid "Quantus"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Spinoza
msgid "ยง0 Intro Spinoza"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Prado.L10_EvenPrime
msgid "ยง0 Remind former proof"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Spinoza.L05_Contrapose
msgid "ยง0 Conclusion Spinoza L05"
msgstr ""

#. ยง0: $$
#. \\begin{aligned}
#. f(A)
#. &= f\\left( \\sum_{i,j} A_{i,j} \\cdot E_{i,j} \\right) \\
#. &= \\sum_{i,j} A_{i,j} \\cdot f(E_{i,j})   \\
#. &= \\sum_{i} A_{i,i} \\cdot f(E_{i,i})
#. \\end{aligned}
#. $$
#. ยง1: `A`
#. ยง2: `f`
#. ยง3: `E i j`
#. ยง4: `i โ j`
#. ยง5: `A`
#. ยง6: `f A`
#. ยง7: `A`
#. ยง8: `nth_rw 1 [ ... ]`
#. ยง9: `rw`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "\n"
"ยง0\n"
"\n"
"Write ยง1 as sum of base matrices. Use linearity to make ยง2 disappear in ยง3 with ยง4.\n"
"Rewrite first ยง5 in ยง6 as sum of base matrices, but not the later ยง7. Try ยง8\n"
"which works like ยง9.\n"
""
msgstr ""

#. ยง0: `congr_arg g`
#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "Try using ยง0"
msgstr ""

#. ยง0: `succ`
#. ยง1: `succ : โ โ โ`
#. ยง2: `n โฆ n + 1`
#. ยง3: `f`
#: Game.Levels.Vieta.L10_Surjective
msgid "Explain ยง0 as mapping ยง1 i.e. ยง2. Explain goal of showing ยง3 surjective."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "ยง0 Conclusion Samarkand L06"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "ยง0 Intro Robotswana L04"
msgstr ""

#. ยง0: `contradiction`
#: Game.Levels.Spinoza.L01_Have
msgid "If to assumptions contradict each other use ยง0"
msgstr ""

#. ยง0: `revert h`
#. ยง1: `h`
#. ยง2: `h : A`
#. ยง3: `โข B`
#. ยง4: `โข A โ B`
#. ยง5: `intro h`
#. ยง6: `revert h`
#: Game.Doc.Tactic
msgid "The tactic ยง0 adds the assumption ยง1 as an implication premise to the proof goal:\n"
"from ยง2 and ยง3, we get ยง4.\n"
"\n"
"## Friends and relatives\n"
"\n"
"The tactic ยง5 does the exact opposite of ยง6."
msgstr ""

#. ยง0: `intro`
#: Game.Levels.Iso.L02_Inverse
msgid "Try beginning with ยง0"
msgstr ""

#: Game.Levels.Spinoza
msgid "Spinoza"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L02_Simp
msgid "ยง0 Intro Piazza L02"
msgstr ""

#. ยง0: `if_pos`
#: Game.Levels.Vieta.L06_Piecewise
msgid "Remind of negation for ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Babylon.L05_sum_subset2
msgid "ยง0 Conclusion Babylon L05"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Babylon.L08_Induction3_sub_insert3
msgid "ยง0 Conclusion Babylon L08"
msgstr ""

#. ยง0: `omega`
#. ยง1: `omega`
#. ยง2: `omega`
#: Game.Levels.Luna.L02_Omega
msgid "Conclusion Luna L02: ยง0 is popular, even though ยง1 is quiet useless.\n"
"ยง2 is only really applicable over integers."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L07_Contradiction
msgid "ยง0 Intro Logo L07"
msgstr ""

#. ยง0: `unfold F`
#. ยง1: `F`
#. ยง2: `unfold F at h`
#. ยง3: `h`
#. ยง4: `unfold`
#. ยง5: `push_neg`
#. ยง6: `rw`
#. ยง7: `unfold F`
#. ยง8: `simp only [F]`
#: Game.Doc.Tactic
msgid "With ยง0, you can write out the definition ยง1 in the proof goal.\n"
"With ยง2, you do the same thing, but in the assumption ยง3.\n"
"\n"
"Although the proof goal or assumption before and after ยง4 are identical in definition,\n"
"many tactics (e.g., ยง5 or ยง6) operate on a syntactic level;\n"
"they do not โsee through definitions.โ\n"
"\n"
"## Friends and Relatives\n"
"\n"
"The tactics ยง7 and ยง8 do practically the same thing."
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Piazza.L07_antisymm_iff
msgid "ยง0 Try ext, tauto"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L07_Forall
msgid "ยง0 Intro Quantus L07"
msgstr ""

#. ยง0: `intro`
#: Game.Levels.Implis.L10_Iff
msgid "Best begin with ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Iso.L01_Bijective
msgid "ยง0 Conclusion Iso L01"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Spinoza.L02_Suffices
msgid "ยง0 Intro Spinoza L02"
msgstr ""

#. ยง0: `b`
#. ยง1: `use โฆ`
#. ยง2: `lt_trichotomy`
#. ยง3: ```
#. obtain h | h | h := lt_trichotomy a c
#. ```
#: Game.Levels.Luna.L09_lt_trichotomy2
msgid "It is clear which ยง0 can be used. Start with ยง1 and continue with ยง2 e.g.\n"
"ยง3\n"
""
msgstr ""

#. ยง0: `if_neg ยซ{hโ}ยป`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Here try ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L08_Rw
msgid "ยง0 Intro Implis L08"
msgstr ""

#. ยง0: ```
#. h : โ (b : B), P b
#. ```
#. ยง1: `choose b hb using h`
#. ยง2: `b : A`
#. ยง3: `hb : P b`
#. ยง4: `choose`
#. ยง5: ```
#. h : โ (a : A), โ (b : B), P a b
#. ```
#. ยง6: `choose f hf using h`
#. ยง7: `f : A โ B`
#. ยง8: `hf : โ (a : A), P a (f a)`
#. ยง9: `P : A โ (B โ Prop)`
#. ยง10: `a`
#. ยง11: `b`
#: Game.Doc.Tactic
msgid "An assumption of the form\n"
"ยง0\n"
"can be decomposed, using ยง1, into the components ยง2 and ยง3.\n"
"\n"
"More generally, you can use ยง4 to select elements using the choice axiom:\n"
"from an assumption of the form\n"
"ยง5\n"
"extracts ยง6\n"
"a mapping ยง7 and the assumption ยง8.\n"
"\n"
"(Here, ยง9 is a predicate that depends on two variables ยง10 and ยง11.)"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L09_Boss
msgid "ยง0 Intro Babylon L09"
msgstr ""

#. ยง0: `trans`
#. ยง1: `โข A = C`
#. ยง2: `trans B`
#. ยง3: `โข A = B`
#. ยง4: `โข B = C`
#. ยง5: `โข A โ C`
#. ยง6: `trans B`
#. ยง7: `โข A โ B`
#. ยง8: `โข B โ C`
#. ยง9: `A = Bโ = Bโ = Bโ โฆ = C`
#. ยง10: `calc`
#: Game.Doc.Tactic
msgid "With ยง0, you insert an intermediate step into an equation or equivalence.\n"
"\n"
"| before | tactic    | after                |\n"
"|:------------ |:--------- |:----------------------- |\n"
"| ยง1    | ยง2 | ยง3 and ยง4 |\n"
"| ยง5    | ยง6 | ยง7 and ยง8 |\n"
"\n"
"Since you can repeat the tactic several times, it is suitable for\n"
"performing a โcalculationโ ยง9 step by step.\n"
"\n"
"(Outside of the game, however, the multi-line tactic ยง10 is better suited for such calculations.)"
msgstr ""

#. ยง0: `simp [f, g]`
#. ยง1: `VIETA_SECOND`
#: Game.Levels.Vieta.L06_Piecewise
msgid "Try ยง0 ยง1"
msgstr ""

#. ยง0: `omega`
#: Game.Levels.Luna.L02_Omega
msgid "Try out ยง0"
msgstr ""

#. ยง0: ``` i ^ 3 - 3 * i ^ 2 + 2 * i = 0 ```
#: Game.Levels.Babylon.L04_sum_subset
msgid "Introduce assumptions until ยง0 as goal"
msgstr ""

#. ยง0: `simp at ยซ{h'}ยป`
#: Game.Levels.Luna.L08_Omega3
msgid "Definitely use ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna
msgid "ยง0 Intro Luna"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Luna.L04_Omega2
msgid "ยง0 Conclusion Luna L04"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "ยง0 Intro Samarkand L01"
msgstr ""

#. ยง0: `tauto`
#. ยง1: `DOC2`
#: Game.Levels.Implis.L14_Summary
msgid "In most cases ยง0 can be used to solve this kind of logical expression. ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L07_Symm
msgid "ยง0 Conclusion Implis L07"
msgstr ""

#. ยง0: `univ`
#. ยง1: `univ`
#. ยง2: `โ`
#. ยง3: `univ : Set โ`
#. ยง4: `โ`
#. ยง5: `5 : โ`
#. ยง6: `univ : Set โ`
#. ยง7: `5`
#. ยง8: `5 โ univ`
#. ยง9: `rw [eq_univ_iff_forall]`
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "Explain ยง0: ยง1 is interpreted as ยง2 but as a subset of it self i.e. ยง3\n"
"is subset of ยง4. So, as 5 is a natural number (ยง5) and it holds that ยง6, ยง7\n"
"is also in this set i.e. ยง8. Try ยง9"
msgstr ""

#. ยง0: `eq_sum_apply_diag_ebasis`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Use the result ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
msgid "ยง0 Intro Euklid L04"
msgstr ""

#. ยง0: `2`
#. ยง1: `decide`
#: Game.Levels.Prado.L01_prime_two
msgid "Because ยง0 is a concrete data and there is a algorithm to decide if a number is prime you can use ยง1"
msgstr ""

#. ยง0: $$
#. \\begin{aligned}
#. \\tfrac{35}{11}\\cdot y &\\le -\\tfrac{22}{21}\\cdot x + \\tfrac{35}{2}  \\
#. \\tfrac{8}{9} \\cdot y &\\le x + \\tfrac{17}{8}
#. \\end{aligned}
#. $$
#. ยง1: $$
#. y โค \\tfrac{34}{7}
#. $$
#: Game.Levels.Luna.L07_Linarith2
msgid "\n"
"Given\n"
"\n"
"ยง0\n"
"\n"
"Show\n"
"ยง1\n"
""
msgstr ""

#. ยง0: `have`
#. ยง1: `suffices`
#. ยง2: `by_contra`
#. ยง3: `contradiction`
#. ยง4: `contrapose`
#. ยง5: `revert`
#. ยง6: `contrapose`
#: Game.Levels.Spinoza.L06_Summary
msgid "Conclusion Spinoza L06: overview of planet's contents:\n"
"ยง0, ยง1, ยง2, ยง3, ยง4, ยง5 (useful when applying\n"
"ยง6 afterwards)."
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Samarkand.L02_ImageMap
msgid "ยง0 This can be simplified"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Saturn.L04_mul_assoc
msgid "ยง0 Intro Saturn L04"
msgstr ""

#. ยง0: `cantor_diagonal`
#. ยง1: `apply cantor_diagonal at ยซ{hf}ยป`
#: Game.Levels.Cantor.L10_CantorPowerset
msgid "Use ยง0 as e.g. ยง1"
msgstr ""

#. ยง0: `ยซ{h}ยป : ยซ{n}ยป = 0`
#. ยง1: `ยซ{i}ยป : Fin ยซ{n}ยป`
#. ยง2: `ยซ{i}ยป`
#. ยง3: `Fin 0`
#. ยง4: `simp [ยซ{h}ยป] at ยซ{i}ยป`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Put ยง0 into ยง1 to show triviality because there is no ยง2 in ยง3. Try ยง4"
msgstr ""

#. ยง0: `contradiction`
#: Game.Levels.Logo.L07_Contradiction
msgid "Conclusion Logo L07: There is ยง0 in assumptions"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L03_Assumption
msgid "ยง0 Intro Logo L03"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `preimage f : Set B โ Set A`
#. ยง2: `B`
#. ยง3: `f โปยน' A`
#. ยง4: `f`
#: Game.Doc.Definition
msgid "For a mapping ยง0, ยง1\n"
"is one of the induced mappings on the power sets โ\n"
"it maps a subset of ยง2 to the preimage ยง3 of this subset under ยง4."
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Cantor.L03_IsFixedPt_abs
#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "ยง0 can used always"
msgstr ""

#. ยง0: `push_neg`
#. ยง1: `not_exists (P : X โ Prop) : ยฌ (โ x, P x) โ โ x, (ยฌ P x)`
#. ยง2: `not_forall (P : X โ Prop) : ยฌ (โ x, P x) โ โ x, (ยฌ P x)`
#. ยง3: `push_neg`
#: Game.Levels.Quantus.L08_PushNeg
msgid "Conclusion Quantus L08: ยง0 internally uses ยง1\n"
"and ยง2. Memorize ยง3."
msgstr ""

#. ยง0: `push_neg at ยซ{h}ยป`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Continue with ยง0"
msgstr ""

#. ยง0: `ยซ{b}ยป = a`
#: Game.Levels.Piazza.L13_insert_erase
msgid "Try proof by cases, if ยง0"
msgstr ""

#. ยง0: `SHORT CAPTION`
#: Game
msgid "ยง0 Explore an alien universe with the Smart-Elf Robo!"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L09_lt_trichotomy2
msgid "ยง0 Intro Luna L09"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L04_sum_subset
msgid "ยง0 Intro Babylon L04"
msgstr ""

#: Game.Levels.Robotswana
msgid "Robotswana"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Epo.L04_RightInverse
msgid "ยง0 look through definitions"
msgstr ""

#. ยง0: `โ (y : ยซ{People}ยป), ยซ{isDrinking}ยป y`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Try proof by case for ยง0"
msgstr ""

#. ยง0: `n`
#. ยง1: `x โฆ x ^ n`
#. ยง2: `h_odd : Odd n`
#. ยง3: `Odd.strictMono_pow h_odd`
#. ยง4: `h_odd.strictMono_pow`
#: Game.Levels.Mono.L05_StrictMono
msgid "Fรผr ungerades ยง0 ist ยง1 strikt monoton.\n"
"\n"
"*Bemerkung*: Hat man ยง2 als Annahme, so kann man statt ยง3 auch einfach ยง4 schreiben."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L08_subset_iff
msgid "ยง0 Intro Piazza L08"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L02_Function
msgid "ยง0 Intro Vieta L02"
msgstr ""

#. ยง0: `obtain`
#: Game.Levels.Logo.L14_Summary
msgid "Divide ยซ{h}ยป with ยง0"
msgstr ""

#. ยง0: `have hB : B`
#: Game.Levels.Implis.L04_Apply
msgid "Try holding onto ยง0"
msgstr ""

#. ยง0: `diag`
#. ยง1: $a$
#. ยง2: $i \\in \\{0,1,โฆ,n\\}$
#. ยง3: $a$
#. ยง4: $a โฆ (a,โฆ,a)$
#: Game.Levels.Mono.L04_Diagonal
msgid "To be more precise: ยง0 sends an ยง1 onto the mapping, which maps each index ยง2 onto ยง3.\n"
"In the former intepretation this is the mapping ยง4."
msgstr ""

#. ยง0: `consturctor`
#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "Try to start with ยง0"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#. ยง0: `ยซ{B}ยป`
#. ยง1: `ยฌยซ{B}ยป`
#: Game.Levels.Spinoza.L03_ByContra
msgid "Finish proof by stating contradiction between ยง0 and ยง1"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `S`
#. ยง2: `A`
#. ยง3: ```
#. f '' S = {f a | a โ S}
#. = {b | โ a โ S, f a = b}
#. ```
#. ยง4: `f`
#. ยง5: `T`
#. ยง6: `B`
#. ยง7: ```
#. f โปยน' T = { a | f a โ T}
#. ```
#. ยง8: `f`
#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "Explain statement: given ยง0 for subset ยง1 of ยง2\n"
"ยง3\n"
"is the image over ยง4. For subset ยง5 of ยง6\n"
"ยง7\n"
"is the pre-image over ยง8,\n"
""
msgstr ""

#. ยง0: `apply congr_fun at h`
#: Game.Levels.Cantor.L07_idempotent
msgid "Specifically try ยง0"
msgstr ""

#. ยง0: `2`
#. ยง1: `a`
#. ยง2: `b`
#. ยง3: `a`
#. ยง4: `b`
#. ยง5: `a โฃ b`
#. ยง6: `\\|`
#. ยง7: `\\dvd`
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "Intro Prado L02: Prove that ยง0 is only even prime by using the expression โยง1 divides ยง2โ.\n"
"โยง3 divides ยง4โ is written as ยง5, where the vertical bar can be either written as ยง6 or ยง7"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L06_not_even_iff_odd
msgid "ยง0 Conclusion Quantus L06"
msgstr ""

#. ยง0: $A \\Rightarrow B \\Rightarrow C$
#. ยง1: $A \\Rightarrow C$
#. ยง2: `intro`
#: Game.Levels.Implis.L04_Apply
msgid "Combine implications ยง0 into ยง1. Try ยง2"
msgstr ""

#. ยง0: `rw [โ insert_erase ยซ{ha}ยป]`
#: Game.Levels.Euklid.L02_prod_insert
msgid "Try rewriting with ยง0"
msgstr ""

#. ยง0: `contradiction`
#. ยง1: `h : n โ n`
#. ยง2: `h : A`
#. ยง3: `h' : ยฌA`
#. ยง4: `h : False`
#. ยง5: `contradiction`
#. ยง6: `by_contra`
#: Game.Doc.Tactic
msgid "The tactic ยง0 concludes the proof if it finds a contradiction in the assumptions.\n"
"Such a contradiction can look like this, for example:\n"
"\n"
"* ยง1\n"
"* ยง2 and ยง3\n"
"* ยง4\n"
"\n"
"## Friends and relatives\n"
"\n"
"Normally, ยง5 is used to conclude a proof by contradiction\n"
"that was opened with ยง6."
msgstr ""

#. ยง0: `symm`
#. ยง1: `symm at ยซ{h}ยป`
#: Game.Levels.Implis.L07_Symm
msgid "Try ยง0 or ยง1 to turn one around"
msgstr ""

#. ยง0: `ยซ{h}ยป`
#. ยง1: `s`
#. ยง2: `s + s = ยซ{n}ยป`
#. ยง3: `choose s hs using ยซ{h}ยป`
#. ยง4: `s`
#: Game.Levels.Quantus.L04_Exists
msgid "Explain that from ยง0 follow that there is ยง1 such that ยง2. Try ยง3\n"
"to introduce ยง4."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L01_Intro
msgid "ยง0 Intro Implis L01"
msgstr ""

#. ยง0: `RightInverse`
#. ยง1: `rw`
#: Game.Levels.Iso.L02_Inverse
msgid "Use assumption ยง0 with ยง1"
msgstr ""

#. ยง0: `by_contra`
#. ยง1: `lt_of_mul_lt_mul_left`
#. ยง2: `a b c : โ`
#. ยง3: `a * b < a * c`
#. ยง4: `b < c`
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid "Use ยง0 and the lemma ยง1.\n"
"For the latter, given ยง2 it concludes from the assumption ยง3 that ยง4"
msgstr ""

#. ยง0: `congr_fun`
#. ยง1: `ยซ{hs}ยป`
#. ยง2: `โ x, (ยซ{f}ยป โ ยซ{g}ยป) x = (succ โ ยซ{f}ยป)`
#: Game.Levels.Vieta.L10_Surjective
msgid "Try ยง0 to rewrite ยง1 to ยง2"
msgstr ""

#. ยง0: `funext`
#. ยง1: `funext x`
#. ยง2: `x`
#. ยง3: `f = g`
#. ยง4: `f x = g x`
#: Game.Levels.Vieta.L05_Funext
msgid "Try ยง0. Explain ยง1 as taking arbitrary ยง2 and changing goal from ยง3 to ยง4"
msgstr ""

#. ยง0: `f`
#. ยง1: `E i j`
#. ยง2: `iโj`
#. ยง3: `trans โ i, โ j, if i = j then (A i j) * f (E i j) else 0`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Use disappearing ยง0 in ยง1 with ยง2. Try ยง3"
msgstr ""

#. ยง0: `decide`
#. ยง1: `Even 42`
#. ยง2: `decide`
#: Game.Levels.Quantus.L03_Decide
msgid "Conclusion Quantus L03: Explain that ยง0 can show True/False for ยง1, if\n"
"ยง2 possesses an algorithm for making this decision"
msgstr ""

#. ยง0: `IN_HINT 1`
#: Game.Levels.Iso.L02_Inverse
msgid "ยง0 stroy"
msgstr ""

#. ยง0: `by_cases h : Even n`
#. ยง1: `Even x โจ ยฌEven x`
#. ยง2: `tauto`
#. ยง3: ```
#. rw [โ Nat.not_odd_iff_even]
#. ```
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "ยง0 would lead you to your goal. Note that ยง1 is a tautology.\n"
"To apply ยง2 it has to be abstracted e.g. with\n"
"ยง3\n"
""
msgstr ""

#. ยง0: `funext x`
#: Game.Levels.Vieta.L06_Piecewise
msgid "Show swappability if mapping by using ยง0"
msgstr ""

#. ยง0: `mopo`
#. ยง1: `mopo`
#. ยง2: `revert ยซ{hA}ยป`
#: Game.Levels.Implis.L02_Revert
msgid "You cannot use ยง0. There is no ยง1. Try ยง2"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Vieta.L10_Surjective
msgid "ยง0 Conclusion Vieta L10"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L04_Assumption
msgid "ยง0 Intro Logo L04"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "ยง0 Intro Euklid L03"
msgstr ""

#. ยง0: `n โฆ n + 1`
#. ยง1: `succ`
#: Game.Levels.Cantor.L11_SequenceUncountable
msgid "The name of mapping ยง0 is ยง1"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Implis.L06_Iff
msgid "ยง0 parts available in assumptions"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L05_True
msgid "ยง0 Intro Logo L05"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "ยง0 Conclusion Robotswana L07"
msgstr ""

#. ยง0: `โ : Set T`
#. ยง1: `โ : Set โ`
#. ยง2: `โ : Set โ`
#. ยง3: `rw [eq_empty_iff_forall_not_mem]`
#. ยง4: `S = โ`
#. ยง5: `โ (x : T), x โ s`
#. ยง6: `โ`
#. ยง7: `\\emptyset`
#: Game.Doc.Definition
msgid "ยง0 is the empty subset.\n"
"In the Formaloverse ยง1 is something different than ยง2\n"
"โ one is a subset of โ, the other is a subset of โ!\n"
"\n"
"With ยง3 you translate the equation ยง4 into the\n"
"statement ยง5.\n"
"\n"
"ยง6 is written as ยง7."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L05_IsFixedPt_not
msgid "ยง0Conclusion Cantor L05"
msgstr ""

#. ยง0: `obtain`
#. ยง1: `use`
#. ยง2: `obtain โจx ,hxโฉ := _`
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "Continue with ยง0 and ยง1. Fristly diect assumptions with ยง2"
msgstr ""

#. ยง0: `tauto`
#: Game.Levels.Implis
msgid "Intro Implis: mention that planet could not be solved without ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L05_Funext
msgid "ยง0 Intro Vieta L05"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L01_Sum_Simp_Card
msgid "ยง0 Intro Babylon L01"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "ยง0 Intro Babylon L06"
msgstr ""

#. ยง0: $42 = 42$
#: Game.Levels.Logo.L02_Rfl
msgid "Intro Logo L02: Why is ยง0?"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L05_neg_pow
msgid "ยง0 Intro Quantus L05"
msgstr ""

#. ยง0: `n : โ`
#. ยง1: `Fin n`
#. ยง2: $\\{0, \\dots, n-1\\}$
#. ยง3: `Fin n`
#. ยง4: `Icc 0 (n-1)`
#. ยง5: `Fin n`
#. ยง6: `Fin n : Type`
#. ยง7: `Icc 0 (n-1) : Finset โ`
#. ยง8: `โ`
#: Game.Doc.Definition
msgid "For ยง0, ยง1 is the set ยง2.\n"
"\n"
"(ยง3 is to be distinguished from ยง4:\n"
"ยง5 is a set, or more precisely a type, i.e. ยง6,\n"
"whereas ยง7 is a finite subset of ยง8.)"
msgstr ""

#. ยง0: `n โค n`
#: Game.Levels.Luna.L01_le_rfl
msgid "Intro Luna L01: Know that ยง0"
msgstr ""

#. ยง0: `let all_primes := hf.toFinset`
#. ยง1: `Finset`
#. ยง2: `hf`
#. ยง3: `{ p : โ | Prime p} : Set โ`
#. ยง4: `{ p : โ | Prime p} : Finset โ`
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "Here ยง0 is useful. The product over all primes can only be reasoned\n"
"with, when interpreted as a ยง1. The first line does exactly this: it uses ยง2 to transform\n"
"ยง3 into a finite set ยง4."
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "You can skip induction start by using ยง0"
msgstr ""

#. ยง0: `constructor`
#. ยง1: `comp_apply`
#. ยง2: `congr_fun`
#: Game.Levels.Epo.L04_RightInverse
msgid "Try ยง0, ยง1 | ยง2"
msgstr ""

#. ยง0: `โ`
#. ยง1: `rw [eq_empty_iff_forall_not_mem]`
#. ยง2: `simp [eq_empty_iff_forall_not_mem]`
#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid "Having ยง0 you could either start with ยง1 or\n"
"ยง2"
msgstr ""

#. ยง0: `comp_apply`
#. ยง1: `simp`
#: Game.Levels.Cantor.L07_idempotent
msgid "Try either ยง0 or ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid "ยง0 Conclusion Prado L08"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L04_Assumption
msgid "ยง0 Conclusion Logo L04"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Robotswana.L11_Linearity
msgid "ยง0 Explain statement"
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `โ a : A, P a`
#. ยง2: `P a`
#. ยง3: `a`
#. ยง4: `A`
#. ยง5: `a`
#. ยง6: `A`
#. ยง7: `โ`
#. ยง8: `โ a : A, โฆ`
#. ยง9: `intro a`
#. ยง10: `a`
#. ยง11: `โ`
#. ยง12: `h : โ a : A, P a`
#. ยง13: `aโ : A`
#. ยง14: `h aโ`
#. ยง15: `P aโ`
#. ยง16: `specialize h aโ`
#. ยง17: `a`
#. ยง18: `h : P aโ`
#. ยง19: `aโ`
#: Game.Doc.Definition
msgid "Universal quantifier: If ยง0 is a predicate, then\n"
"ยง1 is the statement that the statement ยง2 is true for all ยง3 in ยง4\n"
"(more precisely: for all ยง5 of type ยง6).\n"
"## ยง7 as a proof goal\n"
"To prove a statement of the form ยง8, first use ยง9 to select any element ยง10.\n"
"## ยง11 as an assumption\n"
"If ยง12 is an assumption and ยง13 is a concrete element, then ยง14 is a notation for ยง15.\n"
"\n"
"You can also use ยง16 to restrict the given assumption\n"
"over all possible ยง17 to an assumption ยง18 over this concrete ยง19."
msgstr ""

#. ยง0: $$
#.   \\begin{CD}
#.        A  @>{f}>> B @<{g}<< C    \\
#.     @V{h}VV    @V{i}VV   @V{j}VV \\
#.        D  @<{k}<< E @>{l}>> F    \\
#.     @A{m}AA    @A{n}AA   @V{p}VV \\
#.        G  @<{q}<< H @>{r}>> I
#.   \\end{CD}
#.   $$
#: Game.Levels.Implis.L05_Apply
msgid "Intro Implis L05: Introduce implication graph\n"
"  ยง0"
msgstr ""

#. ยง0: `A`
#. ยง1: `A`
#. ยง2: `h`
#. ยง3: `A`
#. ยง4: `obtain`
#. ยง5: `obtain โจaโฉ := h`
#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "ยง0 is in 'type', whcih can be interpreted as ยง1 being a set which is by assumption ยง2\n"
"not empty. The goal is to show that there is an element in ยง3. Use ยง4 to disect assumption.\n"
"Try ยง5."
msgstr ""

#. ยง0: `intro`
#. ยง1: `A โ B`
#. ยง2: `โ x, P x`
#. ยง3: `A โ B`
#. ยง4: `intro h`
#. ยง5: `h : A`
#. ยง6: `B`
#. ยง7: `โ x, P x`
#. ยง8: `intro x`
#. ยง9: `x`
#. ยง10: `P x`
#. ยง11: `โข A โ B`
#. ยง12: `intro h`
#. ยง13: `h : A`
#. ยง14: `โข B`
#. ยง15: `โข  x, P x`
#. ยง16: `intro x hx`
#. ยง17: `x : X`
#. ยง18: `hx : P x`
#. ยง19: `โข P x`
#. ยง20: `revert h`
#. ยง21: `intro h`
#: Game.Doc.Tactic
msgid "The tactic ยง0 is used for   proof goals of the form ยง1 or ยง2.\n"
"\n"
"If your proof goal is ยง3, ยง4 gives you the assumption ยง5, and you then have to prove ยง6.\n"
"If your proof goal is ยง7, ยง8 gices you an arbitrary ยง9 and you have to prove ยง10.\n"
"\n"
"| before | tactic       | after                     |\n"
"|:------------ |:------------ |:---------------------------- |\n"
"| ยง11    | ยง12    | ยง13, ยง14               |\n"
"| ยง15  | ยง16 | ยง17, ยง18, ยง19 |\n"
"\n"
"\n"
"## Friends and relatives\n"
"\n"
"The tactic ยง20 does the exact opposite of ยง21."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "ยง0 Conclusion Samarkand L03"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `image f : Set A โ Set B`
#. ยง2: `A`
#. ยง3: `f '' A`
#. ยง4: `f`
#: Game.Doc.Definition
msgid "For a mapping ยง0, ยง1\n"
"is one of the induced mappings on the power sets โ\n"
"it maps a subset of ยง2 to the image ยง3 of this subset under ยง4."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L11_And
msgid "ยง0 Intro Logo L11"
msgstr ""

#. ยง0: `push_neg`
#. ยง1: `intro f`
#: Game.Levels.Cantor.L02_CantorPowerset
msgid "Start here with ยง0 and ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "ยง0 Intro Prado L06"
msgstr ""

#. ยง0: `intro`
#. ยง1: `ISO_SECOND`
#: Game.Levels.Iso.L02_Inverse
msgid "Try ยง0 to approach injectivity ยง1"
msgstr ""

#. ยง0: `fun x โฆ _`
#. ยง1: `fun (x : โค) โฆ  -x`
#. ยง2: `โค โ โค`
#. ยง3: `โฆ`
#. ยง4: `\\maps`
#. ยง5: `\\mapsto`
#. ยง6: `โฆ`
#. ยง7: `=>`
#: Game.Doc.Definition
msgid "The notation ยง0 is used to define โanonymous functions.โ\n"
"For example, ยง1 defines the negation ยง2 without giving it a name.\n"
"You write the arrow ยง3 as ยง4 or ยง5.\n"
"Alternatively, instead of ยง6 you can use ยง7."
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Babylon.L09_Boss
msgid "ยง0 this should work"
msgstr ""

#. ยง0: `not_odd_iff_even`
#: Game.Levels.Quantus.L09_PushNeg
msgid "Now you can apply ยง0"
msgstr ""

#. ยง0: `all_primes.bubblewrap = blister cong foo`
#. ยง1: `\\prod`
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "ยง0 us nonsensical. You want to use the product of\n"
"all those numbers. Write the product sign as ยง1"
msgstr ""

#. ยง0: `intro`
#: Game.Levels.Implis.L14_Summary
msgid "Try ยง0 to solve implication"
msgstr ""

#. ยง0: `P : T โ Prop`
#. ยง1: `{ a : T | P a } : Set P`
#. ยง2: ```
#. { n : โ | Even n }
#. ```
#. ยง3: `a โ { a : T | P a }`
#. ยง4: `simp`
#. ยง5: `P a`
#: Game.Doc.Definition
msgid "For a predicate ยง0, ยง1 is the subset\n"
"consisting of all elements that satisfy the predicate.  For example,\n"
"ยง2\n"
"is the set of even natural numbers.\n"
"You can simplify the statement ยง3, using ยง4, to ยง5 ."
msgstr ""

#. ยง0: `x : โ`
#. ยง1: `|x|`
#. ยง2: `x`
#. ยง3: `|`
#: Game.Doc.Definition
msgid "For ยง0, ยง1 is the absolute value of ยง2.\n"
"(Here, ยง3 is the usual vertical bar on the keyboard.)"
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `ยซ{B}ยป`
#. ยง2: `ยซ{A}ยป und ยซ{B}ยป`
#. ยง3: `trivial`
#. ยง4: `constructor`
#. ยง5: `destructor`
#. ยง6: `constructor`
#: Game.Levels.Logo.L10_And
msgid "Given assumptions that ยง0 and ยง1 are true, prove that ยง2 is true.\n"
"You cannot just try ยง3. Use ยง4 to divide goal into two. Remind that the tactic\n"
"is not called ยง5. Try ยง6"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `S`
#. ยง3: `A B : Set S`
#. ยง4: `A โฉ B`
#. ยง5: `โฉ`
#. ยง6: `\\inter`
#: Game.Doc.Definition
msgid "For two subsets ยง0 and ยง1 of ยง2 (i.e. ยง3), ยง4 is their intersection.\n"
"ยง5 is written as ยง6."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L10_Iff
msgid "ยง0 Conclusion Implis L10"
msgstr ""

#. ยง0: `obtain h | h | h  := ยซ{h}ยป`
#: Game.Levels.Babylon.L04_sum_subset
msgid "Divide ยซ{h}ยป into three by ยง0"
msgstr ""

#. ยง0: `A โจ B`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `A โจ B`
#. ยง4: `left`
#. ยง5: `right`
#. ยง6: `A โจ B`
#. ยง7: `A`
#. ยง8: `B`
#. ยง9: `A`
#. ยง10: `B`
#. ยง11: ```
#. obtain h | h := h
#. ```
#: Game.Doc.Definition
msgid "ยง0 (โorโ) is the statement that at least one of the statements ยง1, ยง2 is true.\n"
"\n"
"## ยง3 as proof goal\n"
"\n"
"You can use the tactics ยง4 or ยง5 to decide\n"
"which statement you want to prove.\n"
"\n"
"## ยง6 as an assumption\n"
"\n"
"Since you do not know which of the statements ยง7 or ยง8 you can assume,\n"
"you may have to show the proof goal twice:\n"
"once under the assumption ยง9 and once under the assumption ยง10.\n"
"To do this, use the tactic\n"
"ยง11"
msgstr ""

#. ยง0: `f`
#. ยง1: ```
#. โ b, โ a, f a = b
#. ```
#: Game.Doc.Definition
msgid "A mapping ยง0 is surjectiv, if:\n"
"\n"
"ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Luna.L09_lt_trichotomy2
msgid "ยง0 Conclusion Luna L09"
msgstr ""

#. ยง0: $( \\sum_{i\\in I} 1)$
#. ยง1: $I$
#. ยง2: $I$
#. ยง3: `simp`
#: Game.Levels.Babylon.L01_Sum_Simp_Card
msgid "Explain goal as ยง0 being equal to the number of elements in ยง1\n"
"i.e. the cardinality of ยง2. Try ยง3"
msgstr ""

#. ยง0: `ring`
#: Game.Levels.Saturn.L02_Ring_add_pow_two
msgid "Conclusion Saturn L02: ยง0 could have been used as well"
msgstr ""

#. ยง0: `b`
#. ยง1: `b`
#. ยง2: `eq_empty_iff_forall_not_mem`
#. ยง3: `unfold Ne`
#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "Explain that ยง0 is not empty iff ยง1 has pre-image. Remind of ยง2 that can be used after ยง3"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L13_Or
msgid "ยง0 Intro Logo L13"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "ยง0 got to think about it..."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L04_Omega2
msgid "ยง0 Intro Luna L04"
msgstr ""

#. ยง0: `obtain`
#. ยง1: `x < y`
#. ยง2: `x = y`
#. ยง3: `x > y`
#. ยง4: ```
#. obtain h | h | h := lt_trichotomy x y
#. ```
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "Wird typischerweise mit ยง0 verwendet, um in einem Beweis die drei Fรคlle ยง1, ยง2 und ยง3 zu unterscheiden:\n"
"\n"
"ยง4"
msgstr ""

#. ยง0: `โ`
#. ยง1: `โ`
#. ยง2: `Even n`
#. ยง3: `n`
#. ยง4: `Odd n`
#. ยง5: `n`
#. ยง6: `rw`
#. ยง7: `ring`
#. ยง8: `+, -, *, ^`
#. ยง9: `decide`
#. ยง10: `unfold`
#. ยง11: `use`
#. ยง12: `โ`
#. ยง13: `choose x hx using h`
#. ยง14: `โ`
#. ยง15: `intro`
#. ยง16: `โ`
#. ยง17: `push_neg`
#. ยง18: `ยฌโ`
#. ยง19: `ยฌโ`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Conclusion Quantus L10: Overview of planet contents: ยง0, ยง1, ยง2 (ยง3 is even),\n"
"ยง4 (ยง5 is odd), ยง6, ยง7 (solves equations containing ยง8), ยง9,\n"
"ยง10, ยง11 (to tackle ยง12 in goal), ยง13 (to disect ยง14 in assumptions),\n"
"ยง15 (to tackle ยง16 in goal) and ยง17 (for ยง18 and ยง19 in goal)."
msgstr ""

#. ยง0: `n : โ`
#. ยง1: `Prime n`
#. ยง2: `n`
#. ยง3: `prime_def`
#: Game.Doc.Definition
msgid "For ยง0, ยง1 means that ยง2 is a prime number.\n"
"To work with this definition, it is often helpful to rewrite it using the lemma\n"
"ยง3."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus
msgid "ยง0 Intro Quantus"
msgstr ""

#. ยง0: `rw [sum_insert]`
#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid "And yet again ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L12_insert
msgid "ยง0 Intro Piazza L12"
msgstr ""

#. ยง0: `by_contra`
#: Game.Levels.Spinoza.L05_Contrapose
msgid "Intro Spinoza L05. prove without ยง0"
msgstr ""

#. ยง0: `ring`
#. ยง1: `+, -, *, ^`
#: Game.Doc.Tactic
msgid "The ยง0 tactic proves equations with the operations ยง1 in semirings,\n"
"in particular in โ, โค, โ, โ, โฆ   It works particularly well in commutative rings."
msgstr ""

#. ยง0: `f : A โ A`
#. ยง1: `a : A`
#. ยง2: `IsFixedPt f a`
#. ยง3: `f a = a`
#. ยง4: `unfold IsFixedPt`
#: Game.Doc.Definition
msgid "For a self-mapping ยง0 and an element ยง1, ยง2 is the expression ยง3.\n"
"Look up definition with ยง4."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L06_not_even_iff_odd
msgid "ยง0 Intro Quantus L06"
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Piazza.L02_Simp
msgid "The simplest method here is ยง0"
msgstr ""

#. ยง0: `rfl`
#. ยง1: `X = X`
#. ยง2: `rfl`
#. ยง3: `A = B`
#. ยง4: `A`
#. ยง5: `B`
#: Game.Doc.Tactic
msgid "The tactic ยง0 proves ยง1.  More precisely, ยง2 closes every proof target of the form ยง3,\n"
"where ยง4 and ยง5 are identical in definition."
msgstr ""

#. ยง0: `Icc a b`
#. ยง1: $[a,b]$
#: Game.Doc.Definition
msgid "ยง0 is the closed interval ยง1."
msgstr ""

#. ยง0: `Nonempty T`
#. ยง1: `T`
#. ยง2: `T`
#. ยง3: `h : Nonempty T`
#. ยง4: `t : T`
#. ยง5: `obtain โจtโฉ := h`
#. ยง6: `t : T`
#. ยง7: `Nonempty T`
#. ยง8: `use t`
#. ยง9: `A : Set T`
#. ยง10: `Nonemty A`
#. ยง11: `โ x, x โ A`
#. ยง12: `unfold Nonempty`
#: Game.Doc.Definition
msgid "ยง0 means that an element in ยง1 (โof type ยง2โ) exists.\n"
"If ยง3 is given as an assumption, we obtain an element ยง4 with ยง5.\n"
"Conversely, if we already have an element ยง6 given or constructed,\n"
"we can prove ยง7 with ยง8.\n"
"\n"
"Similarly, for a subset ยง9, the statement ยง10 is defined as ยง11.\n"
"In this case, you can easily check this with ยง12."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "ยง0 Conclusion Saturn L01"
msgstr ""

#. ยง0: `tauto`
#. ยง1: `rfl`
#: Game.Levels.Piazza.L08_subset_iff
msgid "Try ยง0 or directly ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "ยง0 Intro Quantus L02"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Robotswana.L03
msgid "ยง0 Seems to be correct"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L02_Revert
msgid "ยง0 Conclusion Implis L02"
msgstr ""

#. ยง0: `ยฌ`
#. ยง1: `Prop`
#: Game.Levels.Cantor.L05_IsFixedPt_not
msgid "The second ยง0 means the same as the first: logical negation. Interpret it as the self\n"
"mapping of the set ยง1 of all possible satements."
msgstr ""

#. ยง0: `obtain โจhโ, hโ , hโโฉ := h`
#: Game.Levels.Logo.L11_And
msgid "Conclusion Logo L11: Could have been written as ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "ยง0 Conclusion Mono L11"
msgstr ""

#. ยง0: `not_odd_iff_even`
#: Game.Levels.Spinoza.L05_Contrapose
msgid "ยง0 might help here"
msgstr ""

#. ยง0: `apply sum_subset`
#: Game.Levels.Babylon.L04_sum_subset
msgid "Now try out ยง0"
msgstr ""

#. ยง0: `intro`
#. ยง1: `SECOND`
#: Game.Levels.Piazza.L10
msgid "Try ยง0 again ยง1"
msgstr ""

#. ยง0: `apply matrix_eq_sum_single`
#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Try to use ยง0"
msgstr ""

#. ยง0: `by_cases`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Employ ยง0"
msgstr ""

#. ยง0: `succ : โ โ โ`
#. ยง1: `n โฆ n + 1`
#: Game.Doc.Definition
msgid "ยง0 is the mapping ยง1.\n"
"It therefore maps a natural number to its successor."
msgstr ""

#. ยง0: ```
#. def Even (n : โ) : Prop := โ r, n = r + r
#. ```
#. ยง1: ```
#. def Odd (n : โ) : Prop := โ r, n = 2 * r + 1
#. ```
#: Game.Levels.Quantus.L04_Exists
msgid "Intro Quantus L04: Show defintion\n"
"ยง0\n"
"\n"
"and\n"
"\n"
"ยง1"
msgstr ""

#. ยง0: $ยซ{i}ยป=0$
#. ยง1: $ยซ{i}ยป=1$
#. ยง2: $ยซ{i}ยป=2$
#. ยง3: `have`
#: Game.Levels.Babylon.L04_sum_subset
msgid "Assumptions have to entail ยง0 or ยง1 or ยง2. Try ยง3"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L02_Card2
msgid "ยง0 Intro Babylon L02"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Cantor.L02_CantorPowerset
msgid "ยง0 Cantor expresses happiness"
msgstr ""

#. ยง0: `sum_subset`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Now ยง0 can be applied"
msgstr ""

#: Game.Levels.Euklid
msgid "Euklid"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L02_Rfl
msgid "ยง0 Conclusion Logo L02"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "ยง0 Intro Samarkand L06"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "ยง0 Ritha gives sighns to try omega"
msgstr ""

#. ยง0: `Odd.neg_pow`
#: Game.Levels.Quantus.L05_neg_pow
msgid "Try continue with ยง0"
msgstr ""

#. ยง0: `A โ B`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `โ`
#. ยง4: `A โ B`
#. ยง5: `constructor`
#. ยง6: `A โ B`
#. ยง7: `B โ A`
#. ยง8: `โ`
#. ยง9: `h : A โ B`
#. ยง10: `obtain โจhโ, hโโฉ := h`
#. ยง11: `hโ : A โ B`
#. ยง12: `hโ : B โ A`
#. ยง13: `h.mp`
#. ยง14: `h.mpr`
#. ยง15: `mp`
#: Game.Doc.Definition
msgid "ยง0 means that statements ยง1 and ยง2 are logically equivalent (โif and only ifโ).\n"
"\n"
"## ยง3 as proof target\n"
"\n"
"To show ยง4, you can, for example, call ยง5\n"
"and then prove ยง6 and ยง7 separately.\n"
"\n"
"## ยง8 as an assumption\n"
"\n"
"You can break down an assumption of the form ยง9 using ยง10 into its two components\n"
"ยง11 and ยง12.\n"
"However, you can also refer directly to these components with ยง13 and ยง14.\n"
"(The abbreviation ยง15 stands for โmodus ponensโ.)"
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `Fin 2`
#. ยง3: `โ`
#. ยง4: `Fin 2`
#. ยง5: $\\{0,1\\}$
#. ยง6: `X 0`
#. ยง7: `X 1`
#: Game.Levels.Saturn.L03_mul_comm
msgid "Explain ยง0: ยง1 is a 'multivariate polynome' with variables indexed by ยง2 and\n"
"coefficients in ยง3.\n"
"Explain ยง4 as the set of elements ยง5 that lead to the variables ยง6 and ยง7"
msgstr ""

#. ยง0: `a`
#. ยง1: `a`
#. ยง2: ```
#. โ b : B, โ a : A,
#. ( f a = b   โจ   ยฌ โ a' : A , f a' = b )
#. ```
#: Game.Levels.Mono.L10_Auxiliary
msgid "Be careful with interpreting goal as 'there is ยง0 or there is no ยง1'. Rewrite goal as ยง2"
msgstr ""

#. ยง0: `โง`
#. ยง1: `constructor`
#: Game.Levels.Logo.L14_Summary
msgid "Approach ยง0 with ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L03_Let
msgid "ยง0 Intro Vieta L03"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L08_Omega3
msgid "ยง0 Intro Luna L08"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L10_And
msgid "ยง0 Intro Logo L10"
msgstr ""

#: Game.Levels.Ciao
msgid "Ciao"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Saturn.L03_mul_comm
msgid "ยง0 Conclusion Saturn L03"
msgstr ""

#. ยง0: `A B : Set T`
#. ยง1: `A โ B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `rw [subset_iff]`
#. ยง5: `A โ B`
#. ยง6: `โ x, x โ A โ x โ B`
#. ยง7: `A โ B`
#. ยง8: `intro a ha`
#. ยง9: `a`
#. ยง10: `ha : a โ A`
#. ยง11: `a โ B`
#. ยง12: `h : A โ B`
#. ยง13: `a`
#. ยง14: `ha : a โ A`
#. ยง15: `have hb := h ha`
#. ยง16: `hb : a โ B`
#. ยง17: `โ`
#. ยง18: `\\subset`
#: Game.Doc.Definition
msgid "For ยง0, ยง1 means that ยง2 is contained in ยง3.\n"
"\n"
"With ยง4, you can rewrite ยง5 as ยง6.\n"
"\n"
"If ยง7 is the proof goal, you can also directly use ยง8\n"
"to select an element ยง9 with ยง10 (and then show ยง11).\n"
"\n"
"If ยง12 is an assumption and an element ยง13 with ยง14 is given,\n"
"you can use ยง15 to obtain the statement ยง16.\n"
"\n"
"You write ยง17 as ยง18."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L09_Contradiction
msgid "ยง0 Intro Logo L09"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Babylon.L04_sum_subset
msgid "ยง0 Show that term in sum is zero for first three indexes"
msgstr ""

#. ยง0: `โx, P x`
#. ยง1: `use n`
#. ยง2: `P x`
#: Game.Doc.Tactic
msgid "If the proof target is of the form ยง0, you can use ยง1 to specify a concrete element\n"
"for which you want to prove ยง2."
msgstr ""

#. ยง0: `by_cases hโ : ยซ{a}ยป โ ยซ{f}ยป ยซ{a}ยป`
#: Game.Levels.Cantor.L01_CantorPowerset
msgid "That would be ยง0"
msgstr ""

#. ยง0: `Surjective f`
#. ยง1: `โ y, (โ x, f x = y)`
#. ยง2: `unfold Surjective`
#: Game.Levels.Epo.L01_Surjective
msgid "Confirm that ยง0 is defined as ยง1 via ยง2"
msgstr ""

#. ยง0: `A B : Prop`
#. ยง1: `A โ B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `X Y : Type`
#. ยง5: `X โ Y`
#. ยง6: `X`
#. ยง7: `Y`
#. ยง8: `A โ B`
#. ยง9: `intro h`
#. ยง10: `h : A`
#. ยง11: `B`
#. ยง12: `apply`
#: Game.Doc.Definition
msgid "For ยง0, ยง1 is the implication โยง2 implies ยง3.โ\n"
"For other ยง4, ยง5 is a mapping that maps values from ยง6 to ยง7.\n"
"\n"
"## Implication as proof goal\n"
"\n"
"If your proof goal is an implication ยง8, with ยง9 you can assume ยง10,\n"
"and then you must prove ยง11.\n"
"\n"
"## Implication as assumption\n"
"\n"
"To use an implication among your assumptions, use the tactic ยง12."
msgstr ""

#. ยง0: $$ \\sum_{i=0}^{n} (i^3 - 3 i^2 + 2 i)  = \\sum_{i=3}^{n} (i^3 - 3 i^2 + 2i) $$
#. ยง1: $0$
#. ยง2: $i$
#. ยง3: `sum_subset`
#. ยง4: `Iโ โ Iโ`
#. ยง5: `Iโ`
#. ยง6: `Iโ`
#. ยง7: `Iโ`
#. ยง8: `Iโ`
#: Game.Levels.Babylon.L04_sum_subset
msgid "Remind goal ยง0 with ยง1 for the value in the sum for fist three ยง2. Try ยง3: If ยง4 and term is disappearing for all elements in ยง5 not in ยง6, then the sum over ยง7 equals sum over ยง8"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L04_Apply
msgid "ยง0 Intro Implis L04"
msgstr ""

#. ยง0: $$ \\sum_{i \\in I} \\left( (-1)^i + 1 \\right) $$
#. ยง1: $I$
#. ยง2: $i$
#. ยง3: $i$
#. ยง4: $2$
#. ยง5: `trans`
#. ยง6: ``` โ i โ { i โ I | Even i}, ((-1)^i + 1) ```
#. ยง7: ``` โ i โ { i โ I | Even i}, 2 ```
#: Game.Levels.Babylon.L05_sum_subset2
msgid "Goal is to show that ยง0 is equal to twice the amount of\n"
"even numbers in ยง1. Note that sum disappears for uneven ยง2. For even ยง3 the sum is ยง4. Use ยง5 to\n"
"constrain sum to ยง6 and then use ยง7\n"
"as intermediate step."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L04_Exists
msgid "ยง0 Conclusion Quantus L04"
msgstr ""

#. ยง0: $A \\Rightarrow I$
#. ยง1: `intro`
#: Game.Levels.Implis.L05_Apply
msgid "Find an implication path ยง0. Try ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L08_Contradiction
msgid "ยง0 Conclusion Logo L08"
msgstr ""

#. ยง0: `fixedPoints f`
#. ยง1: `unfold`
#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid "See if ยง0 is the set of all fix points by using ยง1"
msgstr ""

#. ยง0: `even_square`
#. ยง1: `Odd (n^2) โ Odd n`
#. ยง2: `Even n โ Even (n^2)`
#. ยง3: `โ`
#. ยง4: `revert`
#. ยง5: `revert ยซ{h}ยป`
#. ยง6: `ยซ{h}ยป`
#: Game.Levels.Spinoza.L05_Contrapose
msgid "Refer back to ยง0 as ยง1 is equivalent in contrapoition to ยง2.\n"
"Explain that lack of  ยง3 can be dealt with ยง4 via ยง5 for ยง6."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L02_ImageMap
msgid "ยง0 Conclusions Samarkand L02"
msgstr ""

#. ยง0: `diag ยซ{aโ}ยป`
#. ยง1: `diag ยซ{aโ}ยป`
#. ยง2: `Fin (n + 1) โ A`
#. ยง3: `Fin (n + 1)`
#. ยง4: `congr_fun`
#: Game.Levels.Mono.L04_Diagonal
msgid "Remind that 'tuples' ยง0 and ยง1 are two mappings ยง2.\n"
"Evaluate them on elements from ยง3. Try ยง4"
msgstr ""

#. ยง0: `let`
#. ยง1: `let x : โ := 5 ^ 2`
#. ยง2: `let x := โฆ`
#. ยง3: `x`
#. ยง4: `simp only [x]`
#: Game.Doc.Tactic
msgid "The ยง0 tactic introduces a temporary definition, for example\n"
"ยง1.\n"
"\n"
"Once ยง2 defines a ยง3, you can use the definition later with ยง4."
msgstr ""

#. ยง0: `ext`
#. ยง1: `CONC`
#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "Conclusion Piazza L06: Explain that ยง0 means extensionality ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Spinoza.L01_Have
msgid "ยง0 Conclusion Spinoza L01"
msgstr ""

#. ยง0: `decide`
#. ยง1: `decide`
#: Game.Levels.Logo.L05_True
msgid "Conclusion Logo L05: ยง0 cannot be used every time. ยง1 works only in special cases"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L02_ImageMap
msgid "ยง0 Intro Samarkand L02"
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `obtain`
#: Game.Levels.Mono.L10_Auxiliary
msgid "Known that there exists some element in ยง0. Try ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Saturn
msgid "ยง0 Intro Saturn"
msgstr ""

#. ยง0: `1`
#. ยง1: `1 ยซ{i}ยป j`
#. ยง2: `j โ ยซ{i}ยป`
#. ยง3: `j = ยซ{i}ยป`
#. ยง4: `have h : {ยซ{i}ยป} โ univ`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Explain ยง0 and values of ยง1 for all ยง2 i.e. ยง3. Try ยง4"
msgstr ""

#. ยง0: `ยซ{a}ยป โ ยซ{f}ยป ยซ{a}ยป`
#: Game.Levels.Cantor.L01_CantorPowerset
msgid "Try proof by cases for ยง0"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `range f`
#. ยง2: `f`
#. ยง3: ```
#. range f = {f a | a : A}
#.         = {  b | โ a, f a = b}
#. ```
#. ยง4: `f '' univ`
#. ยง5: `mem_range`
#. ยง6: ```
#. x โ range f โ โ a, f a = b
#. ```
#: Game.Doc.Definition
msgid "For a mapping ยง0, ยง1 is the full image set of ยง2:\n"
"ยง3\n"
"Is a diffierent notation for ยง4.\n"
"ยง5 is useful to work with it:\n"
"ยง6"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L10_Characterize
msgid "ยง0 Conclusion Robotswana L10"
msgstr ""

#. ยง0: `(ยซ{A}ยป โง ยซ{B}ยป) โจ ยซ{A}ยป`
#. ยง1: `ยซ{A}ยป`
#: Game.Levels.Logo.L13_Or
msgid "Show goal via ยง0 i.e. assume ยง1 is true"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Prado.L07_dvd_mul
msgid "ยง0 conclusion Prado L07"
msgstr ""

#: Game.Levels.Cantor
msgid "Cantor"
msgstr ""

#: Game.Levels.Mono
msgid "Mono"
msgstr ""

#. ยง0: `ยฌ .`
#: Game.Levels.Cantor.L10_CantorPowerset
msgid "Does ยง0 have no fixed points?"
msgstr ""

#. ยง0: `(h : A โง B)`
#. ยง1: `h.left`
#. ยง2: `h.right`
#. ยง3: `(h : A โ B)`
#. ยง4: `h.mp`
#. ยง5: `h.mpr`
#. ยง6: `h.mp`
#. ยง7: `A โ B`
#. ยง8: `mp`
#. ยง9: `mp`
#. ยง10: `mpr`
#: Game.Levels.Implis.L06_Iff
msgid "Conclusion Implis L06: Explain that analogous to ยง0 with ยง1 and ยง2,\n"
"ยง3 has ยง4 and ยง5. ยง6 can be understood as ยง7. It is ยง8 as ยง9\n"
"stands for Modens Ponens. The 'r' in ยง10 stands for 'reverse'."
msgstr ""

#. ยง0: `IN_HINT 1`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "ยง0 Use linearity"
msgstr ""

#. ยง0: `ring`
#. ยง1: `rw`
#. ยง2: `n`
#. ยง3: `ยซ{s}ยป + ยซ{s}ยป`
#. ยง4: `ring`
#: Game.Levels.Quantus.L04_Exists
msgid "before using ยง0, use ยง1 to replace ยง2 by ยง3, because\n"
"ยง4 does not know otherwise."
msgstr ""

#. ยง0: `suffices g : ยฌ A`
#: Game.Levels.Spinoza.L04_ByContra
msgid "ยง0 would be a good option"
msgstr ""

#. ยง0: `image_preimage_subset`
#. ยง1: ```
#. f '' (f โปยน' T) โ T
#. ```
#. ยง2: `f`
#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "Remind ยง0 i.e.\n"
"ยง1\n"
"and additional assumption that ยง2 surjectiv"
msgstr ""

#. ยง0: `โ`
#. ยง1: `use โฆ`
#. ยง2: `let f : โค โ โค := fun โฆ`
#. ยง3: `โฆ`
#. ยง4: `\\maps`
#. ยง5: `\\mapsto`
#. ยง6: `=>`
#: Game.Levels.Vieta.L03_Let
msgid "Tackle  ยง0 either with ยง1 or define mapping ยง2 as before.\n"
"Remind that ยง3 is either ยง4 or ยง5 ro can be replyced by ยง6"
msgstr ""

#. ยง0: `intro`
#: Game.Levels.Piazza.L10
msgid "Start with ยง0"
msgstr ""

#. ยง0: `Bijective f`
#. ยง1: `Injective f โง Surjective f`
#: Game.Levels.Iso.L01_Bijective
msgid "Remind that ยง0 is defined as ยง1"
msgstr ""

#. ยง0: `by_cases h : 0 โค ยซ{x}ยป`
#. ยง1: `0 โค ยซ{x}ยป`
#. ยง2: `0 > ยซ{x}ยป`
#. ยง3: `0 โค ยซ{x}ยป`
#. ยง4: `ยฌ(0 โค ยซ{x}ยป)`
#. ยง5: `not_le`
#. ยง6: `ยฌ(0 โค ยซ{x}ยป)`
#. ยง7: `0 > ยซ{x}ยป`
#: Game.Levels.Vieta.L06_Piecewise
msgid "Try ยง0 for resulting cases ยง1 and ยง2 i.e. ยง3 and ยง4.\n"
"Could switch via ยง5 between ยง6 and ยง7"
msgstr ""

#: Game.Levels.Implis
msgid "Implis"
msgstr ""

#. ยง0: `h : X = Y`
#. ยง1: `h : X โ Y`
#. ยง2: `rw [h]`
#. ยง3: `X`
#. ยง4: `Y`
#. ยง5: `rw [โh]`
#. ยง6: `h`
#. ยง7: `Y`
#. ยง8: `X`
#. ยง9: `rw [h, g, โf]`
#. ยง10: `h`
#. ยง11: `g`
#. ยง12: `f`
#. ยง13: `rw [h] at hโ`
#. ยง14: `hโ`
#. ยง15: `nth_rw`
#. ยง16: `h`
#. ยง17: `n`
#. ยง18: ```
#.    h : โ n, 2*n = f n
#.    ```
#. ยง19: ```
#.    h (n : โ) : 2*n = f n
#.    ```
#. ยง20: `rw [h]`
#. ยง21: `nth_rw k [h]`
#. ยง22: `k`
#. ยง23: `2*a + 2*b > 2*a`
#. ยง24: `rw [h]`
#. ยง25: `f a + 2*b > f a`
#. ยง26: `nth_rw 2 [h]`
#. ยง27: `2*a + f b > 2*a`
#: Game.Doc.Tactic
msgid "If you have given an equation ยง0 or an equivalence ยง1 as an assumption or lemma,\n"
"you can use ยง2 to replace all occurrences of ยง3 in the proof target with ยง4.\n"
"\n"
"## Variants\n"
"\n"
"* ยง5 applies ยง6 backwards, i.e., replaces all ยง7 with ยง8.\n"
"* ยง9 applies ยง10, ยง11, and (backwards) ยง12.\n"
"* ยง13 performs the replacements in the assumption ยง14, not in the proof target\n"
"* ยง15: If ยง16 has arguments, e.g., ยง17 in\n"
"ยง18\n"
"   or in\n"
"ยง19\n"
"   ยง20 searches the proof target from left to right for a matching expression,\n"
"   and then replaces *all* occurrences of *the first* expression that the tactic finds.\n"
"   With ยง21, you can replace all occurrences of the ยง22th expression instead.\n"
"\n"
"  | before    | tactic       | after        |\n"
"  |:----------------- |:------------- - |:----------------- |\n"
"  | ยง23 | ยง24       | ยง25 |\n"
"  |                   | ยง26 | ยง27 |"
msgstr ""

#. ยง0: `ยซ{A}ยป : Prop`
#. ยง1: `ยซ{A}ยป`
#. ยง2: `ยซ{hA}ยป`
#. ยง3: `ยซ{A}ยป`
#. ยง4: `ยซ{A}ยป`
#: Game.Levels.Logo.L04_Assumption
msgid "Explain that ยง0 means that ยง1 is some statement.\n"
"ยง2 is the name of the assumption that ยง3 is true. Try to solve ยง4 using said assumption"
msgstr ""

#. ยง0: `True`
#. ยง1: `decide`
#: Game.Levels.Logo.L05_True
msgid "Explain that ยง0 is a special statement that is always true. Try ยง1"
msgstr ""

#. ยง0: `Injective f`
#: Game.Levels.Mono.L06_StrictMono
msgid "Introduce all varaibles and assumptions from ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L07_Forall
msgid "ยง0 Conclusion Quantus L07"
msgstr ""

#. ยง0: `0 - 1`
#. ยง1: `0`
#. ยง2: `n โฆ n - 1`
#. ยง3: `n โฆ n - 1`
#. ยง4: `0`
#. ยง5: `0`
#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "Conclusion Mono L07: Explain that here ยง0 is ยง1, as there is mapping ยง2 defined only on natural numbers.\n"
"In Lean ยง3 is such a mapping and there for it maps ยง4 onto ยง5."
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "Use ยง0 again"
msgstr ""

#. ยง0: `trans`
#. ยง1: `trans โ j : Fin ยซ{n}ยป, f (E i i)`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Try ยง0 several times. Start with ยง1"
msgstr ""

#. ยง0: $\\sum_{i=-n}^ยซ{n}ยป i = 0$
#. ยง1: `insert_Icc_eq_Icc_add_one_right`
#. ยง2: `insert_Icc_eq_Icc_sub_one_left`
#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid "Prove ยง0 by using ยง1, ยง2"
msgstr ""

#. ยง0: `by_cases`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Look at ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L01_NonemptyUse
msgid "ยง0 Intro Quantus L01"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "ยง0 Intro Samarkand L04"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid "ยง0Conclusion Cantor L04"
msgstr ""

#. ยง0: `A : Set T`
#. ยง1: `A`
#. ยง2: `T`
#. ยง3: `A`
#. ยง4: `T`
#: Game.Doc.Definition
msgid "ยง0 means that ยง1 is a subset of ยง2\n"
"(or, more precisely, that ยง3 is a set consisting of elements of type ยง4)."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo
msgid "ยง0 Intro Logo"
msgstr ""

#. ยง0: `Injective f`
#. ยง1: `a โ b โ f a โ f b`
#. ยง2: `Injective.ne_iff`
#. ยง3: `f a โ f b โ a โ b`
#: Game.Levels.Mono.L02_InjectiveNeIff
msgid "Use short cut by instead of the definition of ยง0 using equivalent description\n"
"ยง1. In Leanic it is part of ยง2. For injective mapping it holds\n"
"that ยง3"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "ยง0 Intro Samarkand L08"
msgstr ""

#. ยง0: `constructor`
#. ยง1: `unfold Surjective`
#. ยง2: `push_neg`
#: Game.Levels.Epo.L02_CurrySurjective
msgid "Try ยง0 | ยง1, ยง2"
msgstr ""

#. ยง0: `ext`
#. ยง1: `Subset.antisymm_iff`
#: Game.Levels.Cantor.L07_idempotent
msgid "Start with ยง0 or ยง1"
msgstr ""

#. ยง0: `ยซ{A}ยป ยซ{B}ยป ยซ{C}ยป : Prop`
#. ยง1: `ยซ{A}ยป`
#. ยง2: `ยซ{B}ยป`
#. ยง3: `ยซ{C}ยป`
#. ยง4: `โ`
#. ยง5: $โ$
#. ยง6: `tauto`
#: Game.Levels.Logo.L01_Tauto
msgid "Explain that ยง0 introduces statements ยง1, ยง2 und ยง3 as\n"
"propositions. The symbol ยง4 is equivalent to the implication symbol ยง5. Try ยง6."
msgstr ""

#. ยง0: `push_neg`
#. ยง1: `DOC2`
#: Game.Levels.Quantus.L09_PushNeg
msgid "Instead of this theorem you can use ยง0. ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Spinoza.L06_Summary
msgid "ยง0 Intro Spinoza L06"
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid "Again try ยง0"
msgstr ""

#. ยง0: `rw`
#. ยง1: `apply`
#: Game.Levels.Implis.L11_Iff
msgid "Intro Implis L11: Prove without using ยง0 or ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "ยง0 Conclusion Euklid L03"
msgstr ""

#. ยง0: `โ`
#: Game.Levels.Implis.L14_Summary
msgid "Remind that ยง0 in this case is equivalence"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L06_Iff
msgid "ยง0 Intro Implis L06"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Spinoza.L04_ByContra
msgid "ยง0 Use proof by contradiction"
msgstr ""

#. ยง0: `prod_insert`
#: Game.Levels.Euklid.L02_prod_insert
msgid "Use ยง0 to actually extract the factot"
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Babylon.L02_Card2
msgid "Again try using ยง0"
msgstr ""

#. ยง0: `ยซ{a}ยป`
#. ยง1: `insert_erase`
#: Game.Levels.Euklid.L02_prod_insert
msgid "Seperate factor ยง0 out of product by using ยง1"
msgstr ""

#. ยง0: `DOC`
#: Game.Levels.Mono.L05_StrictMono
msgid "ยง0 Every strictly monotonic mapping (between suitable domains and ranges) is injective."
msgstr ""

#. ยง0: `ยซ{n}ยป : โ`
#. ยง1: `ยซ{n}ยป`
#. ยง2: `ยซ{n}ยป โ โ`
#. ยง3: `ยซ{hโ}ยป`
#. ยง4: `ยซ{hโ}ยป`
#. ยง5: `ยซ{hโ}ยป`
#. ยง6: `n < 10`
#. ยง7: `1 < n`
#. ยง8: `n โ 5`
#. ยง9: `1 < n`
#. ยง10: `assumption`
#: Game.Levels.Logo.L03_Assumption
msgid "Explain that ยง0 means ยง1 is a natural number. The notation ยง2 is not used.\n"
"ยง3, ยง4, ยง5 are names for the respective assumptions ยง6, ยง7 und ยง8.\n"
"The proof goal is ยง9. Try ยง10"
msgstr ""

#. ยง0: `tauto`
#. ยง1: `simp`
#: Game.Levels.Implis.L13_Rw
msgid "Statt dieser Aussage kรถnnen oft auch die Taktiken ยง0 oder ยง1 verwendet werden."
msgstr ""

#. ยง0: `DOC`
#: Game.Levels.Quantus.L04_Exists
msgid "ยง0 The square of an even number is also even."
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Implis.L03_Apply
msgid "ยง0 This should seem obvious now"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "ยง0 Intro Luna L06"
msgstr ""

#. ยง0: `IsFixedPt`
#. ยง1: `IsFixedPt f x`
#. ยง2: `f x = x`
#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "ยง0 means 'is fixed point'. ยง1 equates to ยง2"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid "ยง0 Intro Prado L05"
msgstr ""

#. ยง0: `simp`
#. ยง1: `simp [eq_univ_iff_forall]`
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "Try via ยง0 or directly ยง1"
msgstr ""

#: Game.Levels.Saturn
msgid "Saturn"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "ยง0 Intro Samarkand L07"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#. ยง0: `apply`
#. ยง1: `hAB : A โ B`
#. ยง2: `โข B`
#. ยง3: `apply hAB`
#. ยง4: `โข A`
#. ยง5: `h : A `
#. ยง6: `apply hAB at h`
#. ยง7: `h : B`
#. ยง8: `hAB`
#: Game.Doc.Tactic
msgid "With ยง0, you apply an implication ยง1:\n"
"\n"
"| before | tactic           | after |\n"
"|:------------ |:---------------- |:-------- |\n"
"| ยง2        | ยง3      | ยง4    |\n"
"| ยง5     | ยง6 | ยง7  |\n"
"\n"
"In both cases, the implication ยง8 can either be\n"
"given as an assumption or be an already known lemma."
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `ยซ{h}ยป`
#. ยง2: `False`
#. ยง3: `False`
#. ยง4: `False`
#. ยง5: `ยซ{A}ยป`
#. ยง6: `True`
#. ยง7: `False`
#. ยง8: `contradiction`
#: Game.Levels.Logo.L07_Contradiction
msgid "Explain that ยง0 is a statement and ยง1 is the assumption that ยง2 is true.\n"
"Remind that ยง3 is always false. Explain that assumption ยง4 is false. As any statement\n"
"ยง5 can be proven from a false assumption. Point out contradiction between ยง6 and ยง7\n"
"by applying ยง8."
msgstr ""

#. ยง0: `I : Finset T`
#. ยง1: `โ i โ I, f i`
#. ยง2: $\\sum_{i\\in I} f(i)$
#. ยง3: `\\sum`
#: Game.Doc.Definition
msgid "For a finite index set ยง0, ยง1 is Leanic notation for the sum\n"
"ยง2.  You write the summation sign as ยง3."
msgstr ""

#. ยง0: `Injective`
#. ยง1: `โ {a b : U}, f a = f b โ a = b`
#. ยง2: `unfold`
#: Game.Levels.Mono.L01_Injective
msgid "ยง0 is defined as ยง1. You can check this with ยง2"
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.Piazza.L07_antisymm_iff
msgid "Start here by trying ยง0"
msgstr ""

#. ยง0: `|x|`
#. ยง1: `x`
#. ยง2: `IsFixedPt`
#. ยง3: `unfold`
#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "ยง0 is the absolute value of the real number ยง1. The meaning of ยง2\n"
"can be found out by using ยง3."
msgstr ""

#. ยง0: `IN_HINT 2`
#: Game.Levels.Iso.L02_Inverse
msgid "ยง0 Disect again"
msgstr ""

#. ยง0: `rw`
#. ยง1: `INTRO`
#: Game.Levels.Implis.L10_Iff
msgid "Intro Implis L10: ยง0 is not allowed here as well ยง1"
msgstr ""

#. ยง0: `mul_eq_mul_left_iff`
#. ยง1: ```
#. a * b = a * c โ b = c โจ a = 0
#. ```
#: Game.Levels.Prado.L09_ExistsUnique
msgid "Try ยง0 which states\n"
"ยง1\n"
""
msgstr ""

#. ยง0: `apply hAB at h`
#: Game.Levels.Implis.L03_Apply
msgid "Us the given implication by trying ยง0"
msgstr ""

#. ยง0: `use _`
#: Game.Levels.Quantus.L01_NonemptyUse
msgid "Show that there is a natural number by ยง0"
msgstr ""

#. ยง0: `โ`
#: Game.Levels.Vieta.L10_Surjective
msgid "Remind of induction as mapping goes to ยง0"
msgstr ""

#. ยง0: `ext`
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "Equality of sets demands ยง0"
msgstr ""

#. ยง0: `A โง B`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `A โง B`
#. ยง4: `constructor`
#. ยง5: `A`
#. ยง6: `B`
#. ยง7: `A โง B`
#. ยง8: `obtain โจhโ, hโโฉ := h`
#. ยง9: `h : A โง B`
#. ยง10: `hโ : A`
#. ยง11: `hโ : B`
#: Game.Doc.Definition
msgid "ยง0 (โandโ) is the statement that both ยง1 and ยง2 are true.\n"
"\n"
"## ยง3 as a proof goal\n"
"\n"
"The tactic ยง4 allows you to prove the two sub-statements ยง5 and ยง6 individually.\n"
"\n"
"## ยง7 as an assumption\n"
"\n"
"With ยง8, you break down an assumption of the form ยง9\n"
"into its components ยง10 and ยง11."
msgstr ""

#. ยง0: `A โ B`
#. ยง1: $A \\iff B$
#. ยง2: `A โ B`
#. ยง3: `โจA โ B, B โ Aโฉ`
#. ยง4: `A โง B`
#. ยง5: `constructor`
#: Game.Levels.Implis.L06_Iff
msgid "ยง0 is Leanic for ยง1. ยง2 consists of two parts. It is defined as ยง3.\n"
"It is a similar defintion to ยง4. Start with ยง5"
msgstr ""

#. ยง0: `rw`
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "Apply induction hypothesis with ยง0"
msgstr ""

#. ยง0: `apply`
#: Game.Levels.Mono.L05_StrictMono
msgid "ยง0 is what is looked for"
msgstr ""

#. ยง0: `ยฌ`
#. ยง1: `(A : Prop)`
#. ยง2: `ยฌA`
#. ยง3: `False`
#. ยง4: `decide`
#: Game.Levels.Logo.L06_Not
msgid "Explain that ยง0 is the negation sign. If ยง1 is true than ยง2 is false and\n"
"vica versa. ยง3 is the statement that is always false. Try ยง4"
msgstr ""

#. ยง0: `f`
#. ยง1: ```
#. โ a b, f a = f b โ a = b
#. ```
#: Game.Doc.Definition
msgid "A mapping ยง0 is injectiv, if:\n"
"\n"
"ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L04_Let
msgid "ยง0 Intro Vieta L04"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "ยง0 Conlsuion Samarkand L08"
msgstr ""

#. ยง0: `INTRO-2`
#: Game.Levels.Cantor.L09_CantorDiag
msgid "ยง0Intro Cantor L09 - 2"
msgstr ""

#. ยง0: `funext`
#: Game.Levels.Samarkand.L02_ImageMap
msgid "Remind ยง0"
msgstr ""

#. ยง0: `if 0 โค n then ... else ...`
#: Game.Levels.Vieta.L07_Extend
msgid "Try piecewise function with ยง0"
msgstr ""

#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid "Intro Cantor L04"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Mono.L01_Injective
msgid "ยง0 Intro Mono L01"
msgstr ""

#. ยง0: `range f`
#. ยง1: `f`
#. ยง2: ```
#. range f = {f a | a : A}
#. = {  b | โ a, f a = b}
#. ```
#. ยง3: `f '' univ`
#. ยง4: `mem_range`
#. ยง5: ```
#. x โ range f โ โ a, f a = b
#. ```
#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "Explain ยง0 w.r.t. ยง1 as\n"
"ยง2\n"
"and its equivalent ยง3. Mention ยง4:\n"
"ยง5\n"
""
msgstr ""

#: Game.Levels.Babylon
msgid "Babylon"
msgstr ""

#. ยง0: `unfold`
#. ยง1: `StrictMono`
#: Game.Levels.Mono.L05_StrictMono
msgid "Use ยง0 to look into definition of ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L09_subset_iff2
msgid "ยง0 Intro Piazza L09"
msgstr ""

#. ยง0: `ring`
#: Game.Levels.Vieta.L05_Funext
msgid "Remind: ยง0 sees through local definitions"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Saturn.L05_Ring
msgid "ยง0 Conclusion Saturn L05"
msgstr ""

#. ยง0: `matrix_eq_sum_ebasis`
#. ยง1: `1`
#. ยง2: `matrix_eq_sum_ebasis 1`
#. ยง3: `r`
#. ยง4: `w`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Try ยง0 on ยง1 with ยง2 to ยง3eยง4rite\n"
"goal."
msgstr ""

#. ยง0: `ยซ{hโ}ยป`
#. ยง1: `ยซ{i}ยป โ ยซ{x}ยป`
#. ยง2: `have hโ : ยซ{i}ยป โ ยซ{x}ยป`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Explain that ยง0 states ยง1. Try ยง2"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L11_erase
msgid "ยง0 Intro Piazza L11"
msgstr ""

#. ยง0: `suffices h : P`
#. ยง1: `P`
#. ยง2: `P`
#. ยง3: `have h : P`
#. ยง4: `P`
#: Game.Doc.Tactic
msgid "With ยง0, you introduce a proof section in which you show\n"
"that the desired proof goal follows from ยง1.\n"
"Then you prove ยง2.\n"
"\n"
"## Friends and relatives\n"
"ยง3 works the same way, except that you must first prove ยง4 before you can\n"
"continue with the main proof."
msgstr ""

#. ยง0: `ยซ{isDrinking}ยป`
#. ยง1: `p`
#. ยง2: `ยซ{isDrinking}ยป p`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Explain ยง0 and ยง1 in statement ยง2"
msgstr ""

#. ยง0: `f : A โ A`
#. ยง1: `fixedPoints f : Set A`
#. ยง2: `f `
#. ยง3: `unfold fixedPoints`
#: Game.Doc.Definition
msgid "For a mapping ยง0, ยง1 is the set of fixed points of ยง2.\n"
"Look up definition with ยง3."
msgstr ""

#. ยง0: `Even ยซ{n}ยป`
#. ยง1: `r`
#. ยง2: `r + r = ยซ{n}ยป`
#. ยง3: `unfold Even at *`
#. ยง4: `decide`
#. ยง5: `decide`
#. ยง6: `ยซ{n}ยป`
#: Game.Levels.Quantus.L04_Exists
msgid "Explain definition of ยง0 by ยง1 using ยง2. Look up definition by ยง3.\n"
"ยง4 might be considered but ยง5 does not work, because of ยง6 arbitrary."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L10_CantorPowerset
msgid "ยง0Conclusion Cantor L10"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L11_SequenceUncountable
msgid "ยง0Conclusion Cantor L11"
msgstr ""

#. ยง0: `rw [ยซ{hโ}ยป]`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Try out using ยง0"
msgstr ""

#. ยง0: `omega`
#. ยง1: `linarith`
#. ยง2: `linarith`
#. ยง3: `intro`
#: Game.Levels.Luna.L05_Linarith2
msgid "ยง0 and ยง1 alone don't help here. ยง2 will need some help. Try to untangle\n"
"the implications via ยง3"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid "ยง0 Intro Piazza L05"
msgstr ""

#. ยง0: `Surjective f`
#. ยง1: `f`
#. ยง2: `unfold Surjective`
#. ยง3: `unfold Surjective at h`
#: Game.Levels.Epo.L01_Surjective
msgid "ยง0 bedeutet naheliegenderweise, dass die Abbildung ยง1 surjektiv ist.\n"
"Mit ยง2 (bzw. ยง3) kann man leicht nachsehen, was das\n"
"in Quantorenschreibweise konkret bedeutet."
msgstr ""

#: Game.Levels.Prado
msgid "Prado"
msgstr ""

#. ยง0: `Odd n`
#. ยง1: `n : โ`
#. ยง2: ```
#. โ k : โ, n = 2 * k + 1
#. ```
#. ยง3: `unfold Odd`
#: Game.Doc.Definition
msgid "ยง0 is the statement that ยง1 is odd:\n"
"ยง2\n"
"You can easily check this with ยง3."
msgstr ""

#. ยง0: `[2025-03-28]`
#. ยง1: `Fin n`
#. ยง2: `[2025-03-18]`
#. ยง3: `[2025-02-20]`
#. ยง4: `[2025-01-25]`
#: Game
msgid "# Game Over or QED\n"
"\n"
"Are you curious about how computer-assisted reasoning feels compared to โrealโ mathematics?\n"
"Then you've come to the right place!In this game, you will learn how to work with the proof assistant Lean 4 and the proof library mathlib.\n"
"Among other things, you will prove sum formulas by induction, prove that a mapping is surjective if and only if it has a right inverse,\n"
"show that there are uncountably many sequences of natural numbers, and characterize the trace as a mapping on the space of square matrices.\n"
"The interface is somewhat simplified, but if you activate *editor mode*, it feelsalmost exactly like VSCode,\n"
"the standard IDE for Lean.\n"
"On a smartphone or tablet, it's better to stay in the default *typewriter mode* and turn off all\n"
"autocompletion/correction features on your on-screen keyboard (e.g., under โsmart typing > text recognitionโ on Samsung keyboards).\n"
"Click on the first planet *logo* in the overview to start your journey.\n"
"\n"
"## Game score\n"
"\n"
"Your game score is stored locally in your browser as *site data*.\n"
"If you delete this, you will lose your game score!\n"
"Many browsers delete *site data* and *cookies* together.\n"
"However, you can also download your game score from the menu and save it manually.\n"
"\n"
"## Rules of the game\n"
"\n"
"If you want to play seriously, you should choose *Rules: regular*.\n"
"If you just want to have a look around, choose *Rules: relaxed*\n"
"  โ then you can play any level, even if you haven't solved the previous levels yet.\n"
"\n"
"## News\n"
"ยง0 The youngest planet in the Formaloversum is called Euclid.\n"
"There are also lots of minor improvements, especially on Babylon, Cantor, and Saturn,\n"
"and in the documentation of tactics and definitions.\n"
"On Babylon, intervals are now summed over โ and โค, and no longer over ยง1.\n"
"Saturn now ends with a polynomial square sum formula.\n"
"\n"
"ยง2 The planet Saturn has split off from Quantus, Luna has grown larger, and Piazza has also been fundamentally revised.\n"
"\n"
"ยง3 The โimage planetsโ are complete:  Vieta, Mono, Epo, Iso, and Samarkand.\n"
"\n"
"ยง4 There is now a planet to say goodbye:  Ciao.\n"
"\n"
"Background information and credits can be found in the menu under *Game Info*."
msgstr ""

#. ยง0: `A : Finset T`
#. ยง1: `a : T`
#. ยง2: `erase A a`
#. ยง3: `A \\ {a}`
#. ยง4: `a`
#. ยง5: `A`
#. ยง6: `erase A a = A`
#: Game.Doc.Definition
msgid "For a finite subset ยง0 and an element ยง1,\n"
"ยง2 is another way of writing ยง3.\n"
"If ยง4 is not in ยง5 at all, then obviously ยง6."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Cantor
msgid "ยง0 Intro Cantor"
msgstr ""

#. ยง0: `decide`
#: Game.Levels.Mono.L03_NotInjective
msgid "ยง0 might suffice"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L12_ByCases
msgid "ยง0 Intro Implis L12"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Piazza.L13_insert_erase
msgid "ยง0 Conclusion Piazza L13"
msgstr ""

#. ยง0: `f`
#. ยง1: `A โ (A โ Y)`
#. ยง2: `A`
#. ยง3: `A โ  Y`
#. ยง4: `A ร A`
#. ยง5: `Y`
#. ยง6: `ยซ{f}ยป ยซ{a}ยป ยซ{a}ยป`
#. ยง7: `ยซ{f}ยป ยซ{a}ยป`
#. ยง8: `ยซ{a}ยป`
#. ยง9: `ยซ{f}ยป`
#. ยง10: `(ยซ{a}ยป,ยซ{a}ยป)`
#. ยง11: `(ยซ{a}ยป,ยซ{a}ยป)`
#. ยง12: `ยซ{ha}ยป`
#. ยง13: `f`
#. ยง14: `A โ (A โ Y)`
#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
msgid "Explain for ยง0, that ยง1 is a mapping from ยง2 to the set of mappings of ยง3,\n"
"which in turn is the same as the mapping from ยง4 to ยง5. You can interpret ยง6 either\n"
"as applying ยง7 onto ยง8 or applying ยง9 onto ยง10. The element ยง11 lays\n"
"on the diagonal. Assumption ยง12 is formulated s.t. the interpretation of ยง13 as ยง14\n"
"natural"
msgstr ""

#. ยง0: `linarith`
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "Now try ยง0!"
msgstr ""

#. ยง0: `E i j`
#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Explain statement w.r.t. ยง0 and use former results"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L04_Apply
msgid "ยง0 Conclusion Implis L04"
msgstr ""

#. ยง0: `trans`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Solve second half of ยง0 operation"
msgstr ""

#. ยง0: `obtain`
#. ยง1: `h : A โง B`
#. ยง2: `obtain โจhโ, hโโฉ := h`
#. ยง3: `hโ : A`
#. ยง4: `hโ : B`
#. ยง5: `h : A โ B`
#. ยง6: `obtain โจhโ, hโโฉ := h`
#. ยง7: `hโ : A โ B`
#. ยง8: `hโ : B โ A`
#. ยง9: `h : Nonempty X`
#. ยง10: `obtain โจxโฉ := h`
#. ยง11: `x : X`
#. ยง12: `h : โ x : X, P x`
#. ยง13: `obtain โจx, hxโฉ := h`
#. ยง14: `x : X`
#. ยง15: `hx : P x`
#. ยง16: `h : A โจ B`
#. ยง17: `obtain h \\| h := h`
#. ยง18: `h : A`
#. ยง19: `h : B`
#. ยง20: `\\<`
#. ยง21: `\\>`
#. ยง22: `โจ_, _โฉ`
#. ยง23: $(G, 0, +)$
#: Game.Doc.Tactic
msgid "The ยง0 tactic breaks down an assumption into its individual parts.\n"
"\n"
"| before       | tactic                 | after                                   |\n"
"|:------------------ |:--------------------- - |:------------------------------------------ |\n"
"| ยง1        | ยง2 | ยง3 and ยง4                      |\n"
"| ยง5        | ยง6 | ยง7 and ยง8              |\n"
"| ยง9   | ยง10      | ยง11                                    |\n"
"| ยง12 | ยง13  | ยง14 and ยง15                     |\n"
"| ยง16        | ยง17   | a target with ยง18, a target with ยง19 |\n"
"\n"
"Type the brackets in the first four examples as ยง20 or ยง21.\n"
"Here, ยง22 is the *anonymous constructor*.\n"
"You can think of it as similar to the tuple notation in\n"
"โan abelian group is a tuple ยง23 such that ...โ."
msgstr ""

#. ยง0: `rw`
#. ยง1: `if_neg`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Try ยง0 and ยง1"
msgstr ""

#. ยง0: `tauto`
#: Game.Levels.Logo.L01_Tauto
msgid "Conclusion Logo L01: Remind that ยง0 cannot be used"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza
msgid "ยง0 Intro Piazza"
msgstr ""

#. ยง0: `mem_setOf`
#. ยง1: `Set`
#: Game.Levels.Cantor.L01_CantorPowerset
msgid "Remind: ยง0 from ยง1 could be helpful"
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.Logo.L02_Rfl
msgid "Remind: Equality is reflexive, so try ยง0"
msgstr ""

#. ยง0: $[0, ยซ{d}ยป+1]$
#. ยง1: $[0,ยซ{d}ยป]$
#. ยง2: $ยซ{d}ยป+1$
#. ยง3: `insert_Icc_eq_Icc_add_one_right`
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "Divide interval ยง0 into ยง1 and ยง2 by using ยง3"
msgstr ""

#. ยง0: `ยซ{hp}ยป`
#. ยง1: `ยซ{hp'}ยป`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Observe ยง0 and ยง1"
msgstr ""

#. ยง0: `symm`
#. ยง1: `=`
#. ยง2: `โ`
#. ยง3: `symm at h`
#. ยง4: `h`
#. ยง5: `h.symm`
#. ยง6: `symm at h`
#. ยง7: `h`
#. ยง8: `rw [โh]`
#. ยง9: ```
#.   symm at h
#.   rw [h]
#.   ```
#. ยง10: `rw [h.symm]`
#: Game.Doc.Tactic
msgid "With ยง0 (for โsymmetryโ), you swap the sides of an equation (ยง1) or equivalence (ยง2) in the proof target.\n"
"\n"
"## Variants\n"
"* ยง3 operates on the assumption ยง4 instead of the proof target\n"
"* ยง5 is the result of ยง6 and can be used like ยง7\n"
"\n"
"Each of the following three tactics or tactic sequences therefore has the same effect:\n"
"* ยง8\n"
"* ยง9\n"
"* ยง10"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L08_Induction3_sub_insert3
msgid "ยง0 Intro Babylon L08"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Spinoza.L01_Have
msgid "ยง0 Intro Spinoza L01"
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.Cantor.L01_CantorPowerset
msgid "And now disect ยง0"
msgstr ""

#. ยง0: `let s := { a | a โ ยซ{f}ยป a }`
#: Game.Levels.Cantor.L02_CantorPowerset
msgid "First, introduce set ยง0"
msgstr ""

#. ยง0: `ยซ{hp}ยป`
#. ยง1: `ยซ{a}ยป`
#. ยง2: `have hp' := ยซ{hp}ยป ยซ{a}ยป`
#. ยง3: `specialize ยซ{hp}ยป ยซ{a}ยป`
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "Apply ยง0 onto ยง1. Try either ยง2 or ยง3"
msgstr ""

#. ยง0: `ext`
#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "Try ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L12_ByCases
msgid "ยง0 Conclusion Implis L12"
msgstr ""

#. ยง0: `revert`
#. ยง1: `intro`
#. ยง2: `intro`
#. ยง3: `ยซ{A}ยป \\to ยซ{B}ยป`
#. ยง4: `revert`
#: Game.Levels.Implis.L02_Revert
msgid "ยง0 is like ยง1 'backwards'. ยง2 takes the premisse out of ยง3\n"
"and makes it into an assumption. ยง4 takes an assumption and sets it as the implication premisse\n"
"in front of the goal."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana.L02_EBasis
msgid "ยง0 Intro Robotswana L02"
msgstr ""

#. ยง0: `card_fin`
#. ยง1: `simp`
#: Game.Levels.Robotswana.L11_Linearity
msgid "Try ยง0 | ยง1"
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Babylon.L05_sum_subset2
msgid "Try out ยง0 again"
msgstr ""

#. ยง0: `E.mul_of_ne`
#: Game.Levels.Robotswana.L02_EBasis
msgid "Conclusion Robotswana L02: save result as ยง0"
msgstr ""

#. ยง0: `ยฌ A`
#. ยง1: `A`
#. ยง2: `A โ False`
#. ยง3: `push_neg`
#. ยง4: `by_contra`
#. ยง5: `contrapose`
#. ยง6: `h : ยฌ A`
#. ยง7: `apply`
#. ยง8: `False`
#: Game.Doc.Definition
msgid "ยง0 is the logical negation of ยง1.\n"
"It is implemented internally as ยง2.\n"
"\n"
"Useful tactics are: ยง3, ยง4, ยง5.\n"
"You can also apply an assumption of the form ยง6 using ยง7 to the proof target ยง8."
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "Perform ยง0 again"
msgstr ""

#: Game.Levels.Samarkand
msgid "Samarkand"
msgstr ""

#. ยง0: `binomi`
#. ยง1: `add_pow_two`
#. ยง2: `rw [add_pow_two]`
#: Game.Levels.Saturn.L02_Ring_add_pow_two
msgid "Explain misfit of ยง0. Try ยง1 via ยง2"
msgstr ""

#. ยง0: `CONC-2`
#: Game.Levels.Cantor.L09_CantorDiag
msgid "ยง0Conclusion Cantor L09 - 2"
msgstr ""

#. ยง0: `even_square`
#: Game.Levels.Spinoza.L05_Contrapose
msgid "Apply lemma ยง0"
msgstr ""

#. ยง0: `image`
#. ยง1: `''`
#. ยง2: `image f`
#. ยง3: `A`
#. ยง4: `B`
#. ยง5: ```
#. image f = fun S โฆ f '' S
#. ```
#. ยง6: `image f`
#. ยง7: `f ''`
#: Game.Levels.Samarkand.L02_ImageMap
msgid "Can not use ยง0 instead of ยง1.\n"
"Explain that ยง2 is mapping from ยง3 to ยง4 i.e.\n"
"ยง5\n"
".You can express ยง6 by ยง7 but not vica versa"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Euklid.L02_prod_insert
msgid "ยง0 Intro Euklid L02"
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "Conclusion Spinoza L04"
msgstr ""

#. ยง0: ```
#. def Even (n : โ) : Prop := โ r, n = r + r
#. ```
#. ยง1: `Odd`
#: Game.Levels.Quantus.L03_Decide
msgid "Intro Quantus L03: Show defintion\n"
"ยง0\n"
"before introducing ยง1"
msgstr ""

#. ยง0: `sum_congr`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Again employ ยง0"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Spinoza.L01_Have
msgid "ยง0 Prove the assumption before using it"
msgstr ""

#. ยง0: `obtain`
#: Game.Levels.Cantor.L01_CantorPowerset
msgid "Try ยง0 as always"
msgstr ""

#. ยง0: `A : Finset T`
#. ยง1: `card A : โ`
#. ยง2: `A`
#. ยง3: `A`
#: Game.Doc.Definition
msgid "For a finite subset ยง0, ยง1 is the cardinality of ยง2,\n"
"i.e., the number of elements in ยง3."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Iso.L02_Inverse
msgid "ยง0 Conclusion Iso L02"
msgstr ""

#. ยง0: `โ`
#. ยง1: `\\forall`
#. ยง2: `โ x, โฆ`
#. ยง3: `intro x`
#: Game.Levels.Quantus.L07_Forall
msgid "Explain ยง0 i.e. ยง1 and approch to prove ยง2  by ยง3"
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `โ a : A, P a`
#. ยง2: `a`
#. ยง3: `A`
#. ยง4: `A`
#. ยง5: `P a`
#. ยง6: `A`
#. ยง7: `โ a : A, true`
#. ยง8: `Nonempty A`
#. ยง9: `โ`
#. ยง10: `โ a : A, โฆ`
#. ยง11: `a`
#. ยง12: `use`
#. ยง13: `use a`
#. ยง14: `โ`
#. ยง15: `h : โ a : A, P a`
#. ยง16: `choose a ha using h`
#. ยง17: `obtain โจa, haโฉ := h`
#. ยง18: `a : A`
#. ยง19: `ha : P a`
#: Game.Doc.Definition
msgid "Existential quantifier: If ยง0 is a predicate, then\n"
"ยง1 is the statement that an element ยง2 in ยง3 (more precisely: of type ยง4)\n"
"exists for which the statement ยง5 is true.\n"
"A pure existence statement (\"there is an element of type ยง6)\n"
"can be formulated, for example, as ยง7 or as ยง8.\n"
"\n"
"## ยง9 as a proof goal\n"
"\n"
"To prove a statement of the form ยง10,\n"
"you construct a suitable element ยง11 and then use the ยง12 tactic (ยง13).\n"
"\n"
"## ยง14 as an assumption\n"
"\n"
"You can decompose an assumption of the form ยง15 into its components using\n"
"ยง16 or ยง17 into ยง18 and ยง19."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `S`
#. ยง2: `A`
#. ยง3: ```
#. f '' S = {f a | a โ S} = {b | โ a โ S, f a = b}
#. ```
#. ยง4: `f`
#. ยง5: `f`
#. ยง6: `''`
#: Game.Doc.Definition
msgid "For a mapping ยง0 and a subset ยง1 of ยง2,\n"
"ยง3\n"
"is its image under ยง4.  Note the space between ยง5 and ยง6."
msgstr ""

#. ยง0: `f`
#: Game.Levels.Robotswana.L10_Characterize
msgid "Explain that each ยง0 has stated properties"
msgstr ""

#. ยง0: `rw [dvd_iff_exists_eq_mul_left]`
#: Game.Levels.Prado.L03_even_iff_two_dvd
msgid "Begin with ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Epo.L01_Surjective
msgid "ยง0 Intro Epo L01"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Ciao.L01
msgid "ยง0Conclusion Cia L01"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `T`
#. ยง2: `B`
#. ยง3: ```
#. f โปยน' T = { a | f a โ T}
#. ```
#. ยง4: `f`
#. ยง5: `f \\-1'`
#. ยง6: `f`
#. ยง7: `\\-1'`
#: Game.Doc.Definition
msgid "For a mapping ยง0 and a subset ยง1 of ยง2,\n"
"ยง3\n"
"is its preimage under ยง4.\n"
"You write this as ยง5.\n"
"Note the space between ยง6 and ยง7."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L05_Linarith2
msgid "ยง0 Intro Luna L05"
msgstr ""

#. ยง0: `diag`
#. ยง1: `A โ (Fin (n + 1) โ A)`
#. ยง2: `diag`
#. ยง3: `A`
#. ยง4: `Fin (n + 1) โ A`
#. ยง5: `Fin (n+1)`
#. ยง6: $\\{0,1,โฆ,n\\}$
#. ยง7: `Fin (n + 1) โ A`
#. ยง8: $\\{0,1,โฆ,n\\}$
#. ยง9: $A$
#. ยง10: $(n+1)$
#. ยง11: $A$
#. ยง12: `diag`
#. ยง13: $A$
#. ยง14: $A^{n+1}$
#. ยง15: `diag`
#: Game.Levels.Mono.L04_Diagonal
msgid "Explain ยง0: in the definition add brackets so it's ยง1. So, ยง2\n"
"is a mapping from ยง3 to ยง4. ยง5 is the set ยง6 and therfore,\n"
"ยง7 is the set of mappings from ยง8 to ยง9. Hence, such a mapping can be seen\n"
"as a ยง10-tuple of elements in ยง11. So, ยง12 is given as a mapping from ยง13 to ยง14.\n"
"Name ยง15 should be clear now"
msgstr ""

#. ยง0: $A โ B$
#. ยง1: $ยฌB โ ยฌA$
#. ยง2: `not_imp_not`
#: Game.Levels.Spinoza.L04_ByContra
msgid "Often to prove ยง0, ยง1 can be proven as well. Here this is called ยง2."
msgstr ""

#. ยง0: `A`
#. ยง1: `trace A`
#. ยง2: `A`
#. ยง3: `โ i, A i i`
#: Game.Doc.Definition
msgid "For a matrix ยง0, ยง1 is the trace of ยง2. The expression is also equivalent to ยง3 in Leanic."
msgstr ""

#. ยง0: `simp [f, g]`
#: Game.Levels.Vieta.L06_Piecewise
msgid "Use definitions via ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana
msgid "ยง0 Intro Robotswana"
msgstr ""

#. ยง0: `decide`
#: Game.Levels.Mono.L02_InjectiveNeIff
msgid "Perhaps, try using ยง0 here"
msgstr ""

#. ยง0: `rw [ne_comm]`
#. ยง1: `simp [ne_comm]`
#: Game.Levels.Epo.L02_CurrySurjective
msgid "The number of quantors does not allow for ยง0. Try ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "ยง0 Conclusion Robotswana L08"
msgstr ""

#. ยง0: `not_even_iff_odd`
#. ยง1: `ยฌEven`
#. ยง2: `Odd`
#: Game.Levels.Quantus.L06_not_even_iff_odd
msgid "With ยง0 one can transform ยง1 to ยง2"
msgstr ""

#. ยง0: $$
#. [A, B] = AB - BA
#. $$
#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "Intro Robotswana L06: Introduce nihiliated cummotator\n"
"ยง0"
msgstr ""

#. ยง0: `specialize h aโ aโ`
#. ยง1: `have h := h aโ aโ`
#. ยง2: `h : โ mโ mโ, P mโ mโ`
#. ยง3: `h : P aโ aโ`
#. ยง4: `specialize`
#. ยง5: `have`
#. ยง6: `specialize h โฆ`
#. ยง7: `h`
#. ยง8: `h`
#. ยง9: ```
#. have ha := h aโ aโ
#. have hb := h bโ bโ
#. ```
#. ยง10: ```
#. h : โ mโ mโ, P mโ mโ
#. ha : P aโ aโ
#. hb : P bโ bโ
#. ```
#: Game.Doc.Tactic
msgid "ยง0 is equivalent to ยง1: the tactic replaces an assumption\n"
"ยง2 with the special case ยง3.\n"
"\n"
"If you want to specialize multiple times, instead of ยง4 you should use ยง5,\n"
"since ยง6 overwrites the old assumption ยง7.\n"
"From the above assumption ยง8, you can obtain the following three assumptions with\n"
"ยง9\n"
":\n"
"ยง10"
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.Luna.L01_le_rfl
msgid "Try using ยง0 here"
msgstr ""

#. ยง0: `ยซ{h}ยป`
#. ยง1: `โ`
#. ยง2: `โ`
#. ยง3: `simp`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "ยง0 is an implicid embedding of  ยง1 in ยง2.  Try ยง3"
msgstr ""

#. ยง0: `by_cases h_leq : ยซ{a}ยป โค ยซ{b}ยป`
#. ยง1: `by_cases h_lt : ยซ{a}ยป < ยซ{b}ยป`
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "Try ยง0, ยง1"
msgstr ""

#. ยง0: `โ`
#. ยง1: `\\l`
#. ยง2: `rw [โ hโ]`
#: Game.Levels.Implis.L08_Rw
msgid "To rewrite into the other direction you can use ยง0 (ยง1) infront of the name. Try ยง2"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Spinoza.L03_ByContra
msgid "ยง0 Intro Spinoza L03"
msgstr ""

#. ยง0: `CONC-1`
#: Game.Levels.Cantor.L09_CantorDiag
msgid "ยง0Conclusion Cantor L09 - 1"
msgstr ""

#. ยง0: `trace`
#: Game.Levels.Robotswana.L10_Characterize
msgid "Intro Robotswana L10: Introduce ยง0"
msgstr ""

#. ยง0: `(g โ ยซ{f}ยป) x`
#. ยง1: `g (ยซ{f}ยป x)`
#. ยง2: `simp`
#. ยง3: `rw [comp_apply]`
#: Game.Levels.Vieta.L04_Let
msgid "Explain ยง0 defined as ยง1. Try ยง2 | ยง3"
msgstr ""

#. ยง0: `by_contra h`
#. ยง1: `P`
#. ยง2: `by_contra h`
#. ยง3: `(h : ยฌ P)`
#. ยง4: `False`
#. ยง5: `contradiction`
#. ยง6: `A โ B`
#. ยง7: `contrapose`
#: Game.Doc.Tactic
msgid "The tactic ยง0 initiates a proof by contradiction.\n"
"If ยง1 is your current proof goal, ยง2 generates a new assumption ยง3\n"
"and sets the proof goal to ยง4.\n"
"\n"
"## Friends and relatives\n"
"\n"
"* At the end of a proof by contradiction, there is usually ยง5:\n"
"this tactic closes the proof when it finds two obviously contradictory assumptions.\n"
"* If the proof goal is of the form ยง6, you can use ยง7\n"
"to start a proof by contraposition."
msgstr ""

#. ยง0: `rw`
#. ยง1: `trans`
#. ยง2: $B \\iff A \\iff D \\iff C$
#. ยง3: `trans A`
#. ยง4: `B \\iff A`
#. ยง5: `trans D`
#: Game.Levels.Implis.L09_Trans
msgid "Intro Implis L09: Instead of ยง0 use ยง1 here.\n"
"With it you can solve ยง2 step-by-step by using\n"
"ยง3 to introduce the intermediate step ยง4 and then\n"
"perfrom The next step with ยง5"
msgstr ""

#. ยง0: `Even n`
#. ยง1: `n : โ`
#. ยง2: ```
#. โ r : โ, n = r + r
#. ```
#. ยง3: `unfold Even`
#: Game.Doc.Definition
msgid "ยง0 is the statement that ยง1 is even:\n"
"ยง2\n"
"You can easily check this with ยง3."
msgstr ""

#. ยง0: `ext`
#: Game.Levels.Samarkand.L02_ImageMap
msgid "Show equality of sets by ยง0"
msgstr ""

#. ยง0: `assumption`
#: Game.Doc.Tactic
msgid "The ยง0 tactic closes the proof if one of the assumptions corresponds exactly to the proof target."
msgstr ""

#. ยง0: `n โ 10`
#. ยง1: `n = 10`
#. ยง2: `โ`
#. ยง3: `ยฌ(ยท = ยท)`
#: Game.Levels.Logo.L09_Contradiction
msgid "Conclusion Logo L09: ยง0 is negation of ยง1. ยง2 has to be read as ยง3"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Babylon.L09_Boss
msgid "ยง0 Conclusion Babylon L09"
msgstr ""

#. ยง0: `โ โ โ`
#: Game.Levels.Cantor.L11_SequenceUncountable
msgid "Intro Cantor L11: Show that set of mapping ยง0 is uncountable"
msgstr ""

#. ยง0: `rfl`
#. ยง1: `rw`
#. ยง2: `trans`
#: Game.Doc.Definition
msgid "Useful tactics for equality are: ยง0, ยง1, ยง2"
msgstr ""

#. ยง0: `โ`
#. ยง1: `0, 1, 2, โฆ`
#. ยง2: `=`
#. ยง3: `โ`
#. ยง4: `ยฌ(ยท=ยท)`
#. ยง5: `Prop`
#. ยง6: `True`
#. ยง7: `(True : Prop)`
#. ยง8: `False`
#. ยง9: `(False : Prop)`
#. ยง10: `ยฌ`
#. ยง11: `โง`
#. ยง12: `โจ`
#. ยง13: `(n : โ)`
#. ยง14: `(A : Prop)`
#. ยง15: `(ha : A)`
#. ยง16: `(A : Prop)`
#. ยง17: `(h : A โง B)`
#. ยง18: `h`
#. ยง19: `rfl`
#. ยง20: `A = A`
#. ยง21: `assumption`
#. ยง22: `contradiction`
#. ยง23: `decide`
#. ยง24: `constructor`
#. ยง25: `left`
#. ยง26: `right`
#. ยง27: `obtain โจhโ, hโโฉ := h`
#. ยง28: `obtain h := h \\| h`
#: Game.Levels.Logo.L13_Or
msgid "Conclusion Logo L13:\n"
"Notations introdced so far:\n"
"ยง0, ยง1, ยง2, ยง3 (shorthand for ยง4), ยง5, ยง6 (ยง7 is always true),\n"
"ยง8 (ยง9 is always false), ยง10, ยง11, ยง12, ยง13, ยง14, ยง15 (Proof that ยง16 is true),\n"
" ยง17 (Assumption with name ยง18).\n"
"Tactics introduced so far:\n"
"ยง19 (proves ยง20), ยง21, ยง22, ยง23, ยง24, ยง25/ยง26, ยง27, ยง28"
msgstr ""

#. ยง0: `mul_assoc`
#. ยง1: `ring`
#: Game.Levels.Saturn.L04_mul_assoc
msgid "Try ยง0 or again ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L04_99
msgid "ยง0 Intro Prado L04"
msgstr ""

#. ยง0: `1 ยซ{i}ยป ยซ{x}ยป`
#. ยง1: `Matrix.one_apply`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Apply definition ยง0 by ยง1"
msgstr ""

#. ยง0: $$ \\sum_{i = 0}^n i = \\tfrac{1}{2} \\cdot n \\cdot (n + 1) $$
#. ยง1: `n`
#. ยง2: `induction n with d hd`
#. ยง3: `with โฆ`
#. ยง4: `d`
#. ยง5: `hd`
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "To proof sum ยง0\n"
"try to perform induction over ยง1 using ยง2. ยง3 is optional and you can\n"
"decide on the name of your induction variable (ยง4) and hypothesis (ยง5)."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L10_EvenPrime
msgid "ยง0 Intro Prado L10"
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `ยซ{B}ยป`
#. ยง2: `ยซ{A}ยป โง ยซ{B}ยป`
#: Game.Levels.Implis.L01_Intro
msgid "Having ยง0 and ยง1 in your assumptions you have to show ยง2"
msgstr ""

#. ยง0: `โ`
#: Game.Levels.Vieta.L01_FunctionNotation
msgid "Conclusion Vieta L01: explain ambiguity of ยง0"
msgstr ""

#. ยง0: `apply`
#: Game.Levels.Implis.L05_Apply
msgid "Hier again use ยง0"
msgstr ""

#. ยง0: `g โ ยซ{f}ยป`
#. ยง1: `\\comp`
#. ยง2: `let g : โค โ โค := fun x โฆ _`
#. ยง3: `use fun (x : โค) โฆ _`
#: Game.Levels.Vieta.L04_Let
msgid "Composition ยง0 can be written with ยง1. Try ยง2 or ยง3"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Implis.L11_Iff
msgid "ยง0 Goal is in assumptions"
msgstr ""

#. ยง0: `โ`
#. ยง1: `โ`
#. ยง2: `ring`
#: Game.Levels.Saturn.L04_mul_assoc
msgid "Conclusion Saturn L04: coefficients were in ยง0. Polynomes with coefficients in ยง1\n"
"are not considered rings. ยง2 does also work on half rings."
msgstr ""

#. ยง0: `simp`
#. ยง1: `ring`
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "The rest is simple computation solvable by ยง0 and ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L07_antisymm_iff
msgid "ยง0 Intro Piazza L07"
msgstr ""

#. ยง0: `apply`
#. ยง1: `ยซ{h}ยป`
#. ยง2: `rw [โ ยซ{h}ยป]`
#. ยง3: `ยซ{A}ยป โ ยซ{B}ยป`
#. ยง4: `ยซ{h}ยป`
#. ยง5: `ยซ{h}ยป.mp`
#. ยง6: `apply (ยซ{h}ยป.mp) at โฆ`
#: Game.Levels.Implis.L10_Iff
msgid "We know that ยง0 can be used on implications. Intuitively, for equivalence ยง1\n"
"one could use ยง2. The direction ยง3 of ยง4 is denoted by ยง5.\n"
"Try ยง6"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L07_idempotent
msgid "ยง0Conclusion Cantor L07"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L14_Summary
msgid "ยง0 Conclusion Logo L14"
msgstr ""

#. ยง0: `push_neg`
#. ยง1: `ยฌโ x, P x`
#. ยง2: `โ x, ยฌP x`
#. ยง3: `ยฌโ x, P x`
#. ยง4: `โ x, ยฌP x`
#. ยง5: `ยฌ`
#. ยง6: ```
#.   ยฌ โ ฮต, โ ฮด, โ y, | x - y | < ฮด โ | f x - f y | < ฮต
#. ```
#. ยง7: `push_neg`
#. ยง8: ```
#.   โ ฮต, โ ฮด, โ y, ยฌ (| x - y | < ฮด โ | f x - f y | < ฮต)
#. ```
#. ยง9: `not_forall`
#. ยง10: `not_exists`
#. ยง11: `rw`
#: Game.Doc.Tactic
msgid "The ยง0 tactic pushes negation past quantifiers:\n"
"\n"
"| before       | after      |\n"
"|:------------ |:-------------|\n"
"| ยง1  | ยง2  |\n"
"| ยง3  | ยง4  |\n"
"\n"
"In nested expressions, it pushes the negation ยง5 as far to the right as possible.\n"
"For example, the proof goal\n"
"ยง6\n"
"with ยง7\n"
"ยง8\n"
"\n"
"## Friends and relatives\n"
"\n"
"The two lemmas ยง9 and ยง10 can be applied individually with ยง11."
msgstr ""

#. ยง0: `B`
#: Game.Levels.Implis.L04_Apply
msgid "Prove ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "ยง0 Intro Cantor L03"
msgstr ""

#. ยง0: `obtain โจhโ, hโโฉ := ยซ{h}ยป`
#. ยง1: `\\<`
#. ยง2: `\\>`
#. ยง3: `\\<>`
#. ยง4: `h\\1`
#. ยง5: `hโ`
#. ยง6: `hโ`
#. ยง7: `obtain โจhA, hBCโฉ := ยซ{h}ยป`
#: Game.Levels.Logo.L11_And
msgid "Deconstruct assumption by ยง0. The brackets can be written seperatly\n"
"as ยง1 and ยง2 or simultaneously as ยง3. The first assumption can be named ยง4. Other names\n"
"than ยง5 und ยง6 can be chosen as well e.g. ยง7"
msgstr ""

#. ยง0: `Even.neg_pow`
#. ยง1: `Odd.neg_pow`
#: Game.Levels.Babylon.L05_sum_subset2
msgid "Familiar situation: try ยง0 or ยง1"
msgstr ""

#. ยง0: `0 < n`
#. ยง1: `n < 0`
#. ยง2: `n โ 0`
#: Game.Levels.Luna.L02_Omega
msgid "Intro Luna L02: For integers ยง0 or ยง1 means ยง2"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon
msgid "ยง0 Intro Babylon"
msgstr ""

#. ยง0: `A B C : Set โ`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `C`
#. ยง4: `โ`
#. ยง5: `Set`
#. ยง6: `ext x`
#. ยง7: `A = B`
#. ยง8: `x โ A โ x โ B`
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "ยง0 means that ยง1, ยง2 and ยง3 are subsets of ยง4. Therefore, ยง5\n"
"can be interpreted as 'subset'. Use ยง6 to replace a set equation ยง7 with ยง8"
msgstr ""

#. ยง0: `map_sum`
#. ยง1: `simp`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Try ยง0 via ยง1"
msgstr ""

#: Game.Levels.Logo
msgid "Logo"
msgstr ""

#. ยง0: `Finset.prod_pos`
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "ยง0 is helpful here"
msgstr ""

#. ยง0: `by_cases`
#: Game.Levels.Implis.L14_Summary
msgid "Maybe try ยง0 again"
msgstr ""

#. ยง0: `ยซ{g}ยป`
#. ยง1: `ยซ{f}ยป`
#. ยง2: `have hR : RightInverse ยซ{g}ยป ยซ{f}ยป`
#: Game.Levels.Iso.L02_Inverse
msgid "Show that ยง0 is righ inverse to ยง1 e.g. ยง2"
msgstr ""

#. ยง0: `f`
#. ยง1: `g`
#: Game.Levels.Mono.L08_RightInvOfLeftInv
msgid "Explain goal: An injective mapping ยง0 which is left inverse to mapping ยง1, is to the same mapping also right inverse"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Ciao
msgid "ยง0 Intro Ciao"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "ยง0 Conclusion Cantor L03"
msgstr ""

#. ยง0: `tauto`
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "The rest can be dealt with ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L01_NonemptyUse
msgid "ยง0 Conclusion Quantus L01"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "ยง0 Remind of previous result"
msgstr ""

#. ยง0: `omega`
#. ยง1: `โ`
#. ยง2: `โค`
#. ยง3: `linarith`
#: Game.Doc.Tactic
msgid "The tactic ยง0 can show that a linear equation or inequality in ยง1 or ยง2\n"
"follows from given equations or inequalities.\n"
"Unlike ยง3, it can also handle logical connections between (in)equations."
msgstr ""

#. ยง0: `Mat[ยซ{n}ยป,ยซ{n}ยป]`
#. ยง1: $(ยซ{n}ยป \\times ยซ{n}ยป)$
#. ยง2: `Fin ยซ{n}ยป`
#. ยง3: `Fin ยซ{n}ยป`
#. ยง4: $\\{0,...,n-1\\}$
#. ยง5: $0$
#. ยง6: $1$
#. ยง7: `single i j a`
#. ยง8: `(i, j)`
#. ยง9: `a`
#. ยง10: `E`
#. ยง11: `a = 1`
#. ยง12: `A i j`
#. ยง13: `A`
#. ยง14: `(i, j)`
#. ยง15: $$
#. A_{i,j} \\cdot
#. \\begin{pmatrix}
#. 0 & 0 & 0\\
#. 1 & 0 & 0 \\
#. 0 & 0 & 0
#. \\end{pmatrix}
#. =
#. \\begin{pmatrix}
#. 0 & 0 & 0\\
#. A_{i,j} & 0 & 0 \\
#. 0 & 0 & 0
#. \\end{pmatrix}
#. $$
#. ยง16: `unfold E`
#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "ยง0 looks like a ยง1 matrix. Reminder for ยง2: ยง3 is\n"
"the set ยง4. Indeces start here at ยง5 and not ยง6. ยง7 is the matrix which\n"
"has at position ยง8 the entry ยง9 and else zero. ยง10s are abbreviations for case ยง11.\n"
"ยง12 is entry of matrix ยง13 at position ยง14. Goal can be seen as scalar multiplication akin to\n"
"\n"
"ยง15\n"
"\n"
"Begin with ยง16.\n"
""
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L07_Symm
msgid "ยง0 Intro Implis L07"
msgstr ""

#. ยง0: `f`
#. ยง1: `E i i`
#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "Explain ยง0 with ยง1"
msgstr ""

#. ยง0: `A : Set T`
#. ยง1: `h : Set.Finite A`
#. ยง2: `h.toFinset : Finset T`
#. ยง3: `A`
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "Ist eine Teilmenge ยง0 mit der Annahme ยง1 gegeben,\n"
"so ist ยง2 dieselbe Teilmenge ยง3,\n"
"aber nun explizit als endliche Teilmenge aufgefasst."
msgstr ""

#. ยง0: `h_nonempty`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Use assumption ยง0"
msgstr ""

#. ยง0: `revert`
#. ยง1: `revert`
#: Game.Levels.Implis.L03_Apply
msgid "Intro Implis L03: This Level does not know ยง0. Try proof without ยง1"
msgstr ""

#. ยง0: `f`
#. ยง1: `โค`
#. ยง2: `โ`
#. ยง3: `f n`
#. ยง4: $f(n)$
#. ยง5: `f (n)`
#: Game.Levels.Vieta.L01_FunctionNotation
msgid "Explain ยง0 as mapping from ยง1 to ยง2:\n"
"ยง3 is notation for ยง4. If you want to use brackets it has to be ยง5.\n"
""
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "ยง0 Intro Quantus L10"
msgstr ""

#. ยง0: `ยซ{h}ยป`
#. ยง1: `ยซ{h}ยป`
#. ยง2: `aโ โค bโ`
#. ยง3: `aโ โค aโ`
#. ยง4: `aโ โค aโ`
#. ยง5: `have`
#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "Use assumption ยง0. E.g. apply ยง1 onto ยง2 or ยง3.\n"
"Formulate ยง4 using ยง5"
msgstr ""

#. ยง0: `ยฌ`
#. ยง1: `contradiction`
#. ยง2: `by_contra h`
#. ยง3: `contradiction`
#: Game.Levels.Spinoza.L03_ByContra
msgid "Explain ยง0 in goal. Perform proof by ยง1 by stating with ยง2 and\n"
"concluding with ยง3"
msgstr ""

#. ยง0: `decide`
#: Game.Levels.Piazza.L02_Simp
msgid "Remember to use ยง0 here"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "ยง0 Conclusion Samarkand L05"
msgstr ""

#. ยง0: `contrapose`
#: Game.Levels.Spinoza.L05_Contrapose
msgid "Apply contraposition lemma simply by ยง0"
msgstr ""

#. ยง0: `ยซ{n}ยป โ ยซ{n}ยป`
#: Game.Levels.Logo.L08_Contradiction
msgid "Check that ยง0 is contradiction by the Contradiction tactic"
msgstr ""

#. ยง0: `rw`
#. ยง1: `rfl`
#: Game.Levels.Implis.L13_Rw
msgid "Conclusion Implis L13: Explain that ยง0 always tries to apply ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L08_Contradiction
msgid "ยง0 Intro Logo L08"
msgstr ""

#. ยง0: ```
#. E i j := single i j (1 : โ)
#. ```
#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "Intro Robotswana L01: introduce definition\n"
"ยง0"
msgstr ""

#. ยง0: `toNat`
#. ยง1: `n : โค`
#. ยง2: `n.toNat : โ`
#. ยง3: `(-1).toNat`
#. ยง4: `n โฅ 0`
#. ยง5: `n.toNat`
#: Game.Levels.Vieta.L07_Extend
msgid "Try ยง0. Explain, given ยง1 then ยง2 is the same number interpreted as a natural number.\n"
"Remind that ยง3 undefined as ยง4 for ยง5"
msgstr ""

#. ยง0: `E i j`
#. ยง1: `n ร n`
#. ยง2: `โ`
#. ยง3: `1`
#. ยง4: $(i, j)$
#. ยง5: `single i j (a : R)`
#. ยง6: `a`
#. ยง7: `E`
#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "ยง0 ist die ยง1-Matrix (mit Werten in ยง2) mit einer ยง3 an\n"
"Stelle ยง4 und Null รผberall sonst.\n"
"\n"
"Dies ist eine spezialisierte Form der generellen ยง5,\n"
"welche auch nicht-quadratisch sein kann und einen beliebigen Wert ยง6 aus einem beliebigen\n"
"Ring annehmen kann. Wir benutzen hier ยง7 einfach als Abkรผrzung."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L09_Trans
msgid "ยง0 Conclusion Implis L09"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L10_Surjective
msgid "ยง0 Intro Vieta L10"
msgstr ""

#. ยง0: `rw [eq_sum_apply_diag_ebasis]`
#: Game.Levels.Robotswana.L10_Characterize
msgid "Remind missed argument with ยง0"
msgstr ""

#. ยง0: `exists_prime_and_dvd`
#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
msgid "Try proof by conradiction. For this employ ยง0"
msgstr ""

#. ยง0: `subset_iff`
#. ยง1: `simp`
#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "Try using ยง0 and if nothing else helps, ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta
msgid "ยง0 Intro Vieta"
msgstr ""

#. ยง0: `COMMENT`
#: Game.Levels.Vieta.L03_Let
msgid "ยง0 Try simplification"
msgstr ""
