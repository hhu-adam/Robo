msgid ""
msgstr "Project-Id-Version: Game v4.22.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-24\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: de\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L13_insert_erase
msgid "ยง0 Intro Piazza L13"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L03_Apply
msgid "ยง0 Conclusion Implis L03"
msgstr ""

#: Game.Levels.Epo.L04_RightInverse
msgid "Intro Epo L04"
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid "Intro Vieta L09"
msgstr ""

#: Game.Levels.Piazza.L12_insert
msgid "Conclusion Piazza L12"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Vieta.L10_Surjective
msgid "ยง0 Conclusion Vieta L10"
msgstr ""

#. ยง0: `let`
#. ยง1: `let x : โ := 5 ^ 2`
#. ยง2: `x`
#. ยง3: `let x := โฆ`
#. ยง4: `simp only [x]`
#: Game.Doc.Tactic
msgid "The ยง0 tactic introduces a temporary definition, for example ยง1.\n"
"\n"
"Once you have defined an ยง2 with ยง3, you can use the definition later with ยง4."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "ยง0 Intro Euklid L03"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L04_Assumption
msgid "ยง0 Intro Logo L04"
msgstr ""

#. ยง0: `Nonempty T`
#. ยง1: `T`
#. ยง2: `T`
#. ยง3: `h : Nonempty T`
#. ยง4: `t : T`
#. ยง5: `obtain โจtโฉ := h`
#. ยง6: `t : T`
#. ยง7: `Nonempty T`
#. ยง8: `use t`
#. ยง9: `A : Set T`
#. ยง10: `Nonemty A`
#. ยง11: `โ x, x โ A`
#. ยง12: `unfold Nonempty`
#: Game.Doc.Definition
msgid "ยง0 means that an element in ยง1 (โof type ยง2โ) exists. If ยง3 is given as an assumption, we obtain an element ยง4 with ยง5. Conversely, if we already have an element ยง6 given or constructed, we can prove ยง7 with ยง8.\n"
"\n"
"Similarly, for a subset ยง9, the statement ยง10 is defined as ยง11. In this case, you can easily check this with ยง12."
msgstr ""

#. ยง0: `(g โ f) ยซ{x}ยป`
#. ยง1: `g (f ยซ{x}ยป)`
#. ยง2: `simp`
#: Game.Levels.Vieta.L06_Piecewise
msgid "Rewrite ยง0 to ยง1 via ยง2"
msgstr ""

#. ยง0: ``` E i j := single i j (1 : โ) ```
#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "Intro Robotswana L01: introduce definition ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L05_True
msgid "ยง0 Intro Logo L05"
msgstr ""

#. ยง0: $(n ร n)$
#. ยง1: $\\mathbb{R}$
#. ยง2: $A$
#. ยง3: $A = \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} A_{ij} \\cdot E(i, j)$
#. ยง4: `matrix_eq_sum_single`
#. ยง5: $(m ร n)$
#. ยง6: $R$
#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Sagt aus, dass man jede ยง0-Matrix (รผber ยง1) ยง2 schreiben kann als ยง3.\n"
"\n"
"Siehe auch ยง4, welches die generalisierte Form fรผr ยง5-Matrix (รผber beliebigem ยง6) ist."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "ยง0 Conclusion Robotswana L07"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L05_IsFixedPt_not
msgid "ยง0Conclusion Cantor L05"
msgstr ""

#. ยง0: `tauto`
#: Game.Levels.Implis
msgid "Intro Implis: mention that planet could not be solved without ยง0"
msgstr ""

#. ยง0: `f`
#. ยง1: `A`
#. ยง2: `A`
#: Game.Levels.Cantor.L01_CantorPowerset
msgid "Intro Cantor L01: Mapping ยง0 from ยง1 to the power set of ยง2"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Spinoza.L03_ByContra
msgid "ยง0 Conclusion Spinoza L03"
msgstr ""

#: Game.Levels.Cantor.L05_IsFixedPt_not
msgid "Intro Cantor L05"
msgstr ""

#. ยง0: `E i j`
#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
msgid "intro Robotswana L07: Do not consider ยง0 with i โ j"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L05_Funext
msgid "ยง0 Intro Vieta L05"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L01_Sum_Simp_Card
msgid "ยง0 Intro Babylon L01"
msgstr ""

#. ยง0: `False : Prop`
#. ยง1: `False`
#. ยง2: `False`
#. ยง3: `contradiction`
#. ยง4: `False`
#. ยง5: `h : ยฌ A`
#. ยง6: `apply h`
#. ยง7: `A`
#. ยง8: `ยฌ A`
#. ยง9: `A โ False`
#. ยง10: `False`
#. ยง11: `False`
#. ยง12: `contradiction`
#: Game.Doc.Definition
msgid "The statement ยง0 is always false.\n"
"\n"
"## ยง1 as proof target\n"
"\n"
"If ยง2 is your proof target, you can try to find a contradiction in your assumptions, for example. Once the contradiction is sufficiently evident, ยง3 concludes such a proof.\n"
"\n"
"If ยง4 is your proof goal and you have an assumption or lemma of the form ยง5 available, you can use ยง6 to change the proof goal to ยง7 (because ยง8 means ยง9).\n"
"\n"
"## ยง10  as an assumption\n"
"\n"
"If you have ยง11 as an assumption, you can immediately end the proof with ยง12 โ because, as is well known, any other statement follows from a false statement."
msgstr ""

#. ยง0: ``` A = B ```
#. ยง1: `T`
#. ยง2: `A B : Set T`
#. ยง3: `ext x`
#. ยง4: ``` x โ A โ x โ B ```
#: Game.Doc.Tactic
msgid "Two subsets of a given set are equal if they have the same elements. If the proof goal is ยง0 for two subsets of ยง1 (i.e., for ยง2), then ยง3 converts the proof goal into the equivalence ยง4"
msgstr ""

#. ยง0: $42 = 42$
#: Game.Levels.Logo.L02_Rfl
msgid "Intro Logo L02: Why is ยง0?"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "ยง0 Intro Babylon L06"
msgstr ""

#. ยง0: `rw [ยซ{h}ยป]`
#. ยง1: `apply (ยซ{h}ยป.mp)`
#. ยง2: `obtain โจmp, mprโฉ := ยซ{h}ยป`
#: Game.Levels.Implis.L11_Iff
msgid "Instead of ยง0 and ยง1 try ยง2"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L05_neg_pow
msgid "ยง0 Intro Quantus L05"
msgstr ""

#. ยง0: `revert`
#: Game.Levels.Implis.L03_Apply
msgid "Intro Implis L03: Try proof without ยง0"
msgstr ""

#. ยง0: `preimage f`
#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "Explain surcetivity by ยง0"
msgstr ""

#. ยง0: `congr_arg`
#. ยง1: `x = y`
#. ยง2: `f x = f y`
#. ยง3: `apply congr_arg`
#: Game.Levels.Vieta.L08_CongrArg
msgid "Try ยง0. If ยง1, then ยง2 when using ยง3"
msgstr ""

#. ยง0: `A โจ B`
#. ยง1: `right`
#. ยง2: `left`
#: Game.Doc.Tactic
msgid "If the proof target is of the form ยง0, you choose ยง1 to show the right side.\n"
"\n"
"## Friends and relatives\n"
"\n"
"With ยง2, you choose the left side accordingly."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Saturn.L02_Ring_add_pow_two
msgid "ยง0 Intro Saturn L02"
msgstr ""

#. ยง0: `A B : Prop`
#. ยง1: `A โ B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `X Y : Type`
#. ยง5: `X โ Y`
#. ยง6: `X`
#. ยง7: `Y`
#. ยง8: `A โ B`
#. ยง9: `h : A`
#. ยง10: `intro h`
#. ยง11: `B`
#. ยง12: `apply`
#: Game.Doc.Definition
msgid "For ยง0, ยง1 is the implication โยง2 implies ยง3.โ For other ยง4, ยง5 is a mapping that maps values from ยง6 to ยง7.\n"
"\n"
"## Implication as proof goal\n"
"\n"
"If your proof goal is an implication ยง8, you can assume ยง9 with ยง10, and then you must prove ยง11.\n"
"\n"
"## Implication as assumption\n"
"\n"
"To use an implication among your assumptions, use the tactic ยง12."
msgstr ""

#. ยง0: `A : Finset T`
#. ยง1: `card A : โ`
#. ยง2: `A`
#. ยง3: `A`
#: Game.Doc.Definition
msgid "For a finite subset ยง0, ยง1 is the cardinality of ยง2, i.e., the number of elements in ยง3."
msgstr ""

#. ยง0: `have`
#. ยง1: `suffices`
#. ยง2: `suffices g : ยฌB`
#. ยง3: `g`
#: Game.Levels.Spinoza.L02_Suffices
msgid "Explain ยง0 w.r.t. ยง1. Explain ยง2 w.r.t. ยง3"
msgstr ""

#. ยง0: `n โค n`
#: Game.Levels.Luna.L01_le_rfl
msgid "Intro Luna L01: Know that ยง0"
msgstr ""

#. ยง0: `succ : โ โ โ`
#. ยง1: `n โฆ n + 1`
#: Game.Doc.Definition
msgid "ยง0 is the mapping ยง1. It therefore maps a natural number to its successor."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "ยง0 Conclusion Samarkand L07"
msgstr ""

#. ยง0: `constructor`
#. ยง1: `comp_apply`
#. ยง2: `congr_fun`
#: Game.Levels.Epo.L04_RightInverse
msgid "Try ยง0, ยง1 | ยง2"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L09_PushNeg
msgid "ยง0 Conclusion Quantus L09"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "ยง0 Conclusion Mono L09"
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "Story: reminder of set equality"
msgstr ""

#. ยง0: `f ยซ{A}ยป`
#: Game.Levels.Robotswana.L10_Characterize
msgid "Rewrite ยง0 as sum of basis elements"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid "ยง0 Conclusion Prado L08"
msgstr ""

#. ยง0: `omega`
#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "Intro Luna L10: Use ยง0 again"
msgstr ""

#. ยง0: `obtain`
#. ยง1: `h`
#: Game.Levels.Implis.L14_Summary
msgid "Try ยง0 to divide ยง1"
msgstr ""

#. ยง0: `obtain โจhโ, hโโฉ := ยซ{h}ยป`
#. ยง1: `\\<>`
#: Game.Levels.Logo.L13_Or
msgid "Try ยง0. Write brackets as ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L04_Assumption
msgid "ยง0 Conclusion Logo L04"
msgstr ""

#. ยง0: `ยฌ`
#: Game.Levels.Quantus.L09_PushNeg
msgid "Remind about ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "ยง0 Conclusion Samarkand L03"
msgstr ""

#. ยง0: `matrix_eq_sum_ebasis`
#. ยง1: `1`
#. ยง2: `matrix_eq_sum_ebasis 1`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Try ยง0 on ยง1 with ยง2"
msgstr ""

#. ยง0: `A ร A`
#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
msgid "Intro Cantor L08: Mapping defined on product ยง0 with diagonal"
msgstr ""

#. ยง0: `simp`
#. ยง1: `mathlib`
#. ยง2: `@[simp]`
#. ยง3: `simp [h]`
#. ยง4: `h`
#. ยง5: `h`
#. ยง6: `simp [F]`
#. ยง7: `F`
#. ยง8: `simp only [h,f,g]`
#. ยง9: `h`
#. ยง10: `f`
#. ยง11: `g`
#. ยง12: `simp?`
#: Game.Doc.Tactic
msgid "The ยง0 tactic attempts to apply a large number of lemmas to simplify a given expression. (Technically, these are all lemmas in ยง1 that are marked with ยง2.)\n"
"\n"
"## Variants\n"
"\n"
"* ยง3 additionally uses the assumption ยง4 or the lemma ยง5 for simplification * ยง6 additionally uses the definition of ยง7 * ยง8 exclusively uses the assumptions/lemmas/definitions ยง9, ยง10, and ยง11 * ยง12 shows you which lemmas were used"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L10
msgid "ยง0 Intro Piazza L10"
msgstr ""

#: Game.Levels.Vieta.L06_Piecewise
msgid "Conclusion Vieta L06"
msgstr ""

#. ยง0: `f`
#. ยง1: ``` โ โฆa bโฆ, a < b โ f a < f b ```
#: Game.Doc.Definition
msgid "A mapping ยง0 is strictly monotonous, if:\n"
"\n"
"ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L11_And
msgid "ยง0 Intro Logo L11"
msgstr ""

#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "Conclusion Luna L10"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L01_Mem__Set
msgid "ยง0 Intro Piazza L01"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "ยง0 Intro Prado L06"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `S`
#. ยง2: `A`
#. ยง3: `f`
#. ยง4: `T`
#. ยง5: `B`
#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "Explain statement with ยง0 using ยง1, ยง2, ยง3, ยง4 and ยง5"
msgstr ""

#. ยง0: `x โ y`
#. ยง1: `ยฌ x = y`
#. ยง2: `unfold Ne`
#: Game.Doc.Definition
msgid "Inequality ยง0 is defined as ยง1.  You can see this with ยง2."
msgstr ""

#: Game.Levels.Mono.L04_Diagonal
msgid "Intro Mono L04"
msgstr ""

#. ยง0: `(A B : Set T)`
#. ยง1: `A\\B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `A`
#. ยง5: `B`
#: Game.Doc.Definition
msgid "For two subsets ยง0, ยง1 is the difference between ยง2 and ยง3, consisting of all elements of ยง4 that are not in ยง5."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "ยง0 Conclusion Robotswana L04"
msgstr ""

#. ยง0: `intro`
#: Game.Levels.Implis.L14_Summary
msgid "Try ยง0 to solve implication"
msgstr ""

#. ยง0: `ext`
#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "Conclusion Piazza L06: Explain that ยง0 means extensionality"
msgstr ""

#: Game.Levels.Cantor.L06_IsFixedPt_odd
msgid "Intro Cantor L06"
msgstr ""

#. ยง0: `A : Set T`
#. ยง1: `a`
#. ยง2: `T`
#. ยง3: `T`
#. ยง4: `a โ A`
#. ยง5: `a`
#. ยง6: `A`
#. ยง7: `A = { a : T | P a }`
#. ยง8: `a โ A`
#. ยง9: `simp`
#. ยง10: `P a`
#: Game.Doc.Definition
msgid "For a subset ยง0 and an element ยง1 from ยง2 (more precisely: of type ยง3), ยง4 means that ยง5 is in ยง6. For subsets of the form ยง7, you can simplify the statement ยง8 with ยง9 to ยง10."
msgstr ""

#. ยง0: `A : Set T`
#. ยง1: `h : Set.Finite A`
#. ยง2: `h.toFinset : Finset T`
#. ยง3: `A`
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "Ist eine Teilmenge ยง0 mit der Annahme ยง1 gegeben, so ist ยง2 dieselbe Teilmenge ยง3, aber nun explizit als endliche Teilmenge aufgefasst."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "ยง0 Conclusion Samarkand L01"
msgstr ""

#. ยง0: ``` f = g ```
#. ยง1: `f g : X โ Y`
#. ยง2: `funext x`
#. ยง3: ``` f x = g x ```
#: Game.Doc.Tactic
msgid "Two mappings with the same range and domain are equal if they take the same values on all elements of the domain. A proof goal of the form ยง0 for mappings ยง1 is converted by ยง2 into the equation ยง3."
msgstr ""

#. ยง0: `simp`
#: Game.Levels.Babylon.L02_Card2
#: Game.Levels.Babylon.L03_sum_congr
#: Game.Levels.Babylon.L03_sum_congr
#: Game.Levels.Piazza.L01_Mem__Set
msgid "try ยง0"
msgstr ""

#. ยง0: `2`
#. ยง1: `a`
#. ยง2: `b`
#. ยง3: `a`
#. ยง4: `b`
#. ยง5: `a โฃ b`
#. ยง6: `\\|`
#. ยง7: `\\dvd`
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "Intro Prado L02: Prove that ยง0 is only even prime by using the expression โยง1 divides ยง2โ. โยง3 divides ยง4โ is written as ยง5, where the vertical bar can be either written as ยง6 or ยง7"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "ยง0 Intro Piazza L04"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Luna.L07_Linarith2
msgid "ยง0 Conclusion Luna L07"
msgstr ""

#. ยง0: `ยซ{h}ยป : ยซ{A}ยป`
#. ยง1: `suffices`
#. ยง2: `suffices k : B`
#: Game.Levels.Spinoza.L03_ByContra
msgid "Apply contradiction with ยง0 via ยง1 with ยง2"
msgstr ""

#. ยง0: `Even x โจ ยฌEven x`
#. ยง1: `rw [โ Nat.not_odd_iff_even]`
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "Explain that ยง0 tautology. Try ยง1"
msgstr ""

#. ยง0: `n : โ`
#. ยง1: `Prime n`
#. ยง2: `n`
#. ยง3: `prime_def`
#: Game.Doc.Definition
msgid "For ยง0, ยง1 means that ยง2 is a prime number. To work with this definition, it is often helpful to rewrite it using the lemma ยง3."
msgstr ""

#: Game
msgid "Dieses Spiel illustriert Beweisfรผhrung mit Lean anhand verschiedener Themen aus der Eingangsphase des Bachelorstudiums Mathematik."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L10_Iff
msgid "ยง0 Conclusion Implis L10"
msgstr ""

#. ยง0: `obtain h | h | h  := ยซ{h}ยป`
#: Game.Levels.Babylon.L04_sum_subset
msgid "Divide ยซ{h}ยป into three by ยง0"
msgstr ""

#: Game.Levels.Iso
msgid "Iso"
msgstr ""

#. ยง0: `f`
#. ยง1: ``` โ b, โ a, f a = b ```
#: Game.Doc.Definition
msgid "A mapping ยง0 is surjectiv, if:\n"
"\n"
"ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Luna.L09_lt_trichotomy2
msgid "ยง0 Conclusion Luna L09"
msgstr ""

#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "Intro Samarkand L03"
msgstr ""

#. ยง0: `ring`
#: Game.Levels.Saturn.L02_Ring_add_pow_two
msgid "Conclusion Saturn L02: ยง0 could have been used as well"
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `โ a : A, P a`
#. ยง2: `a`
#. ยง3: `A`
#. ยง4: `A`
#. ยง5: `P a`
#. ยง6: `A`
#. ยง7: `โ a : A, true`
#. ยง8: `Nonempty A`
#. ยง9: `โ`
#. ยง10: `โ a : A, โฆ`
#. ยง11: `a`
#. ยง12: `use`
#. ยง13: `use a`
#. ยง14: `โ`
#. ยง15: `h : โ a : A, P a`
#. ยง16: `a : A`
#. ยง17: `ha : P a`
#. ยง18: `choose a ha using h`
#. ยง19: `obtain โจa, haโฉ := h`
#: Game.Doc.Definition
msgid "Existential quantifier: If ยง0 is a predicate, then ยง1 is the statement that an element ยง2 in ยง3 (more precisely: of type ยง4) exists for which the statement ยง5 is true. A pure existence statement (\"there is an element of type ยง6) can be formulated, for example, as ยง7 or as ยง8.\n"
"\n"
"## ยง9 as a proof goal\n"
"\n"
"To prove a statement of the form ยง10, you construct a suitable element ยง11 and then use the ยง12 tactic (ยง13).\n"
"\n"
"## ยง14 as an assumption\n"
"\n"
"You can decompose an assumption of the form ยง15 into its components ยง16 and ยง17 using ยง18 or ยง19."
msgstr ""

#. ยง0: `[a, b] โช \\{ b + 1 \\} = [a, b + 1]`
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "Goal: ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "ยง0 Intro Robotswana L08"
msgstr ""

#: Game.Levels.Mono.L08_RightInvOfLeftInv
msgid "Intro Mono L08"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L13_Or
msgid "ยง0 Intro Logo L13"
msgstr ""

#. ยง0: `Function.RightInverse f g`
#. ยง1: `LeftInverse g f`
#. ยง2: `โ x, g (f x) = x`
#. ยง3: `Function.RightInverse`
#. ยง4: `RightInverse`
#. ยง5: `RightInverse`
#: Game.Doc.Definition
msgid "ยง0 is defined as ยง1. In other words: ยง2.\n"
"\n"
"You have to write ยง3  instead of ยง4, as ยง5 is ambigous in Leanic."
msgstr ""

#. ยง0: `obtain`
#. ยง1: `x < y`
#. ยง2: `x = y`
#. ยง3: `x > y`
#. ยง4: ``` obtain h | h | h := lt_trichotomy x y ```
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "Wird typischerweise mit ยง0 verwendet, um in einem Beweis die drei Fรคlle ยง1, ยง2 und ยง3 zu unterscheiden:\n"
"\n"
"ยง4"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L04_Omega2
msgid "ยง0 Intro Luna L04"
msgstr ""

#: Game.Levels.Ciao.L01
msgid "Intro Ciao L01"
msgstr ""

#. ยง0: `1 ยซ{i}ยป ยซ{i}ยป`
#. ยง1: `1 โข _`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Explain simplification of ยง0 and ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Epo
msgid "ยง0 Intro Epo"
msgstr ""

#. ยง0: `by_contra h`
#. ยง1: `P`
#. ยง2: `by_contra h`
#. ยง3: `(h : ยฌ P)`
#. ยง4: `False`
#. ยง5: `contradiction`
#. ยง6: `A โ B`
#. ยง7: `contrapose`
#: Game.Doc.Tactic
msgid "The tactic ยง0 initiates a proof by contradiction. If ยง1 is your current proof goal, ยง2 generates a new assumption ยง3 and sets the proof goal to ยง4.\n"
"\n"
"## Friends and relatives\n"
"\n"
"* At the end of a proof by contradiction, there is usually ยง5: this tactic closes the proof when it finds two obviously contradictory assumptions. * If the proof goal is of the form ยง6, you can use ยง7 to start a proof by contraposition."
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `โ a : A, P a`
#. ยง2: `P a`
#. ยง3: `a`
#. ยง4: `A`
#. ยง5: `a`
#. ยง6: `A`
#. ยง7: `โ`
#. ยง8: `โ a : A, โฆ`
#. ยง9: `a`
#. ยง10: `intro a`
#. ยง11: `โ`
#. ยง12: `h : โ a : A, P a`
#. ยง13: `aโ : A`
#. ยง14: `h aโ`
#. ยง15: `P aโ`
#. ยง16: `specialize h aโ`
#. ยง17: `a`
#. ยง18: `h : P aโ`
#. ยง19: `aโ`
#: Game.Doc.Definition
msgid "Universal quantifier: If ยง0 is a predicate, then ยง1 is the statement that the statement ยง2 is true for all ยง3 in ยง4 (more precisely: for all ยง5 of type ยง6). ## ยง7 as a proof goal To prove a statement of the form ยง8, first select any element ยง9 with ยง10. ## ยง11 as an assumption If ยง12 is an assumption and ยง13 is a concrete element, then ยง14 is a notation for ยง15.\n"
"\n"
"You can also use ยง16 to restrict the given assumption over all possible ยง17 to an assumption ยง18 over this concrete ยง19."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus
msgid "ยง0 Intro Quantus"
msgstr ""

#: Game.Levels.Epo.L07_SurjectiveRightInverse
msgid "Intro Epo L07"
msgstr ""

#: Game.Levels.Implis.L01_Intro
msgid "Stroy"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L12_insert
msgid "ยง0 Intro Piazza L12"
msgstr ""

#. ยง0: `by_contra`
#: Game.Levels.Spinoza.L05_Contrapose
msgid "Intro Spinoza L05. prove without ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L06_not_even_iff_odd
msgid "ยง0 Intro Quantus L06"
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "Try `linarith"
msgstr ""

#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "Intro Mono L07"
msgstr ""

#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "Conclusion Luna L06"
msgstr ""

#. ยง0: `Odd n`
#. ยง1: `n : โ`
#. ยง2: ``` โ k : โ, n = 2 * k + 1 ```
#. ยง3: `unfold Odd`
#: Game.Doc.Definition
msgid "ยง0 is the statement that ยง1 is odd: ยง2 You can easily check this with ยง3."
msgstr ""

#. ยง0: `Icc a b`
#. ยง1: $[a,b]$
#: Game.Doc.Definition
msgid "ยง0 is the closed interval ยง1."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L08_PushNeg
msgid "ยง0 Intro Quanus L08"
msgstr ""

#. ยง0: `HasRightInverse f`
#. ยง1: `f`
#. ยง2: `HasLeftInverse f`
#. ยง3: `f`
#: Game.Doc.Definition
msgid "ยง0 means, that ยง1 has a right inverse.\n"
"\n"
"ยง2 means, that ยง3 has left inverse."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "ยง0 Conclusion Saturn L01"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "ยง0 Intro Quantus L02"
msgstr ""

#. ยง0: `simp`
#. ยง1: `ยซ{x}ยป โ ยซ{A}ยป โฉ ยซ{B}ยป โ ยซ{x}ยป โ ยซ{A}ยป โง ยซ{x}ยป โ ยซ{B}ยป`
#. ยง2: `ยซ{x}ยป โ ยซ{B}ยป โช ยซ{C}ยป โ ยซ{x}ยป โ ยซ{B}ยป โจ ยซ{x}ยป โ ยซ{C}ยป`
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "Explain what ยง0 does by using simplifications ยง1 and ยง2"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L05_Apply
msgid "ยง0 Conclusion Implis L05"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L02_Revert
msgid "ยง0 Conclusion Implis L02"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `T`
#. ยง2: `B`
#. ยง3: ``` f โปยน' T = { a | f a โ T} ```
#. ยง4: `f`
#. ยง5: `f \\-1'`
#. ยง6: `f`
#. ยง7: `\\-1'`
#: Game.Doc.Definition
msgid "For a mapping ยง0 and a subset ยง1 of ยง2, ยง3 is its preimage under ยง4. You write this as ยง5. Note the space between ยง6 and ยง7."
msgstr ""

#. ยง0: `induction n`
#. ยง1: `n`
#. ยง2: `induction n with d dh`
#. ยง3: `d`
#. ยง4: `hd`
#. ยง5: `n = 0`
#. ยง6: `hd`
#. ยง7: `induction`
#. ยง8: `induction'`
#. ยง9: `0`
#. ยง10: `Nat.zero`
#. ยง11: `d + 1`
#. ยง12: `Nat.succ d`
#. ยง13: `zero_eq`
#. ยง14: `Nat.succ_eq_add_one`
#: Game.Doc.Tactic
msgid "The tactic ยง0 performs an inductive proof over ยง1. With ยง2, you can specify names for the induction variable (here: ยง3) and the induction assumption (here: ยง4). The tactic thus replaces the original proof goal with two new proof goals: * an induction start, in which ยง5 is set, and * an induction step, in which the induction assumption ยง6 is available to you.\n"
"\n"
"## Modifications in this game\n"
"\n"
"Outside of this game, ยง7 is called ยง8, ยง9 is initially written as ยง10 and ยง11 as ยง12. These terms are identical in definition, but occasionally need to be explicitly rewritten with ยง13 and ยง14."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `โข A โง B`
#. ยง2: `โข A`
#. ยง3: `โข B`
#. ยง4: `โข A โ B`
#. ยง5: `โข A โ B`
#. ยง6: `โข B โ A`
#. ยง7: `obtain`
#. ยง8: `A โจ B`
#. ยง9: `left`
#. ยง10: `right`
#: Game.Doc.Tactic
msgid "The ยง0 tactic breaks down a proof goal into its constituent parts:\n"
"\n"
"| before | after                | |:------------ |:----------------------- | | ยง1    | ยง2 and ยง3         | | ยง4    | ยง5 and ยง6 |\n"
"\n"
"## Friends and relatives\n"
"\n"
"* You can break down an *assumption* into its components using ยง7. * If you want to prove ยง8, you have to choose one side using ยง9 or ยง10."
msgstr ""

#: Game.Levels.Vieta.L02_Function
msgid "Conclusion Vieta L02"
msgstr ""

#. ยง0: `obtain โจhโ, hโ , hโโฉ := h`
#: Game.Levels.Logo.L11_And
msgid "Conclusion Logo L11: Could have been written as ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L02_Revert
msgid "ยง0 Intro Implis L02"
msgstr ""

#: Game.Levels.Luna.L08_Omega3
msgid "Conclusion Luna L08"
msgstr ""

#: Game.Levels.Luna
msgid "Luna"
msgstr ""

#: Game.Levels.Epo
msgid "Epo"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L11_Linearity
msgid "ยง0 Conclusion Robotswana L11"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
msgid "ยง0 Conclusion Euklid L04"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "ยง0 Conclusion Mono L11"
msgstr ""

#. ยง0: `โ : Set T`
#. ยง1: `โ : Set โ`
#. ยง2: `โ : Set โ`
#. ยง3: `rw [eq_empty_iff_forall_not_mem]`
#. ยง4: `S = โ`
#. ยง5: `โ (x : T), x โ s`
#. ยง6: `โ`
#. ยง7: `\\emptyset`
#: Game.Doc.Definition
msgid "ยง0 is the empty subset. In the Formaloverse ยง1 is something different than ยง2 โ one is a subset of โ, the other is a subset of โ!\n"
"\n"
"With ยง3 you translate the equation ยง4 into the statement ยง5.\n"
"\n"
"ยง6 is written as ยง7."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "ยง0 Intro Samarkand L05"
msgstr ""

#. ยง0: `=`
#. ยง1: `โ`
#. ยง2: `rw`
#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "Explain that ยง0 and ยง1 with ยง2 can be used as in Implis"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `range f`
#. ยง2: `f`
#. ยง3: ``` range f = {f a | a : A} = {  b | โ a, f a = b} ```
#. ยง4: `f '' univ`
#. ยง5: `mem_range`
#. ยง6: ``` x โ range f โ โ a, f a = b ```
#: Game.Doc.Definition
msgid "For a mapping ยง0, ยง1 is the full image set of ยง2: ยง3 Is a diffierent notation for ยง4. ยง5 is useful to work with it: ยง6"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L03_sum_congr
msgid "ยง0 Intro Babylon L03"
msgstr ""

#. ยง0: `โ! a`
#. ยง1: `a`
#. ยง2: `use a`
#. ยง3: `simp`
#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "Try ยง0 to construct ยง1, Try ยง2, ยง3"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Prado.L10_EvenPrime
msgid "ยง0 Conclusion Prado L10"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Euklid.L01_prod_pos
msgid "ยง0 Intro Euklid L01"
msgstr ""

#. ยง0: `Goal`
#. ยง1: `funext x`
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "Explain ยง0. Try ยง1"
msgstr ""

#. ยง0: `โง`
#. ยง1: `obtain โจhโ, hโโฉ := h`
#. ยง2: `constructor`
#. ยง3: `โจ`
#. ยง4: `obtain h \\| h := h`
#. ยง5: `left`
#. ยง6: `right`
#: Game.Levels.Logo.L14_Summary
msgid "Intro Logo L14: The most important tactics of this chapter. For ยง0 it is ยง1 and ยง2. For ยง3 it is ยง4 and ยง5/ยง6"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L06_Not
msgid "ยง0 Conclusion Logo L06"
msgstr ""

#. ยง0: `diag`
#: Game.Levels.Mono.L04_Diagonal
msgid "Explain ยง0 1"
msgstr ""

#. ยง0: `intro`
#. ยง1: `A โ B`
#. ยง2: `โ x, P x`
#. ยง3: `A โ B`
#. ยง4: `intro h`
#. ยง5: `h : A`
#. ยง6: `B`
#. ยง7: `โ x, P x`
#. ยง8: `intro x`
#. ยง9: `x`
#. ยง10: `P x`
#. ยง11: `โ x, P x`
#. ยง12: `x`
#. ยง13: `intro x`
#. ยง14: `P x`
#. ยง15: `โข A โ B`
#. ยง16: `intro h`
#. ยง17: `h : A`
#. ยง18: `โข B`
#. ยง19: `โข  x, P x`
#. ยง20: `intro x hx`
#. ยง21: `x : X`
#. ยง22: `hx : P x`
#. ยง23: `โข P x`
#. ยง24: `revert h`
#. ยง25: `intro h`
#: Game.Doc.Tactic
msgid "The tactic ยง0 is used for proof goals of the form ยง1 or ยง2.\n"
"\n"
"If your proof goal is ยง3, ยง4 gives you the assumption ยง5, and you then have to prove ยง6. If your proof goal is ยง7, ยง8 gives you any ยง9, and you then have to prove ยง10. If your proof goal is ยง11, you specify any ยง12 with ยง13 and then have to prove ยง14.\n"
"\n"
"| before | tactic       | after                     | |:------------ |:------------ |:---------------------------- | | ยง15    | ยง16    | ยง17, ยง18               | | ยง19  | ยง20 | ยง21, ยง22, ยง23 |\n"
"\n"
"\n"
"## Friends and relatives\n"
"\n"
"The tactic ยง24 does the exact opposite of ยง25."
msgstr ""

#. ยง0: $ยซ{i}ยป=0$
#. ยง1: $ยซ{i}ยป=1$
#. ยง2: $ยซ{i}ยป=2$
#. ยง3: `have`
#: Game.Levels.Babylon.L04_sum_subset
msgid "Assumptions have to entail ยง0 or ยง1 or ยง2. Try ยง3"
msgstr ""

#: Game.Levels.Euklid
msgid "Euklid"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L02_Card2
msgid "ยง0 Intro Babylon L02"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "ยง0 Intro Samarkand L06"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L02_Rfl
msgid "ยง0 Conclusion Logo L02"
msgstr ""

#. ยง0: `Prime.dvd_mul`
#: Game.Levels.Prado.L07_dvd_mul
msgid "Intro Prado L07: Use lemma ยง0"
msgstr ""

#. ยง0: `rfl`
#. ยง1: `X = X`
#. ยง2: `rfl`
#. ยง3: `A = B`
#. ยง4: `A`
#. ยง5: `B`
#: Game.Doc.Tactic
msgid "The tactic ยง0 proves ยง1.  More precisely, ยง2 closes every proof target of the form ยง3, where ยง4 and ยง5 are identical in definition."
msgstr ""

#. ยง0: `obtain โจaโฉ := h`
#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "Explain Statement, Try ยง0"
msgstr ""

#. ยง0: `A โง B`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `A โง B`
#. ยง4: `constructor`
#. ยง5: `A`
#. ยง6: `B`
#. ยง7: `A โง B`
#. ยง8: `obtain โจhโ, hโโฉ := h`
#. ยง9: `h : A โง B`
#. ยง10: `hโ : A`
#. ยง11: `hโ : B`
#: Game.Doc.Definition
msgid "ยง0 (โandโ) is the statement that both ยง1 and ยง2 are true.\n"
"\n"
"## ยง3 as a proof goal\n"
"\n"
"The tactic ยง4 allows you to prove the two sub-statements ยง5 and ยง6 individually.\n"
"\n"
"## ยง7 as an assumption\n"
"\n"
"With ยง8, you break down an assumption of the form ยง9 into its components ยง10 and ยง11."
msgstr ""

#: Game.Levels.Prado.L10_EvenPrime
msgid "Remind former proof"
msgstr ""

#. ยง0: `โ`
#. ยง1: `โ`
#. ยง2: `ยซ{h}ยป`
#. ยง3: `simp`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Explain embedding of ยง0 in ยง1 via ยง2. Try ยง3"
msgstr ""

#. ยง0: `rw [eq_sum_apply_diag_ebasis]`
#. ยง1: `assumption`
#: Game.Levels.Robotswana.L10_Characterize
msgid "Remind missed argument with ยง0. Try ยง1"
msgstr ""

#. ยง0: `a`
#. ยง1: `a`
#. ยง2: ``` โ b : B, โ a : A, ( f a = b   โจ   ยฌ โ a' : A , f a' = b ) ```
#: Game.Levels.Mono.L10_Auxiliary
msgid "Be careful with interpreting goal as 'there is ยง0 or there is no ยง1'. Rewrite goal as ยง2"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "ยง0 Conclusion Robotswana L06"
msgstr ""

#. ยง0: `ยซ{f}ยป`
#. ยง1: `use`
#: Game.Levels.Vieta.L03_Let
msgid "If ยง0 correctly defind try ยง1"
msgstr ""

#. ยง0: `A : Set T`
#. ยง1: `Set.Finite A`
#. ยง2: `A`
#. ยง3: `h : Set.Finite A`
#. ยง4: `h.toFinset : Finset T`
#. ยง5: `A`
#: Game.Doc.Definition
msgid "For a subset ยง0, ยง1 means that ยง2 has only a finite number of elements. If ยง3 is given as an assumption, then ยง4 is the same subset ยง5, but now explicitly understood as a finite subset."
msgstr ""

#. ยง0: `โง`
#. ยง1: `constructor`
#: Game.Levels.Logo.L14_Summary
msgid "Approach ยง0 with ยง1"
msgstr ""

#. ยง0: `trans`
#. ยง1: `โข A = C`
#. ยง2: `trans B`
#. ยง3: `โข A = B`
#. ยง4: `โข B = C`
#. ยง5: `โข A โ C`
#. ยง6: `trans B`
#. ยง7: `โข A โ B`
#. ยง8: `โข B โ C`
#. ยง9: `A = Bโ = Bโ = Bโ ... = C`
#. ยง10: `calc`
#: Game.Doc.Tactic
msgid "With ยง0, you insert an intermediate step into an equation or equivalence.\n"
"\n"
"| before | tactic    | after                | |:------------ |:--------- |:----------------------- | | ยง1    | ยง2 | ยง3 and ยง4 | | ยง5    | ยง6 | ยง7 and ยง8 |\n"
"\n"
"Since you can repeat the tactic several times, it is suitable for performing a โcalculationโ ยง9 step by step.\n"
"\n"
"(Outside of the game, however, the multi-line tactic ยง10 is better suited for such calculations.)"
msgstr ""

#. ยง0: `matrix_eq_sum_ebasis A`
#. ยง1: `nth_rw 1`
#. ยง2: `rw`
#. ยง3: `rw [matrix_eq_sum_ebasis A]`
#. ยง4: `A`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Explain why to use ยง0 with ยง1 instead of ยง2. ยง3 replaces both ยง4"
msgstr ""

#. ยง0: `ยซ{n}ยป`
#. ยง1: `f E i i`
#. ยง2: `f E j j`
#. ยง3: `i`
#. ยง4: `j`
#. ยง5: `suffices h : n * f (E i i) = n * 1`
#. ยง6: `mul_eq_mul_left_iff`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Show calculation of ยง0th result of equation via former results. Explain that ยง1 = ยง2 for arbitrary ยง3 and ยง4. Try ยง5, ยง6"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L03_Let
msgid "ยง0 Intro Vieta L03"
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `โ! a : A, P a`
#. ยง2: `a`
#. ยง3: `A`
#. ยง4: `A`
#. ยง5: `P a`
#. ยง6: `a`
#. ยง7: `a`
#. ยง8: `โ!`
#. ยง9: `โ! a : A, โฆ`
#. ยง10: `a`
#. ยง11: `use`
#. ยง12: `use a`
#. ยง13: `simp`
#. ยง14: `P a โง โ a' : A, P a' โ a' = a`
#. ยง15: `P a`
#. ยง16: `a`
#. ยง17: `a`
#. ยง18: `โ!`
#. ยง19: `h : โ! a : A, P a`
#. ยง20: ``` obtain โจa, h_exists, h_uniqueโฉ := h simp at h_unique ```
#. ยง21: ``` a : A h_exists : P a h_unique : โ (y : A), P y โ y = a ```
#: Game.Doc.Definition
msgid "Existential quantifier: If ยง0 is a predicate, then ยง1 is the statement that *exactly one* element ยง2 in ยง3 (more precisely: of type ยง4) exists for which the statement ยง5 is true. The statement therefore has two parts: first, such an ยง6 exists, and second, ยง7 is unique. ## ยง8 as a proof goal\n"
"\n"
"To prove a statement of the form ยง9, first construct a suitable element ยง10 and then use the ยง11 tactic (ยง12), usually immediately followed by ยง13. The proof goal should then have the following form:\n"
"\n"
"ยง14\n"
"\n"
"On the left is ยง15: you still have to show that ยง16 has the required property. On the right is the uniqueness statement: every element with this property is equal to ยง17.\n"
"\n"
"## ยง18 as an assumption\n"
"\n"
"You can prove an assumption of the form ยง19 with\n"
"\n"
"ยง20 into its components ยง21 ."
msgstr ""

#. ยง0: `if 0 โค n then โฆ else โฆ`
#: Game.Levels.Vieta.L07_Extend
msgid "Try function with ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "ยง0 Conclusion Prado L02"
msgstr ""

#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "Intro Mono L09"
msgstr ""

#. ยง0: `by_cases h : 0 โค ยซ{x}ยป`
#. ยง1: `0 โค ยซ{x}ยป`
#. ยง2: `0 > ยซ{x}ยป`
#. ยง3: `0 โค ยซ{x}ยป`
#. ยง4: `ยฌ(0 โค ยซ{x}ยป)`
#. ยง5: `not_le`
#. ยง6: `ยฌ(0 โค ยซ{x}ยป)`
#. ยง7: `0 > ยซ{x}ยป`
#: Game.Levels.Vieta.L06_Piecewise
msgid "Try ยง0 for resulting cases ยง1 and ยง2 i.e. ยง3 and ยง4. Could switch via ยง5 between ยง6 and ยง7"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L08_Omega3
msgid "ยง0 Intro Luna L08"
msgstr ""

#: Game.Levels.Vieta.L05_Funext
msgid "Conclusion Vieta L05"
msgstr ""

#. ยง0: `, `
#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
msgid "Try subset_iffยง0simp`"
msgstr ""

#: Game.Levels.Babylon.L04_sum_subset
msgid "Show that term in sum is zero for first three indexes"
msgstr ""

#. ยง0: `suffices h : P`
#. ยง1: `P`
#. ยง2: `P`
#. ยง3: `have h : P`
#. ยง4: `P`
#: Game.Doc.Tactic
msgid "With ยง0, you introduce a proof section in which you show that the desired proof goal follows from ยง1. Then you prove ยง2.\n"
"\n"
"## Friends and relatives ยง3 works the same way, except that you must first prove ยง4 before you can continue with the main proof."
msgstr ""

#. ยง0: `2`
#: Game.Levels.Prado.L01_prime_two
msgid "Conclusion Prado L01: Present ยง0 as prime number"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L10_And
msgid "ยง0 Intro Logo L10"
msgstr ""

#. ยง0: `INTRO-1`
#: Game.Levels.Cantor.L09_CantorDiag
msgid "ยง0Intro Cantor L09 - 1"
msgstr ""

#: Game.Levels.Ciao
msgid "Ciao"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Mono.L01_Injective
msgid "ยง0 Conclusion Mono L01"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Saturn.L03_mul_comm
msgid "ยง0 Conclusion Saturn L03"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L09_Contradiction
msgid "ยง0 Intro Logo L09"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#. ยง0: `fun x โฆ _`
#. ยง1: `fun (x : โค) โฆ  -x`
#. ยง2: `โค โ โค`
#. ยง3: `โฆ`
#. ยง4: `\\maps`
#. ยง5: `\\mapsto`
#. ยง6: `=>`
#. ยง7: `โฆ`
#: Game.Doc.Definition
msgid "The notation ยง0 is used to define โanonymous functions.โ For example, ยง1 defines the negation ยง2 without giving it a name. You write the arrow ยง3 as ยง4 or ยง5. Alternatively, you can use ยง6 instead of ยง7."
msgstr ""

#. ยง0: `Surjective f`
#. ยง1: `f`
#. ยง2: `unfold Surjective`
#. ยง3: `unfold Surjective at h`
#: Game.Levels.Epo.L01_Surjective
msgid "ยง0 bedeutet naheliegenderweise, dass die Abbildung ยง1 surjektiv ist. Mit ยง2 (bzw. ยง3) kann man leicht nachsehen, was das in Quantorenschreibweise konkret bedeutet."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Babylon.L01_Sum_Simp_Card
msgid "ยง0 Conclusion Babylon L01"
msgstr ""

#. ยง0: `Surjective f`
#. ยง1: `โ y, (โ x, f x = y)`
#. ยง2: `unfold Surjective`
#: Game.Levels.Epo.L01_Surjective
msgid "Confirm that ยง0 is defined as ยง1 via ยง2"
msgstr ""

#. ยง0: `obtain`
#. ยง1: `ยซ{h}ยป`
#: Game.Levels.Quantus.L10_DrinkersParadox
#: Game.Levels.Mono.L06_StrictMono
msgid "Try ยง0 on ยง1"
msgstr ""

#. ยง0: $$\\sum_{i=0}^{n} (i^3 - 3 i^2 + 2 i)  = \\sum_{i=3}^{n} (i^3 - 3 i^2 + 2i)$$
#. ยง1: $0$
#. ยง2: $i$
#. ยง3: `sum_subset`
#. ยง4: `Iโ โ Iโ`
#. ยง5: `Iโ`
#. ยง6: `Iโ`
#. ยง7: `Iโ`
#. ยง8: `Iโ`
#: Game.Levels.Babylon.L04_sum_subset
msgid "Remind goal ยง0 with ยง1 for the value in the sum for fist three ยง2. Try ยง3: If ยง4 and term is disappearing for all elements in ยง5 not in ยง6, then the sum over ยง7 equals sum over ยง8"
msgstr ""

#. ยง0: `if_pos ยซ{hโ}ยป`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Try ยง0."
msgstr ""

#. ยง0: `(h : A โง B)`
#. ยง1: `h.left`
#. ยง2: `h.right`
#. ยง3: `(h : A โ B)`
#. ยง4: `h.mp`
#. ยง5: `h.mpr`
#. ยง6: `h.mp`
#. ยง7: `A โ B`
#. ยง8: `mp`
#. ยง9: `mp`
#. ยง10: `mpr`
#: Game.Levels.Implis.L06_Iff
msgid "Conclusion Implis L06: Explain that analogous to ยง0 with ยง1 and ยง2, ยง3 has ยง4 and ยง5. ยง6 can be understood as ยง7. It is ยง8 as ยง9 stands for Modens Ponens. The 'r' in ยง10 stands for 'reverse'."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L04_Apply
msgid "ยง0 Intro Implis L04"
msgstr ""

#. ยง0: `f`
#. ยง1: `โค`
#. ยง2: `โ`
#. ยง3: `f n`
#. ยง4: `f (n)`
#: Game.Levels.Vieta.L01_FunctionNotation
msgid "Explain ยง0 as mapping from ยง1 to ยง2. Explain notations ยง3 and ยง4"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L04_Exists
msgid "ยง0 Conclusion Quantus L04"
msgstr ""

#: Game.Levels.Piazza.L02_Simp
msgid "Conclusion Piazza L02"
msgstr ""

#. ยง0: `ring`
#. ยง1: `ยซ{f}ยป`
#: Game.Levels.Vieta.L04_Let
msgid "Try ยง0 as it sees through defintion ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L01_Intro
msgid "ยง0 Conclusion Implis L01"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L08_Contradiction
msgid "ยง0 Conclusion Logo L08"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "ยง0 Intro Luna L03"
msgstr ""

#. ยง0: `tauto`
#: Game.Levels.Implis.L14_Summary
#: Game.Levels.Implis.L14_Summary
msgid "Oft kann auch ยง0 diese Art von logischen Ausdrรผcken lรถsen."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L02_ImageMap
msgid "ยง0 Conclusions Samarkand L02"
msgstr ""

#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid "Conclusion Babylon L07"
msgstr ""

#. ยง0: `(f โ g) x`
#. ยง1: `f (g x)`
#: Game.Levels.Vieta.L04_Let
msgid "Sagt dass ยง0 das gleiche ist wie ยง1."
msgstr ""

#. ยง0: `Odd (n ^ 2)`
#: Game.Levels.Spinoza.L06_Summary
msgid "Derive contradiction for ยง0"
msgstr ""

#. ยง0: `rw [subset_iff] at *`
#. ยง1: `A`
#. ยง2: `C`
#. ยง3: `intro a`
#: Game.Levels.Piazza.L09_subset_iff2
msgid "Try ยง0, show that element in ยง1 is also in ยง2 via ยง3"
msgstr ""

#. ยง0: `ยซ{g}ยป`
#: Game.Levels.Spinoza.L02_Suffices
msgid "End proof with assumption that ยง0 is true"
msgstr ""

#. ยง0: `even_square`
#. ยง1: `Odd (n^2) โ Odd n`
#. ยง2: `Even n โ Even (n^2)`
#. ยง3: `โ`
#. ยง4: `revert`
#. ยง5: `revert ยซ{h}ยป`
#. ยง6: `ยซ{h}ยป`
#: Game.Levels.Spinoza.L05_Contrapose
msgid "Refer back to ยง0 as ยง1 is equivalent in contrapoition to ยง2. Explain lack of  ยง3 can be dealt with ยง4 with ยง5 for ยง6."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L02_ImageMap
msgid "ยง0 Intro Samarkand L02"
msgstr ""

#. ยง0: `decide`
#. ยง1: `decide`
#: Game.Levels.Logo.L05_True
msgid "Conclusion Logo L05: ยง0 cannot be used every time. ยง1 works only in special cases"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Spinoza.L01_Have
msgid "ยง0 Conclusion Spinoza L01"
msgstr ""

#. ยง0: `rw [sum_insert]`
#: Game.Levels.Babylon.L07_Induction2_sum_insert2
#: Game.Levels.Iso.L02_Inverse
msgid "ยง0"
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `obtain`
#: Game.Levels.Mono.L10_Auxiliary
msgid "Known that there exists some element in ยง0. Try ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Epo.L07_SurjectiveRightInverse
msgid "ยง0 Conclusion Epo L07"
msgstr ""

#. ยง0: `1`
#. ยง1: `matrix_eq_sum_ebasis`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Intro Robotswana L05: ยง0 indicates unit matrix. Begin with ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Saturn
msgid "ยง0 Intro Saturn"
msgstr ""

#. ยง0: `1`
#. ยง1: `1 ยซ{i}ยป j`
#. ยง2: `j โ ยซ{i}ยป`
#. ยง3: `j = ยซ{i}ยป`
#. ยง4: `have h : {ยซ{i}ยป} โ univ`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Explain ยง0 and values of ยง1 for all ยง2 i.e. ยง3. Try ยง4"
msgstr ""

#: Game.Levels.Mono.L02_InjectiveNeIff
msgid "Intro Mono L02"
msgstr ""

#: Game.Levels.Quantus.L04_Exists
msgid "Das Quadrat einer geraden Zahl ist gerade."
msgstr ""

#: Game.Levels.Robotswana.L11_Linearity
msgid "Explain statement"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L09_PushNeg
msgid "ยง0 Intro Quantus L09"
msgstr ""

#. ยง0: `univ`
#. ยง1: `โ`
#. ยง2: `rw [eq_univ_iff_forall]`
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "Explain differnece between ยง0 and ยง1. Try ยง2"
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "Goal is in assumptions"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L10_Characterize
msgid "ยง0 Conclusion Robotswana L10"
msgstr ""

#. ยง0: `g`
#. ยง1: `use`
#: Game.Levels.Vieta.L07_Extend
msgid "Insert ยง0 via ยง1"
msgstr ""

#. ยง0: `(ยซ{A}ยป โง ยซ{B}ยป) โจ ยซ{A}ยป`
#. ยง1: `ยซ{A}ยป`
#: Game.Levels.Logo.L13_Or
msgid "Show goal via ยง0 i.e. assume ยง1 is true"
msgstr ""

#. ยง0: `ยฌ A`
#. ยง1: `A`
#. ยง2: `A โ False`
#. ยง3: `push_neg`
#. ยง4: `by_contra`
#. ยง5: `contrapose`
#. ยง6: `h : ยฌ A`
#. ยง7: `False`
#. ยง8: `apply`
#: Game.Doc.Definition
msgid "ยง0 is the logical negation of ยง1. It is implemented internally as ยง2.\n"
"\n"
"Useful tactics are: ยง3, ยง4, ยง5. You can also apply an assumption of the form ยง6 to the proof target ยง7 using ยง8."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Iso
msgid "ยง0 Intro Iso"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L06_Piecewise
msgid "ยง0 Intro Vieta L06"
msgstr ""

#: Game.Levels.Vieta.L09_CongrFun
msgid "Conclusion Vieta L09"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Prado.L07_dvd_mul
msgid "ยง0 conclusion Prado L07"
msgstr ""

#: Game.Levels.Cantor
msgid "Cantor"
msgstr ""

#. ยง0: `have h : P`
#. ยง1: `suffices h : P`
#: Game.Doc.Tactic
msgid "With ยง0, you introduce an intermediate result. You must then prove this intermediate result before you can continue with the actual proof.\n"
"\n"
"## Friends and relatives ยง1 works in exactly the same way, except that you can continue with the main proof first and only have to prove your intermediate result at the very end."
msgstr ""

#. ยง0: `specialize h aโ aโ`
#. ยง1: `have h := h aโ aโ`
#. ยง2: `h : โ mโ mโ, P mโ mโ`
#. ยง3: `h : P aโ aโ`
#. ยง4: `have`
#. ยง5: `specialize`
#. ยง6: `specialize h โฆ`
#. ยง7: `h`
#. ยง8: `h`
#. ยง9: ``` have ha := h aโ aโ have hb := h bโ bโ ```
#. ยง10: ``` h : โ mโ mโ, P mโ mโ ha : P aโ aโ hb : P bโ bโ ```
#: Game.Doc.Tactic
msgid "ยง0 is equivalent to ยง1: the tactic replaces an assumption ยง2 with the special case ยง3.\n"
"\n"
"If you want to specialize multiple times, you should use ยง4 instead of ยง5, since ยง6 overwrites the old assumption ยง7. From the above assumption ยง8, you can obtain the following three assumptions with ยง9 : ยง10"
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "Intro Mono L11"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L07_Extend
msgid "ยง0 Intro Vieta L07"
msgstr ""

#. ยง0: `I : Finset T`
#. ยง1: `โ i โ I, f i`
#. ยง2: $\\prod_{i\\in I} f(i)$
#. ยง3: `\\prod`
#: Game.Doc.Definition
msgid "For a finite index set ยง0, ยง1 is the Leanic notation for the product ยง2.  You write the product symbol as ยง3."
msgstr ""

#. ยง0: `omega`
#: Game.Levels.Luna.L07_Linarith2
msgid "Intro Luna L07: Enough of ยง0"
msgstr ""

#. ยง0: ` into `
#. ยง1: ` to show triviality because there is no `
#. ยง2: ` in `
#. ยง3: `. Try `
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Put ยซ{h}ยป : ยซ{n}ยป = 0ยง0ยซ{i}ยป : Fin ยซ{n}ยปยง1ยซ{i}ยปยง2Fin 0ยง3simp [ยซ{h}ยป] at ยซ{i}ยป`"
msgstr ""

#: Game.Levels.Mono
msgid "Mono"
msgstr ""

#. ยง0: `f (E i i) = 1`
#. ยง1: `one_on_diag_ebasis`
#: Game.Levels.Robotswana.L10_Characterize
msgid "Remind former result for ยง0. Try ยง1"
msgstr ""

#. ยง0: `True : Prop`
#. ยง1: `True`
#. ยง2: `tauto`
#. ยง3: `decide`
#. ยง4: `True`
#. ยง5: `True`
#. ยง6: `True`
#: Game.Doc.Definition
msgid "The statement ยง0 is always true.\n"
"\n"
"## ยง1 as a proof target\n"
"\n"
"The tactics ยง2 and ยง3 conclude every proof with ยง4 as the proof target.\n"
"\n"
"## ยง5 as an assumption\n"
"\n"
"As an assumption, ยง6 is not helpful at all."
msgstr ""

#. ยง0: `ring`
#. ยง1: `+, -, *, ^`
#: Game.Doc.Tactic
msgid "The ยง0 tactic proves equations with the operations ยง1 in semirings, in particular in โ, โค, โ, โ, โฆ   It works particularly well in commutative rings."
msgstr ""

#. ยง0: `have`
#. ยง1: `suffices`
#: Game.Levels.Spinoza.L02_Suffices
msgid "Conclusion Spinoza L02: The use of ยง0 or ยง1 is up to personal preference."
msgstr ""

#. ยง0: `not_imp_not`
#: Game.Levels.Spinoza.L04_ByContra
msgid "Intro Spinoza L04: introduce contraposition equivalence with ยง0"
msgstr ""

#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid "Conclusion Piazza L05"
msgstr ""

#: Game.Levels.Saturn.L05_Ring
msgid "Intro Saturn L05"
msgstr ""

#. ยง0: `Even n`
#. ยง1: `n : โ`
#. ยง2: ``` โ r : โ, n = r + r ```
#. ยง3: `unfold Even`
#: Game.Doc.Definition
msgid "ยง0 is the statement that ยง1 is even: ยง2 You can easily check this with ยง3."
msgstr ""

#. ยง0: `ยซ{i}ยป = ยซ{j}ยป`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Prove by cases for ยง0"
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `ยซ{B}ยป`
#: Game.Levels.Piazza.L07_antisymm_iff
msgid "Try replacing ยง0 by ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L08_Rw
msgid "ยง0 Conclusion Implis L08"
msgstr ""

#. ยง0: `ยซ{A}ยป โง ยซ{B}ยป`
#. ยง1: `ยซ{A}ยป`
#: Game.Levels.Logo.L13_Or
msgid "Prove goal once for ยง0 and once for ยง1"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `preimage f : Set B โ Set A`
#. ยง2: `B`
#. ยง3: `f โปยน' A`
#. ยง4: `f`
#: Game.Doc.Definition
msgid "For a mapping ยง0, ยง1 is one of the induced mappings on the power sets โ it maps a subset of ยง2 to the preimage ยง3 of this subset under ยง4."
msgstr ""

#. ยง0: ``` def Even (n : โ) : Prop := โ r, n = r + r ```
#. ยง1: `Odd`
#: Game.Levels.Quantus.L03_Decide
msgid "Intro Quantus L03: Show defintion ยง0 before introducing ยง1"
msgstr ""

#. ยง0: `apply`
#. ยง1: ``` lemma not_not (A : Prop) : ยฌยฌA โ A ```
#: Game.Levels.Implis.L13_Rw
msgid "Intro Implis L13: Do not use ยง0. Try it with ยง1"
msgstr ""

#: Game
msgid "Intro Game"
msgstr ""

#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "Conclusion Piazza L03"
msgstr ""

#: Game.Levels.Implis
msgid "Implis"
msgstr ""

#: Game.Levels.Logo.L04_Assumption
#: Game.Levels.Implis.L02_Revert
#: Game.Levels.Implis.L03_Apply
#: Game.Levels.Implis.L04_Apply
#: Game.Levels.Implis.L04_Apply
#: Game.Levels.Implis.L06_Iff
#: Game.Levels.Spinoza.L01_Have
#: Game.Levels.Cantor.L02_CantorPowerset
#: Game.Levels.Cantor.L02_CantorPowerset
#: Game.Levels.Cantor.L03_IsFixedPt_abs
#: Game.Levels.Cantor.L03_IsFixedPt_abs
#: Game.Levels.Cantor.L05_IsFixedPt_not
#: Game.Levels.Cantor.L06_IsFixedPt_odd
#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
#: Game.Levels.Cantor.L09_CantorDiag
#: Game.Levels.Cantor.L10_CantorPowerset
#: Game.Levels.Robotswana.L02_EBasis
#: Game.Levels.Robotswana.L03
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Euklid.L01_prod_pos
#: Game.Levels.Euklid.L02_prod_insert
#: Game.Levels.Epo.L02_CurrySurjective
#: Game.Levels.Epo.L04_RightInverse
#: Game.Levels.Mono.L03_NotInjective
#: Game.Levels.Mono.L05_StrictMono
#: Game.Levels.Mono.L11_InjHasLeftInv
#: Game.Levels.Samarkand.L07_LeftInvPreimage
#: Game.Levels.Iso.L01_Bijective
#: Game.Levels.Iso.L02_Inverse
msgid "Story"
msgstr ""

#: Game.Levels.Samarkand.L02_ImageMap
msgid "Try simplification"
msgstr ""

#. ยง0: `f : A โ A`
#. ยง1: `fixedPoints f : Set A`
#. ยง2: `f `
#. ยง3: `unfold fixedPoints`
#: Game.Doc.Definition
msgid "For a mapping ยง0, ยง1 is the set of fixed points of ยง2. Look up definition with ยง3."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L01_Tauto
msgid "ยง0 Intro Logo L01"
msgstr ""

#. ยง0: `omega`
#. ยง1: `omega`
#. ยง2: `omega`
#: Game.Levels.Luna.L02_Omega
msgid "Conclusion Luna L02: ยง0 is popular, even though ยง1 is quiet useless. ยง2 is only really applicable over integers."
msgstr ""

#: Game.Levels.Mono.L10_Auxiliary
msgid "Intro Mono L10"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Piazza.L01_Mem__Set
msgid "ยง0 Conclusion Piazza L01"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L07_Forall
msgid "ยง0 Conclusion Quantus L07"
msgstr ""

#. ยง0: `use`
#: Game.Levels.Mono.L03_NotInjective
msgid "Try ยง0 with two numbers"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Use linearity"
msgstr ""

#. ยง0: `trans`
#. ยง1: `trans โ j : Fin ยซ{n}ยป, f (E i i)`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Try ยง0 several times. Start with ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L08_CongrArg
msgid "ยง0 Intro Vieta L08"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `S`
#. ยง3: `A B : Set S`
#. ยง4: `A โฉ B`
#. ยง5: `โฉ`
#. ยง6: `\\inter`
#: Game.Doc.Definition
msgid "For two subsets ยง0 and ยง1 of ยง2 (i.e. ยง3), ยง4 is their intersection. ยง5 is written as ยง6."
msgstr ""

#. ยง0: `I : Finset T`
#. ยง1: `โ i โ I, f i`
#. ยง2: $\\sum_{i\\in I} f(i)$
#. ยง3: `\\sum`
#: Game.Doc.Definition
msgid "For a finite index set ยง0, ยง1 is Leanic notation for the sum ยง2.  You write the summation sign as ยง3."
msgstr ""

#: Game.Levels.Cantor.L07_idempotent
msgid "Intro Cantor L07"
msgstr ""

#. ยง0: `P`
#. ยง1: `Fin 2`
#. ยง2: `โ`
#. ยง3: `Fin 2`
#. ยง4: `X 0`
#. ยง5: `X 1`
#: Game.Levels.Saturn.L03_mul_comm
msgid "Explain ยง0 with ยง1 and ยง2. Explain ยง3 with elements ยง4 and ยง5"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L01_FunctionNotation
msgid "ยง0 Intro Vieta L01"
msgstr ""

#: Game.Levels.Luna.L05_Linarith2
msgid "Conclusion Luna L05"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L01_NonemptyUse
msgid "ยง0 Intro Quantus L01"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "ยง0 Intro Samarkand L04"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "Jede strikt monotone Abbildung (zwischen geeigneten Definitions- und Wertebereichen) ist injektiv."
msgstr ""

#. ยง0: `have`
#. ยง1: `have g : ยฌ B`
#: Game.Levels.Spinoza.L01_Have
msgid "Try ยง0 in form of ยง1"
msgstr ""

#: Game.Levels.Mono.L11_InjHasLeftInv
msgid "Comment: Remember proof"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L03_Assumption
msgid "ยง0 Conclusion Logo L03"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Iso.L02_Inverse
msgid "ยง0 Intro Iso L02"
msgstr ""

#. ยง0: `diag`
#: Game.Levels.Mono.L04_Diagonal
msgid "Explain ยง0 2"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid "ยง0Conclusion Cantor L04"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo
msgid "ยง0 Intro Logo"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "ยง0 Intro Samarkand L08"
msgstr ""

#: Game
msgid "Conclusion Game"
msgstr ""

#. ยง0: `A โ B`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `โ`
#. ยง4: `A โ B`
#. ยง5: `constructor`
#. ยง6: `A โ B`
#. ยง7: `B โ A`
#. ยง8: `โ`
#. ยง9: `h : A โ B`
#. ยง10: `hโ : A โ B`
#. ยง11: `hโ : B โ A`
#. ยง12: `obtain โจhโ, hโโฉ := h`
#. ยง13: `h.mp`
#. ยง14: `h.mpr`
#. ยง15: `mp`
#: Game.Doc.Definition
msgid "ยง0 means that statements ยง1 and ยง2 are logically equivalent (โif and only ifโ).\n"
"\n"
"## ยง3 as proof target\n"
"\n"
"To show ยง4, you can, for example, call ยง5 and then prove ยง6 and ยง7 separately.\n"
"\n"
"## ยง8 as an assumption\n"
"\n"
"You can break down an assumption of the form ยง9 into its two components ยง10 and ยง11 using ยง12. However, you can also refer directly to these components with ยง13 and ยง14. (The abbreviation ยง15 stands for โmodus ponensโ.)"
msgstr ""

#. ยง0: `x : โ`
#. ยง1: `|x|`
#. ยง2: `x`
#. ยง3: `|`
#: Game.Doc.Definition
msgid "For ยง0, ยง1 is the absolute value of ยง2. (Here, ยง3 is the usual vertical bar on the keyboard.)"
msgstr ""

#. ยง0: `constructor`
#. ยง1: `unfold Surjective`
#. ยง2: `push_neg`
#: Game.Levels.Epo.L02_CurrySurjective
msgid "Try ยง0 | ยง1, ยง2"
msgstr ""

#. ยง0: `have`
#. ยง1: `suffices`
#. ยง2: `by_contra`
#. ยง3: `contradiction`
#. ยง4: `contrapose`
#. ยง5: `revert`
#. ยง6: `contrapose`
#: Game.Levels.Spinoza.L06_Summary
msgid "Conclusion Spinoza L06: overview of planet's contents: ยง0, ยง1, ยง2, ยง3, ยง4, ยง5 (useful when applying ยง6 afterwards)."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L01_prime_two
msgid "ยง0 Intro Prado L01"
msgstr ""

#. ยง0: `tauto`
#. ยง1: `generalize`
#. ยง2: `tauto`
#: Game.Doc.Tactic
msgid "The tactic ยง0 proves logical tautologies.\n"
"\n"
"# Friends and relatives\n"
"\n"
"Sometimes the proof target must first be abstracted with ยง1 so that ยง2 recognizes the tautology."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Spinoza.L06_Summary
msgid "ยง0 Intro Spinoza L06"
msgstr ""

#. ยง0: `a โฃ b`
#. ยง1: `โ k, b = a * k`
#. ยง2: `โฃ`
#. ยง3: `\\dvd`
#. ยง4: `|`
#. ยง5: `obtain hโ | hโ := h`
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "ยง0 bedeutet ยง1.\n"
"\n"
"**Warnung**: Die Symbole ยง2 (ยง3) und ยง4 (ASCII vertikaler Strich) sind zwei unterschiedliche Zeichen! Das erste wird ausschlieรlich fรผr โteiltโ verwendet, das andere kommt zum Beispiel in der Syntax ยง5 vor."
msgstr ""

#. ยง0: `rw`
#. ยง1: `apply`
#: Game.Levels.Implis.L11_Iff
msgid "Intro Implis L11: Prove without using ยง0 or ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
msgid "ยง0 Conclusion Euklid L03"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado
msgid "ยง0 Intro Prado"
msgstr ""

#. ยง0: `โ`
#: Game.Levels.Implis.L14_Summary
msgid "Remind that ยง0 in this case is equivalence"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L06_Iff
msgid "ยง0 Intro Implis L06"
msgstr ""

#. ยง0: `by_cases`
#. ยง1: `ยซ{b}ยป`
#: Game.Levels.Mono.L10_Auxiliary
msgid "Try ยง0 to see if ยง1 has preimage"
msgstr ""

#. ยง0: `StrictMono.injective`
#: Game.Levels.Mono.L06_StrictMono
msgid "Intro Mono L06: Prove ยง0"
msgstr ""

#: Game.Levels.Babylon.L09_Boss
#: Game.Levels.Cantor.L01_CantorPowerset
#: Game.Levels.Cantor.L01_CantorPowerset
#: Game.Levels.Cantor.L01_CantorPowerset
#: Game.Levels.Mono.L05_StrictMono
#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "Comment"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Lineare Abbildungen (oder genereller \"additive\" Abbildungen) kann man mit einer Summe vertauschen."
msgstr ""

#. ยง0: `โ`
#. ยง1: `0, 1, 2, โฆ`
#. ยง2: `=`
#. ยง3: `โ`
#. ยง4: `ยฌ(ยท=ยท)`
#. ยง5: `Prop`
#. ยง6: `True`
#. ยง7: `(True : Prop)`
#. ยง8: `False`
#. ยง9: `(False : Prop)`
#. ยง10: `ยฌ`
#. ยง11: `โง`
#. ยง12: `โจ`
#. ยง13: `(n : โ)`
#. ยง14: `(A : Prop)`
#. ยง15: `(ha : A)`
#. ยง16: `(A : Prop)`
#. ยง17: `(h : A โง B)`
#. ยง18: `h`
#. ยง19: `rfl`
#. ยง20: `A = A`
#. ยง21: `assumption`
#. ยง22: `contradiction`
#. ยง23: `decide`
#. ยง24: `constructor`
#. ยง25: `left`
#. ยง26: `right`
#. ยง27: `obtain โจhโ, hโโฉ := h`
#. ยง28: `obtain h := h \\| h`
#: Game.Levels.Logo.L13_Or
msgid "Conclusion Logo L13: Notations introdced so far: ยง0, ยง1, ยง2, ยง3 (shorthand for ยง4), ยง5, ยง6 (ยง7 is always true), ยง8 (ยง9 is always false), ยง10, ยง11, ยง12, ยง13, ยง14, ยง15 (Proof that ยง16 is true), ยง17 (Assumption with name ยง18). Tactics introduced so far: ยง19 (proves ยง20), ยง21, ยง22, ยง23, ยง24, ยง25/ยง26, ยง27, ยง28"
msgstr ""

#. ยง0: `apply lt_trichotomy`
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
msgid "Conclusion Luna L03: Alternatively ยง0 could have been used."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "ยง0 Intro Robotswana L09"
msgstr ""

#. ยง0: `tauto`
#. ยง1: `simp`
#: Game.Levels.Implis.L13_Rw
msgid "Statt dieser Aussage kรถnnen oft auch die Taktiken ยง0 oder ยง1 verwendet werden."
msgstr ""

#. ยง0: `A : Set T`
#. ยง1: `A`
#. ยง2: `T`
#. ยง3: `A`
#. ยง4: `T`
#: Game.Doc.Definition
msgid "ยง0 means that ยง1 is a subset of ยง2 (or, more precisely, that ยง3 is a set consisting of elements of type ยง4)."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L03
msgid "ยง0 Conclusion Robotswana L03"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "ยง0 Conclusion Robotswana L05"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
msgid "ยง0 Intro Prado L05"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
msgid "ยง0 Intro Luna L06"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L02_NonemptyObtain
msgid "ยง0 Conclusion Quantus L02"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Saturn.L03_mul_comm
msgid "ยง0 Intro Saturn L03"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "ยง0 Conclusion Samarkand L04"
msgstr ""

#. ยง0: `decide`
#. ยง1: `True`
#. ยง2: `Even 4`
#. ยง3: `2 โค 5`
#. ยง4: `4 โ 6`
#. ยง5: `Prime 7`
#: Game.Doc.Tactic
msgid "With ยง0, you can prove statements that can be decided using a simple algorithm. These include, in particular, ยง1 and statements about concrete numbers such as: - ยง2 - ยง3 - ยง4 - ยง5"
msgstr ""

#. ยง0: `revert h`
#. ยง1: `h`
#. ยง2: `h : A`
#. ยง3: `โข B`
#. ยง4: `โข A โ B`
#. ยง5: `intro h`
#. ยง6: `revert h`
#: Game.Doc.Tactic
msgid "The tactic ยง0 adds the assumption ยง1 as an implication premise to the proof goal: from ยง2 and ยง3, we get ยง4.\n"
"\n"
"## Friends and relatives\n"
"\n"
"The tactic ยง5 does the exact opposite of ยง6."
msgstr ""

#: Game.Levels.Mono.L08_RightInvOfLeftInv
#: Game.Levels.Mono.L09_InjOfHasLeftInv
msgid "Explain"
msgstr ""

#. ยง0: `โ`
#. ยง1: `โ`
#. ยง2: `ring`
#: Game.Levels.Saturn.L04_mul_assoc
msgid "Conclusion Saturn L04: coefficients were in ยง0. Polynomes with coefficients in ยง1 are not considered rings. ยง2 does also work on half rings."
msgstr ""

#: Game.Levels.Saturn
msgid "Saturn"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L07_LeftInvPreimage
msgid "ยง0 Intro Samarkand L07"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Luna.L01_le_rfl
msgid "ยง0 Conclusion Luna L01"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L12_Or
msgid "ยง0 Intro Logo L12"
msgstr ""

#. ยง0: `StrictMono.injective`
#. ยง1: ` | `
#: Game.Levels.Mono.L05_StrictMono
msgid "Try ยง0 | StrictMono.addยง1Odd.strictMono_pow`"
msgstr ""

#: Game.Levels.Implis.L11_Iff
msgid "Start with implication"
msgstr ""

#. ยง0: `obtain โจโฉ := ยซ{h}ยป`
#: Game.Levels.Logo.L14_Summary
msgid "Divide assumption ยซ{h}ยป using ยง0"
msgstr ""

#. ยง0: `univ : Set T`
#. ยง1: `T`
#. ยง2: `rw [eq_univ_iff_forall]`
#. ยง3: `S = univ`
#. ยง4: `โ (x : T), x โ S`
#: Game.Doc.Definition
msgid "ยง0 is the โsubsetโ consisting of *all* elements of type ยง1.\n"
"\n"
"With ยง2, you convert an equation of the form ยง3 into the statement ยง4."
msgstr ""

#: Game.Levels.Robotswana.L10_Characterize
msgid "Observe equality"
msgstr ""

#. ยง0: `โง`
#: Game.Levels.Spinoza.L01_Have
msgid "Try to split ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L12_Or
msgid "ยง0 Conclusion Logo L12"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L06_Ext2__univ2
msgid "ยง0 Intro Piazza L06"
msgstr ""

#. ยง0: `simp`
#. ยง1: `ยซ{h}ยป`
#: Game.Levels.Robotswana.L02_EBasis
msgid "Try ยง0 with ยง1"
msgstr ""

#. ยง0: `simp`
#. ยง1: `omega`
#: Game.Levels.Babylon.L04_sum_subset
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "Try ยง0 & ยง1"
msgstr ""

#. ยง0: `f`
#. ยง1: `g`
#. ยง2: `f + g`
#: Game.Levels.Mono.L05_StrictMono
msgid "Sind ยง0 und ยง1 beide strikt monoton sind, so ist auch ยง2 strikt momonton."
msgstr ""

#. ยง0: `โ`
#: Game.Levels.Vieta.L10_Surjective
msgid "Remind of induction as mapping goes to ยง0"
msgstr ""

#. ยง0: `A โจ B`
#. ยง1: `left`
#. ยง2: `right`
#: Game.Doc.Tactic
msgid "If the proof target is of the form ยง0, you choose ยง1 to show the left side.\n"
"\n"
"## Friends and relatives\n"
"\n"
"With ยง2, you choose the right side accordingly."
msgstr ""

#: Game.Levels.Piazza
msgid "Piazza"
msgstr ""

#. ยง0: `ยซ{h}ยป : ยซ{n}ยป = 0`
#. ยง1: `obtain ยซ{h}ยป | ยซ{h}ยป := ยซ{h}ยป`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Observe ยง0 seperatly. Prove by cases with ยง1"
msgstr ""

#. ยง0: `let c : ยซ{A}ยป โ ยซ{Y}ยป := fun a โฆ _`
#: Game.Levels.Cantor.L09_CantorDiag
msgid "Try ยง0, <Urbild>"
msgstr ""

#: Game.Levels.Epo.L03_LeftInverse
msgid "Intro Epo L03"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L14_Summary
msgid "ยง0 Conclusion Implis L14"
msgstr ""

#: Game.Levels.Vieta.L03_Let
msgid "Conclusion Vieta L03"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L08_Preimage_Injective
msgid "ยง0 Conlsuion Samarkand L08"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L04_Let
msgid "ยง0 Intro Vieta L04"
msgstr ""

#. ยง0: `f`
#. ยง1: ``` โ a b, f a = f b โ a = b ```
#: Game.Doc.Definition
msgid "A mapping ยง0 is injectiv, if:\n"
"\n"
"ยง1"
msgstr ""

#. ยง0: `not_imp_not`
#: Game.Levels.Spinoza.L04_ByContra
msgid "Explain technique ยง0"
msgstr ""

#. ยง0: `funext`
#: Game.Levels.Samarkand.L02_ImageMap
msgid "Remind ยง0"
msgstr ""

#. ยง0: `INTRO-2`
#: Game.Levels.Cantor.L09_CantorDiag
msgid "ยง0Intro Cantor L09 - 2"
msgstr ""

#. ยง0: `A B : Set T`
#. ยง1: `A โ B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `rw [subset_iff]`
#. ยง5: `A โ B`
#. ยง6: `โ x, x โ A โ x โ B`
#. ยง7: `A โ B`
#. ยง8: `intro a ha`
#. ยง9: `a`
#. ยง10: `ha : a โ A`
#. ยง11: `a โ B`
#. ยง12: `h : A โ B`
#. ยง13: `a`
#. ยง14: `ha : a โ A`
#. ยง15: `have hb := h ha`
#. ยง16: `hb : a โ B`
#. ยง17: `โ`
#. ยง18: `\\subset`
#: Game.Doc.Definition
msgid "For ยง0, ยง1 means that ยง2 is contained in ยง3.\n"
"\n"
"With ยง4, you can rewrite ยง5 as ยง6.\n"
"\n"
"If ยง7 is the proof goal, you can also directly use ยง8 to select an element ยง9 with ยง10 (and then show ยง11).\n"
"\n"
"If ยง12 is an assumption and an element ยง13 with ยง14 is given, you can use ยง15 to obtain the statement ยง16.\n"
"\n"
"You write ยง17 as ยง18."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L01_CantorPowerset
msgid "ยง0 Conclusion Cantor L01"
msgstr ""

#. ยง0: `A : Finset T`
#. ยง1: `a : T`
#. ยง2: `insert a A`
#. ยง3: `A โช {a}`
#. ยง4: `a`
#. ยง5: `A`
#. ยง6: `insert a A = A`
#: Game.Doc.Definition
msgid "For a finite subset ยง0 and an element ยง1, ยง2 is another way of writing ยง3. If ยง4 is already in ยง5, then obviously ยง6."
msgstr ""

#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
msgid "Conclusion Piazza L04"
msgstr ""

#. ยง0: `omega`
#. ยง1: `โ`
#. ยง2: `โค`
#. ยง3: `linarith`
#: Game.Doc.Tactic
msgid "The tactic ยง0 can show that a linear equation or inequality in ยง1 or ยง2 follows from given equations or inequalities. Unlike ยง3, it can also handle logical connections between (in)equations."
msgstr ""

#: Game.Levels.Cantor.L04_fixedPoints_neg
msgid "Intro Cantor L04"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Mono.L01_Injective
msgid "ยง0 Intro Mono L01"
msgstr ""

#. ยง0: `contradiction`
#. ยง1: `h : n โ n`
#. ยง2: `h : A`
#. ยง3: `h' : ยฌA`
#. ยง4: `h : False`
#. ยง5: `contradiction`
#. ยง6: `by_contra`
#: Game.Doc.Tactic
msgid "The tactic ยง0 concludes the proof if it finds a contradiction in the assumptions. Such a contradiction can look like this, for example:\n"
"\n"
"* ยง1 * ยง2 and ยง3 * ยง4\n"
"\n"
"## Friends and relatives\n"
"\n"
"Normally, ยง5 is used to conclude a proof by contradiction that was opened with ยง6."
msgstr ""

#: Game.Levels.Babylon
msgid "Babylon"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L09_subset_iff2
msgid "ยง0 Intro Piazza L09"
msgstr ""

#. ยง0: `f (E i j)`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "See that ยง0 is zero"
msgstr ""

#. ยง0: `โ`
#. ยง1: `\\l`
#. ยง2: `rw [โ hโ]`
#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "Remind of rewrite via ยง0 as ยง1. Try ยง2"
msgstr ""

#. ยง0: `Matrix.smul_ebasis`
#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "Conclusion Robotswana L01: Save result as ยง0"
msgstr ""

#. ยง0: `unfold F`
#. ยง1: `F`
#. ยง2: `unfold F at h`
#. ยง3: `h`
#. ยง4: `unfold`
#. ยง5: `push_neg`
#. ยง6: `rw`
#. ยง7: `unfold F`
#. ยง8: `simp only [F]`
#: Game.Doc.Tactic
msgid "With ยง0, you can write out the definition ยง1 in the proof goal. With ยง2, you do the same thing, but in the assumption ยง3.\n"
"\n"
"Although the proof goal or assumption before and after ยง4 are identical in definition, many tactics (e.g., ยง5 or ยง6) operate on a syntactic level; they do not โsee through definitions.โ\n"
"\n"
"## Friends and Relatives\n"
"\n"
"The tactics ยง7 and ยง8 do practically the same thing."
msgstr ""

#: Game.Levels.Epo.L06_choose
msgid "Intro Epo L06"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Saturn.L05_Ring
msgid "ยง0 Conclusion Saturn L05"
msgstr ""

#. ยง0: ``` h : โ (b : B), P b ```
#. ยง1: `b : A`
#. ยง2: `hb : P b`
#. ยง3: `choose b hb using h`
#. ยง4: `choose`
#. ยง5: ``` h : โ (a : A), โ (b : B), P a b ```
#. ยง6: `choose f hf using h`
#. ยง7: `f : A โ B`
#. ยง8: `hf : โ (a : A), P a (f a)`
#. ยง9: `P : A โ (B โ Prop)`
#. ยง10: `a`
#. ยง11: `b`
#: Game.Doc.Tactic
msgid "An assumption of the form ยง0 can be decomposed into the components ยง1 and ยง2 using ยง3.\n"
"\n"
"More generally, you can use ยง4 to select elements using the choice axiom: from an assumption of the form ยง5 extracts ยง6 a mapping ยง7 and the assumption ยง8.\n"
"\n"
"(Here, ยง9 is a predicate that depends on two variables ยง10 and ยง11.)"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L10_And
msgid "ยง0 Conclusion Logo L10"
msgstr ""

#. ยง0: `symm`
#. ยง1: `=`
#. ยง2: `โ`
#. ยง3: `symm at h`
#. ยง4: `h`
#. ยง5: `h.symm`
#. ยง6: `symm at h`
#. ยง7: `h`
#. ยง8: `rw [โh]`
#. ยง9: ``` symm at h rw [h] ```
#. ยง10: `rw [h.symm]`
#: Game.Doc.Tactic
msgid "With ยง0 (for โsymmetryโ), you swap the sides of an equation (ยง1) or equivalence (ยง2) in the proof target.\n"
"\n"
"## Variants * ยง3 operates on the assumption ยง4 instead of the proof target * ยง5 is the result of ยง6 and can be used like ยง7\n"
"\n"
"Each of the following three tactics or tactic sequences therefore has the same effect: * ยง8 * ยง9 * ยง10"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
msgid "ยง0Conclusion Cantor L08"
msgstr ""

#. ยง0: `ยซ{hโ}ยป`
#. ยง1: `ยซ{i}ยป โ ยซ{x}ยป`
#. ยง2: `have hโ : ยซ{i}ยป โ ยซ{x}ยป`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Explain that ยง0 states ยง1. Try ยง2"
msgstr ""

#. ยง0: `ยฌ`
#. ยง1: `contradiction`
#. ยง2: `by_contra h`
#: Game.Levels.Spinoza.L03_ByContra
msgid "Explain ยง0 in goal. Explain ยง1 and ยง2"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L11_erase
msgid "ยง0 Intro Piazza L11"
msgstr ""

#. ยง0: `ยซ{isDrinking}ยป`
#. ยง1: `p`
#. ยง2: `ยซ{isDrinking}ยป p`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Explain ยง0 and ยง1 in statement ยง2"
msgstr ""

#. ยง0: $$ [A, B] = AB - BA $$
#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "Intro Robotswana L06: Introduce nihiliated cummotator ยง0"
msgstr ""

#: Game.Levels.Epo.L05_RightInverse
msgid "Intro Epo L05"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L11_Iff
msgid "ยง0 Conclusion Implis L11"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Cantor.L02_CantorPowerset
msgid "ยง0Intro Cantor L02"
msgstr ""

#. ยง0: `0 - 1`
#. ยง1: `0`
#. ยง2: `n โฆ n - 1`
#. ยง3: `n โฆ n - 1`
#. ยง4: `0`
#. ยง5: `0`
#: Game.Levels.Mono.L07_SuccHasLeftInv
msgid "Conclusion Mono L07: Explain that here ยง0 is ยง1, as there is mapping ยง2 defined only on natural numbers. In Lean ยง3 is such a mapping and there for it maps ยง4 onto ยง5."
msgstr ""

#: Game.Levels.Epo.L02_CurrySurjective
msgid "Intro Epo L02"
msgstr ""

#: Game.Levels.Vieta.L08_CongrArg
msgid "Conclusion Vieta L08"
msgstr ""

#. ยง0: $$ \\begin{CD} A  @>{f}>> B @<{g}<< C    \\ @V{h}VV    @V{i}VV   @V{j}VV \\ D  @<{k}<< E @>{l}>> F    \\ @A{m}AA    @A{n}AA   @V{p}VV \\ G  @<{q}<< H @>{r}>> I \\end{CD} $$
#: Game.Levels.Implis.L05_Apply
msgid "Intro Implis L05: Introduce implication graph ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L10_CantorPowerset
msgid "ยง0Conclusion Cantor L10"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L11_SequenceUncountable
msgid "ยง0Conclusion Cantor L11"
msgstr ""

#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Try again"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
msgid "ยง0 Intro Piazza L05"
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "Conclusion Prado L06"
msgstr ""

#. ยง0: `by_cases h : P`
#. ยง1: `P`
#. ยง2: `by cases h : a = b`
#. ยง3: `a = b`
#. ยง4: `a โ b`
#. ยง5: `(h : P)`
#. ยง6: `(h : ยฌP)`
#: Game.Doc.Tactic
msgid "The tactic ยง0 begins a case distinction as to whether ยง1 is true or false. For example, ยง2 distinguishes between the cases ยง3 and ยง4.\n"
"\n"
"The proof goal is duplicated for this purpose, and the assumption ยง5 is added to the first โcopy,โ while the assumption ยง6 is added to the second โcopy.โ"
msgstr ""

#. ยง0: `P : MvPolynomial (Fin n) R`
#. ยง1: `P`
#. ยง2: `n`
#. ยง3: `X 0`
#. ยง4: `X (n-1)`
#. ยง5: `R`
#: Game.Doc.Definition
msgid "ยง0 means that ยง1 is a polynomial in ยง2 indeterminates ยง3, โฆ, ยง4 with coefficients in ยง5."
msgstr ""

#: Game.Levels.Prado
msgid "Prado"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L06_Not
msgid "ยง0 Intro Logo L06"
msgstr ""

#: Game.Levels.Prado.L09_ExistsUnique
msgid "Story, next step in proof"
msgstr ""

#. ยง0: `ยซ{P}ยป`
#. ยง1: `ยซ{X}ยป`
#. ยง2: `ยซ{P}ยป x`
#. ยง3: `x`
#. ยง4: `push_neg`
#: Game.Levels.Quantus.L08_PushNeg
msgid "Explain ยง0 over ยง1 and statement ยง2 for the natural number ยง3. Try ยง4."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Piazza.L10
msgid "ยง0 Conclusion Piazza L10"
msgstr ""

#. ยง0: `Mat[ยซ{n}ยป,ยซ{n}ยป]`
#. ยง1: `Fin ยซ{n}ยป`
#. ยง2: `single i j a`
#. ยง3: `a`
#. ยง4: `(i, j)`
#. ยง5: `E`
#. ยง6: `a = 1`
#. ยง7: `A i j`
#. ยง8: `A`
#. ยง9: `(i, j)`
#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "Introduce ยง0. Explain ยง1 and ยง2, the matrix with ยง3 at ยง4. Explain ยง5 being ยง6. Explain ยง7 being matrix ยง8 at ยง9"
msgstr ""

#: Game
msgid "Erkunde ein fremdes Universum mit deinem Smart-Elf Robo!"
msgstr ""

#. ยง0: `use _`
#. ยง1: `ยซ{b}ยป + ยซ{c}ยป = ยซ{a}ยป * _`
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
msgid "Try ยง0 such that ยง1"
msgstr ""

#. ยง0: `push_neg`
#: Game.Levels.Quantus.L09_PushNeg
#: Game.Levels.Quantus.L09_PushNeg
msgid "Statt diesem Theorem kannst du ยง0 verwenden."
msgstr ""

#. ยง0: `A`
#. ยง1: `f`
#. ยง2: `E i j`
#. ยง3: `i โ j`
#. ยง4: `A`
#. ยง5: `f A`
#. ยง6: `nth_rw 1 [ โฆ ]`
#. ยง7: `rw`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Rewrite ยง0 and use ยง1 with disappearing ยง2 with ยง3. Rewrite ยง4 to ยง5. Remind that ยง6! works as ยง7"
msgstr ""

#. ยง0: `ยซ{hb}ยป`
#. ยง1: `simp`
#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "Transform ยง0 by using ยง1"
msgstr ""

#: Game.Levels.Vieta
msgid "Vieta"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Cantor
msgid "ยง0 Intro Cantor"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L12_ByCases
msgid "ยง0 Intro Implis L12"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand
msgid "ยง0 Intro Samarkand"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Piazza.L13_insert_erase
msgid "ยง0 Conclusion Piazza L13"
msgstr ""

#. ยง0: `E i j`
#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Explain statement w.r.t. ยง0 and use former results"
msgstr ""

#: Game.Levels.Piazza.L09_subset_iff2
msgid "Conclusion Piazza L09"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L04_Apply
msgid "ยง0 Conclusion Implis L04"
msgstr ""

#. ยง0: `trans`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Solve second half of ยง0 operation"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `S`
#. ยง3: `A B : Set S`
#. ยง4: `A โช B`
#. ยง5: `โช`
#. ยง6: `\\union`
#: Game.Doc.Definition
msgid "For two subsets ยง0 and ยง1 of ยง2 (i.e. ยง3), ยง4 is their union. ยง5 is written as ยง6."
msgstr ""

#: Game.Levels.Epo.L01_Surjective
msgid "Conclusion Epo L01"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "Conclusion Mono L05"
msgstr ""

#. ยง0: `โ`
#. ยง1: `โ`
#. ยง2: `Even n`
#. ยง3: `n`
#. ยง4: `Odd n`
#. ยง5: `n`
#. ยง6: `rw`
#. ยง7: `ring`
#. ยง8: `+, -, *, ^`
#. ยง9: `decide`
#. ยง10: `unfold`
#. ยง11: `use`
#. ยง12: `โ`
#. ยง13: `choose x hx using h`
#. ยง14: `โ`
#. ยง15: `intro`
#. ยง16: `โ`
#. ยง17: `push_neg`
#. ยง18: `ยฌโ`
#. ยง19: `ยฌโ`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Conclusion Quantus L10: Overview of planet contents: ยง0, ยง1, ยง2 (ยง3 is even), ยง4 (ยง5 is odd), ยง6, ยง7 (solves equations containing ยง8), ยง9, ยง10, ยง11 (to tackle ยง12 in goal), ยง13 (to disect ยง14 in assumptions), ยง15 (to tackle ยง16 in goal) and ยง17 (for ยง18 and ยง19 in goal)."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana.L11_Linearity
msgid "ยง0 Intro Robotswana L11"
msgstr ""

#. ยง0: `tauto`
#: Game.Levels.Logo.L01_Tauto
msgid "Conclusion Logo L01: Remind that ยง0 cannot be used"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Iso.L01_Bijective
msgid "ยง0 Intro Iso L01"
msgstr ""

#: Game.Levels.Vieta.L04_Let
msgid "Conclusion Vieta L04"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza
msgid "ยง0 Intro Piazza"
msgstr ""

#. ยง0: `โ! m, P(m)`
#. ยง1: `use _`
#: Game.Levels.Prado.L09_ExistsUnique
msgid "Explain notation ยง0, Try ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Prado.L03_even_iff_two_dvd
msgid "ยง0 Intro Prado L03"
msgstr ""

#: Game.Levels.Quantus.L05_neg_pow
msgid "Conclusion Quantus L05"
msgstr ""

#. ยง0: `ยซ{hp}ยป`
#. ยง1: `ยซ{hp'}ยป`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Observe ยง0 and ยง1"
msgstr ""

#. ยง0: `if โฆ then โฆ else`
#. ยง1: `fun x โฆ if 0 โค x then x else -x`
#. ยง2: `h : A`
#. ยง3: `rw [if_pos h]`
#. ยง4: `if A then B else C`
#. ยง5: `B`
#. ยง6: `h : ยฌ A`
#. ยง7: `rw [if_neg h]`
#. ยง8: `if A then B else C`
#. ยง9: `C`
#: Game.Doc.Tactic
msgid "With ยง0, you can define mappings with two branches of definition.\n"
"\n"
"For example, ยง1 defines the absolute value function.\n"
"\n"
"## Friends and relatives\n"
"\n"
"* If you have ยง2 as an assumption, you can use ยง3 to reduce the expression ยง4 to ยง5. * If you have ยง6 as an assumption, you can use ยง7 to reduce the expression ยง8 to ยง9."
msgstr ""

#. ยง0: `use`
#. ยง1: `not_odd_iff_even`
#. ยง2: `rw`
#: Game.Levels.Quantus.L09_PushNeg
msgid "Try ยง0, ยง1. Explain that ยง2 can not be used in quantors."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Mono
msgid "ยง0 Intro Mono"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L08_Induction3_sub_insert3
msgid "ยง0 Intro Babylon L08"
msgstr ""

#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Remind of previous result"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Spinoza.L01_Have
msgid "ยง0 Intro Spinoza L01"
msgstr ""

#. ยง0: `intro b`
#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "Explain inclusion. Try ยง0"
msgstr ""

#. ยง0: `linarith`
#. ยง1: ``` h : m โค x โ n < x ```
#. ยง2: ``` rw [imp_iff_or_not] at h ```
#. ยง3: ``` h : n < x โจ ยฌm โค x ```
#. ยง4: `linarith`
#: Game.Doc.Tactic
msgid "The tactic ยง0 can show that a linear equation or inequality follows from given equations or inequalities. It is quite flexible and works just as well in โ as in โ. However, the (in)equations must be given individually, not logically linked. An assumption of the form ยง1 must first be rewritten with ยง2 to ยง3 so that ยง4 can do something with it."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "ยง0 Conclusion Robotswana L09"
msgstr ""

#: Game
msgid "Robo"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L08_exists_prime_and_dvd
msgid "ยง0 Intro Prado L08"
msgstr ""

#. ยง0: `tauto`
#: Game.Levels.Logo.L01_Tauto
#: Game.Levels.Logo.L02_Rfl
#: Game.Levels.Logo.L03_Assumption
#: Game.Levels.Logo.L04_Assumption
#: Game.Levels.Logo.L05_True
#: Game.Levels.Logo.L06_Not
#: Game.Levels.Logo.L07_Contradiction
#: Game.Levels.Logo.L08_Contradiction
#: Game.Levels.Logo.L09_Contradiction
#: Game.Levels.Logo.L10_And
#: Game.Levels.Logo.L10_And
#: Game.Levels.Logo.L11_And
#: Game.Levels.Logo.L11_And
#: Game.Levels.Implis.L01_Intro
#: Game.Levels.Implis.L02_Revert
#: Game.Levels.Implis.L03_Apply
#: Game.Levels.Implis.L04_Apply
#: Game.Levels.Implis.L04_Apply
#: Game.Levels.Implis.L05_Apply
#: Game.Levels.Implis.L05_Apply
#: Game.Levels.Implis.L06_Iff
#: Game.Levels.Implis.L08_Rw
#: Game.Levels.Implis.L08_Rw
#: Game.Levels.Implis.L10_Iff
#: Game.Levels.Implis.L10_Iff
#: Game.Levels.Implis.L11_Iff
#: Game.Levels.Implis.L12_ByCases
#: Game.Levels.Implis.L13_Rw
#: Game.Levels.Implis.L13_Rw
#: Game.Levels.Implis.L14_Summary
#: Game.Levels.Quantus.L01_NonemptyUse
#: Game.Levels.Quantus.L03_Decide
#: Game.Levels.Quantus.L05_neg_pow
#: Game.Levels.Quantus.L06_not_even_iff_odd
#: Game.Levels.Quantus.L09_PushNeg
#: Game.Levels.Quantus.L10_DrinkersParadox
#: Game.Levels.Quantus.L10_DrinkersParadox
#: Game.Levels.Spinoza.L01_Have
#: Game.Levels.Spinoza.L01_Have
#: Game.Levels.Spinoza.L04_ByContra
#: Game.Levels.Spinoza.L04_ByContra
#: Game.Levels.Spinoza.L04_ByContra
#: Game.Levels.Spinoza.L05_Contrapose
#: Game.Levels.Spinoza.L05_Contrapose
#: Game.Levels.Spinoza.L05_Contrapose
#: Game.Levels.Spinoza.L06_Summary
#: Game.Levels.Spinoza.L06_Summary
#: Game.Levels.Luna.L01_le_rfl
#: Game.Levels.Luna.L02_Omega
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
#: Game.Levels.Luna.L04_Omega2
#: Game.Levels.Luna.L05_Linarith2
#: Game.Levels.Luna.L05_Linarith2
#: Game.Levels.Luna.L05_Linarith2
#: Game.Levels.Luna.L05_Linarith2
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L08_Omega3
#: Game.Levels.Babylon.L01_Sum_Simp_Card
#: Game.Levels.Babylon.L04_sum_subset
#: Game.Levels.Babylon.L04_sum_subset
#: Game.Levels.Babylon.L05_sum_subset2
#: Game.Levels.Babylon.L05_sum_subset2
#: Game.Levels.Babylon.L05_sum_subset2
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L07_Induction2_sum_insert2
#: Game.Levels.Babylon.L08_Induction3_sub_insert3
#: Game.Levels.Babylon.L09_Boss
#: Game.Levels.Cantor.L01_CantorPowerset
#: Game.Levels.Cantor.L01_CantorPowerset
#: Game.Levels.Cantor.L02_CantorPowerset
#: Game.Levels.Cantor.L02_CantorPowerset
#: Game.Levels.Cantor.L02_CantorPowerset
#: Game.Levels.Cantor.L03_IsFixedPt_abs
#: Game.Levels.Cantor.L03_IsFixedPt_abs
#: Game.Levels.Cantor.L03_IsFixedPt_abs
#: Game.Levels.Cantor.L04_fixedPoints_neg
#: Game.Levels.Cantor.L04_fixedPoints_neg
#: Game.Levels.Cantor.L04_fixedPoints_neg
#: Game.Levels.Cantor.L07_idempotent
#: Game.Levels.Cantor.L10_CantorPowerset
#: Game.Levels.Cantor.L11_SequenceUncountable
#: Game.Levels.Robotswana.L04_MatrixEqSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L08_EvalOnEBasis
#: Game.Levels.Robotswana.L08_EvalOnEBasis
#: Game.Levels.Robotswana.L08_EvalOnEBasis
#: Game.Levels.Robotswana.L08_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L10_Characterize
#: Game.Levels.Prado.L01_prime_two
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
#: Game.Levels.Prado.L03_even_iff_two_dvd
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
#: Game.Levels.Prado.L08_exists_prime_and_dvd
#: Game.Levels.Prado.L09_ExistsUnique
#: Game.Levels.Prado.L09_ExistsUnique
#: Game.Levels.Euklid.L01_prod_pos
#: Game.Levels.Euklid.L02_prod_insert
#: Game.Levels.Euklid.L02_prod_insert
#: Game.Levels.Euklid.L02_prod_insert
#: Game.Levels.Euklid.L02_prod_insert
#: Game.Levels.Euklid.L02_prod_insert
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
#: Game.Levels.Vieta.L03_Let
#: Game.Levels.Vieta.L05_Funext
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Epo.L02_CurrySurjective
#: Game.Levels.Epo.L02_CurrySurjective
#: Game.Levels.Epo.L03_LeftInverse
#: Game.Levels.Epo.L06_choose
#: Game.Levels.Mono.L01_Injective
#: Game.Levels.Mono.L01_Injective
#: Game.Levels.Mono.L01_Injective
#: Game.Levels.Mono.L02_InjectiveNeIff
#: Game.Levels.Mono.L02_InjectiveNeIff
#: Game.Levels.Mono.L03_NotInjective
#: Game.Levels.Mono.L03_NotInjective
#: Game.Levels.Mono.L04_Diagonal
#: Game.Levels.Mono.L04_Diagonal
#: Game.Levels.Mono.L05_StrictMono
#: Game.Levels.Mono.L05_StrictMono
#: Game.Levels.Mono.L09_InjOfHasLeftInv
#: Game.Levels.Mono.L11_InjHasLeftInv
#: Game.Levels.Samarkand.L02_ImageMap
#: Game.Levels.Samarkand.L03_SurjectiveRange
#: Game.Levels.Samarkand.L03_SurjectiveRange
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Piazza.L02_Simp
#: Game.Levels.Piazza.L02_Simp
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
#: Game.Levels.Piazza.L06_Ext2__univ2
#: Game.Levels.Piazza.L06_Ext2__univ2
#: Game.Levels.Piazza.L07_antisymm_iff
#: Game.Levels.Piazza.L10
#: Game.Levels.Piazza.L10
msgid "Try ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L12_ByCases
msgid "ยง0 Conclusion Implis L12"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana.L02_EBasis
msgid "ยง0 Intro Robotswana L02"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L09_ExistsUnique
msgid "ยง0 Intro Prado L09"
msgstr ""

#: Game.Doc.Definition
msgid "A mapping ist bijectiv, if it is injektiv and surjektiv."
msgstr ""

#. ยง0: `push_neg`
#. ยง1: `not_exists (P : X โ Prop) : ยฌ (โ x, P x) โ โ x, (ยฌ P x)`
#. ยง2: `not_forall (P : X โ Prop) : ยฌ (โ x, P x) โ โ x, (ยฌ P x)`
#. ยง3: `push_neg`
#: Game.Levels.Quantus.L08_PushNeg
msgid "Conclusion Quantus L08: ยง0 internally uses ยง1 and ยง2. Memorize ยง3."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L07_Induction2_sum_insert2
msgid "ยง0 Intro Babylon L07"
msgstr ""

#. ยง0: `left`
#. ยง1: `right`
#: Game.Levels.Logo.L12_Or
#: Game.Levels.Implis.L07_Symm
#: Game.Levels.Quantus.L04_Exists
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Babylon.L05_sum_subset2
#: Game.Levels.Cantor.L07_idempotent
#: Game.Levels.Cantor.L07_idempotent
#: Game.Levels.Robotswana.L11_Linearity
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
#: Game.Levels.Epo.L04_RightInverse
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
#: Game.Levels.Piazza.L08_subset_iff
msgid "Try ยง0 | ยง1"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `image f : Set A โ Set B`
#. ยง2: `A`
#. ยง3: `f โโ A`
#. ยง4: `f`
#: Game.Doc.Definition
msgid "For a mapping ยง0, ยง1 is one of the induced mappings on the power sets โ it maps a subset of ยง2 to the image ยง3 of this subset under ยง4."
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "Conclusion Piazza L07"
msgstr ""

#. ยง0: `E.mul_of_ne`
#: Game.Levels.Robotswana.L02_EBasis
msgid "Conclusion Robotswana L02: save result as ยง0"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L06_IsFixedPt_odd
msgid "ยง0Conclusion Cantor L06"
msgstr ""

#. ยง0: `image_preimage_subset`
#. ยง1: `f`
#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
msgid "Remind ยง0 and assumption that ยง1 surjectiv"
msgstr ""

#. ยง0: `image`
#. ยง1: `''`
#. ยง2: `image f`
#. ยง3: `A`
#. ยง4: `B`
#. ยง5: `image f`
#. ยง6: `f ''`
#: Game.Levels.Samarkand.L02_ImageMap
msgid "Can not use ยง0 instead of ยง1. Explain that ยง2 is mapping from ยง3 to ยง4. You can express ยง5 by ยง6 but not vica versa"
msgstr ""

#. ยง0: `โ`
#. ยง1: `use โฆ`
#. ยง2: `let f : โค โ โค := fun โฆ`
#. ยง3: `โฆ`
#. ยง4: `\\maps`
#. ยง5: `\\mapsto`
#. ยง6: `=>`
#: Game.Levels.Vieta.L03_Let
msgid "Tackle  ยง0 either with ยง1 or define mapping ยง2 as before. Remind that ยง3 is either ยง4 or ยง5 ro can be replyced by ยง6"
msgstr ""

#. ยง0: `(ยซ{A}ยป โง ยซ{B}ยป) โจ ยซ{A}ยป`
#. ยง1: `obtain โฆ`
#. ยง2: `obtain h | h := ยซ{h}ยป`
#. ยง3: `obtain โจhโ, hโโฉ := ยซ{h}ยป`
#: Game.Levels.Logo.L13_Or
msgid "Observe goal as ยง0. Try ยง1 via ยง2 not via ยง3"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
msgid "ยง0 Intro Piazza L03"
msgstr ""

#: Game.Levels.Samarkand
msgid "Samarkand"
msgstr ""

#. ยง0: `binomi`
#. ยง1: `add_pow_two`
#. ยง2: `rw [add_pow_two]`
#: Game.Levels.Saturn.L02_Ring_add_pow_two
msgid "Explain misfit of ยง0. Try ยง1 via ยง2"
msgstr ""

#. ยง0: `apply`
#. ยง1: `hAB : A โ B`
#. ยง2: `โข B`
#. ยง3: `apply hAB`
#. ยง4: `โข A`
#. ยง5: `h : A `
#. ยง6: `apply hAB at h`
#. ยง7: `h : B`
#. ยง8: `hAB`
#: Game.Doc.Tactic
msgid "With ยง0, you apply an implication ยง1:\n"
"\n"
"| before | tactic           | after | |:------------ |:---------------- |:-------- | | ยง2        | ยง3      | ยง4    | | ยง5     | ยง6 | ยง7  |\n"
"\n"
"In both cases, the implication ยง8 can either be given as an assumption or be an already known lemma."
msgstr ""

#. ยง0: `CONC-2`
#: Game.Levels.Cantor.L09_CantorDiag
msgid "ยง0Conclusion Cantor L09 - 2"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Euklid.L02_prod_insert
msgid "ยง0 Intro Euklid L02"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Saturn.L01_Rewrite_equality
msgid "ยง0 Intro Saturn L01"
msgstr ""

#: Game.Levels.Mono.L05_StrictMono
msgid "Intro Mono L05"
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "Conclusion Spinoza L04"
msgstr ""

#. ยง0: `โโโฒโฌโโผโขฆโฝชโโซโฝญโโโฏโซโขโโโฎโโงโถคโโงโโธโฉโชโโฉโฅโตโฎโชณโโโฟฉโโกโดโธโโฎโฃโนโชโพโผฐโฐโฆโโบโโดโฌโพโโโฐโฑโทโคโพโฝฌโฏโณโงญโธโตนโพโกโพโขโจโโผญโปโดฒโฆโฎโโกโงโโฌโโโโฝโโโ โฆ`
#: Game.Levels.Euklid
msgid "Intro Euklid: shows encrypted message ยง0"
msgstr ""

#. ยง0: `r`
#. ยง1: `n ^ 2 = r + r`
#. ยง2: `let r := โฆ`
#: Game.Levels.Quantus.L04_Exists
msgid "Find ยง0 such that ยง1. Try ยง2"
msgstr ""

#: Game.Levels.Logo.L01_Tauto
#: Game.Levels.Logo.L01_Tauto
#: Game.Levels.Logo.L02_Rfl
#: Game.Levels.Logo.L03_Assumption
#: Game.Levels.Logo.L04_Assumption
#: Game.Levels.Logo.L05_True
#: Game.Levels.Logo.L06_Not
#: Game.Levels.Logo.L07_Contradiction
#: Game.Levels.Logo.L08_Contradiction
#: Game.Levels.Logo.L08_Contradiction
#: Game.Levels.Logo.L09_Contradiction
#: Game.Levels.Logo.L09_Contradiction
#: Game.Levels.Logo.L10_And
#: Game.Levels.Logo.L10_And
#: Game.Levels.Logo.L11_And
#: Game.Levels.Logo.L12_Or
#: Game.Levels.Logo.L13_Or
#: Game.Levels.Logo.L13_Or
#: Game.Levels.Logo.L14_Summary
#: Game.Levels.Implis.L01_Intro
#: Game.Levels.Implis.L02_Revert
#: Game.Levels.Implis.L03_Apply
#: Game.Levels.Implis.L04_Apply
#: Game.Levels.Implis.L05_Apply
#: Game.Levels.Implis.L06_Iff
#: Game.Levels.Implis.L07_Symm
#: Game.Levels.Implis.L08_Rw
#: Game.Levels.Implis.L09_Trans
#: Game.Levels.Implis.L10_Iff
#: Game.Levels.Implis.L11_Iff
#: Game.Levels.Implis.L12_ByCases
#: Game.Levels.Implis.L13_Rw
#: Game.Levels.Implis.L14_Summary
#: Game.Levels.Quantus.L01_NonemptyUse
#: Game.Levels.Quantus.L02_NonemptyObtain
#: Game.Levels.Quantus.L03_Decide
#: Game.Levels.Quantus.L04_Exists
#: Game.Levels.Quantus.L05_neg_pow
#: Game.Levels.Quantus.L05_neg_pow
#: Game.Levels.Quantus.L05_neg_pow
#: Game.Levels.Quantus.L06_not_even_iff_odd
#: Game.Levels.Quantus.L06_not_even_iff_odd
#: Game.Levels.Quantus.L06_not_even_iff_odd
#: Game.Levels.Quantus.L07_Forall
#: Game.Levels.Quantus.L08_PushNeg
#: Game.Levels.Quantus.L09_PushNeg
#: Game.Levels.Quantus.L10_DrinkersParadox
#: Game.Levels.Saturn.L01_Rewrite_equality
#: Game.Levels.Saturn.L02_Ring_add_pow_two
#: Game.Levels.Saturn.L02_Ring_add_pow_two
#: Game.Levels.Saturn.L03_mul_comm
#: Game.Levels.Saturn.L03_mul_comm
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L04_mul_assoc
#: Game.Levels.Saturn.L05_Ring
#: Game.Levels.Spinoza.L01_Have
#: Game.Levels.Spinoza.L02_Suffices
#: Game.Levels.Spinoza.L03_ByContra
#: Game.Levels.Spinoza.L04_ByContra
#: Game.Levels.Spinoza.L04_ByContra
#: Game.Levels.Spinoza.L05_Contrapose
#: Game.Levels.Spinoza.L06_Summary
#: Game.Levels.Luna.L01_le_rfl
#: Game.Levels.Luna.L01_le_rfl
#: Game.Levels.Luna.L02_Omega
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
#: Game.Levels.Luna.L04_Omega2
#: Game.Levels.Luna.L05_Linarith2
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L06_Icc__Icc_insert_succ_right
#: Game.Levels.Luna.L07_Linarith2
#: Game.Levels.Luna.L08_Omega3
#: Game.Levels.Luna.L09_lt_trichotomy2
#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
#: Game.Levels.Babylon.L01_Sum_Simp_Card
#: Game.Levels.Babylon.L02_Card2
#: Game.Levels.Babylon.L03_sum_congr
#: Game.Levels.Babylon.L03_sum_congr
#: Game.Levels.Babylon.L04_sum_subset
#: Game.Levels.Babylon.L04_sum_subset
#: Game.Levels.Babylon.L05_sum_subset2
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
#: Game.Levels.Babylon.L07_Induction2_sum_insert2
#: Game.Levels.Babylon.L08_Induction3_sub_insert3
#: Game.Levels.Babylon.L09_Boss
#: Game.Levels.Cantor.L01_CantorPowerset
#: Game.Levels.Cantor.L01_CantorPowerset
#: Game.Levels.Cantor.L02_CantorPowerset
#: Game.Levels.Cantor.L03_IsFixedPt_abs
#: Game.Levels.Cantor.L04_fixedPoints_neg
#: Game.Levels.Cantor.L05_IsFixedPt_not
#: Game.Levels.Cantor.L06_IsFixedPt_odd
#: Game.Levels.Cantor.L07_idempotent
#: Game.Levels.Cantor.L08_CantorDiag_IsFixedPt
#: Game.Levels.Cantor.L09_CantorDiag
#: Game.Levels.Cantor.L09_CantorDiag
#: Game.Levels.Cantor.L10_CantorPowerset
#: Game.Levels.Cantor.L11_SequenceUncountable
#: Game.Levels.Robotswana.L01_SMulEBasis
#: Game.Levels.Robotswana.L01_SMulEBasis
#: Game.Levels.Robotswana.L02_EBasis
#: Game.Levels.Robotswana.L02_EBasis
#: Game.Levels.Robotswana.L03
#: Game.Levels.Robotswana.L03
#: Game.Levels.Robotswana.L04_MatrixEqSum
#: Game.Levels.Robotswana.L04_MatrixEqSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L05_EBasisDiagSum
#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
#: Game.Levels.Robotswana.L07_EBasisZeroOffDiag
#: Game.Levels.Robotswana.L08_EvalOnEBasis
#: Game.Levels.Robotswana.L08_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L09_EvalOnEBasis
#: Game.Levels.Robotswana.L10_Characterize
#: Game.Levels.Robotswana.L10_Characterize
#: Game.Levels.Robotswana.L11_Linearity
#: Game.Levels.Robotswana.L11_Linearity
#: Game.Levels.Robotswana.L11_Linearity
#: Game.Levels.Robotswana.L11_Linearity
#: Game.Levels.Robotswana.L11_Linearity
#: Game.Levels.Ciao.L01
#: Game.Levels.Prado.L01_prime_two
#: Game.Levels.Prado.L01_prime_two
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
#: Game.Levels.Prado.L03_even_iff_two_dvd
#: Game.Levels.Prado.L03_even_iff_two_dvd
#: Game.Levels.Prado.L04_99
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
#: Game.Levels.Prado.L07_dvd_mul
#: Game.Levels.Prado.L07_dvd_mul
#: Game.Levels.Prado.L08_exists_prime_and_dvd
#: Game.Levels.Prado.L08_exists_prime_and_dvd
#: Game.Levels.Prado.L09_ExistsUnique
#: Game.Levels.Prado.L09_ExistsUnique
#: Game.Levels.Prado.L09_ExistsUnique
#: Game.Levels.Prado.L10_EvenPrime
#: Game.Levels.Euklid.L01_prod_pos
#: Game.Levels.Euklid.L01_prod_pos
#: Game.Levels.Euklid.L02_prod_insert
#: Game.Levels.Euklid.L02_prod_insert
#: Game.Levels.Euklid.L03_Finite_toFinset__prod_insert2
#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
#: Game.Levels.Vieta.L01_FunctionNotation
#: Game.Levels.Vieta.L02_Function
#: Game.Levels.Vieta.L03_Let
#: Game.Levels.Vieta.L04_Let
#: Game.Levels.Vieta.L05_Funext
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Vieta.L06_Piecewise
#: Game.Levels.Vieta.L07_Extend
#: Game.Levels.Vieta.L08_CongrArg
#: Game.Levels.Vieta.L08_CongrArg
#: Game.Levels.Vieta.L09_CongrFun
#: Game.Levels.Vieta.L09_CongrFun
#: Game.Levels.Vieta.L10_Surjective
#: Game.Levels.Epo.L01_Surjective
#: Game.Levels.Epo.L02_CurrySurjective
#: Game.Levels.Epo.L02_CurrySurjective
#: Game.Levels.Epo.L03_LeftInverse
#: Game.Levels.Epo.L04_RightInverse
#: Game.Levels.Epo.L05_RightInverse
#: Game.Levels.Epo.L06_choose
#: Game.Levels.Epo.L07_SurjectiveRightInverse
#: Game.Levels.Epo.L07_SurjectiveRightInverse
#: Game.Levels.Mono.L01_Injective
#: Game.Levels.Mono.L02_InjectiveNeIff
#: Game.Levels.Mono.L02_InjectiveNeIff
#: Game.Levels.Mono.L03_NotInjective
#: Game.Levels.Mono.L04_Diagonal
#: Game.Levels.Mono.L05_StrictMono
#: Game.Levels.Mono.L06_StrictMono
#: Game.Levels.Mono.L07_SuccHasLeftInv
#: Game.Levels.Mono.L08_RightInvOfLeftInv
#: Game.Levels.Mono.L09_InjOfHasLeftInv
#: Game.Levels.Mono.L09_InjOfHasLeftInv
#: Game.Levels.Mono.L10_Auxiliary
#: Game.Levels.Mono.L11_InjHasLeftInv
#: Game.Levels.Mono.L11_InjHasLeftInv
#: Game.Levels.Samarkand.L01_ImagePreimage
#: Game.Levels.Samarkand.L01_ImagePreimage
#: Game.Levels.Samarkand.L02_ImageMap
#: Game.Levels.Samarkand.L03_SurjectiveRange
#: Game.Levels.Samarkand.L03_SurjectiveRange
#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
#: Game.Levels.Samarkand.L04_SurjectiveImagePreimage
#: Game.Levels.Samarkand.L05_InjectiveFibre
#: Game.Levels.Samarkand.L05_InjectiveFibre
#: Game.Levels.Samarkand.L06_PreimageNonempty
#: Game.Levels.Samarkand.L07_LeftInvPreimage
#: Game.Levels.Samarkand.L08_Preimage_Injective
#: Game.Levels.Samarkand.L08_Preimage_Injective
#: Game.Levels.Iso.L01_Bijective
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Iso.L02_Inverse
#: Game.Levels.Piazza.L01_Mem__Set
#: Game.Levels.Piazza.L02_Simp
#: Game.Levels.Piazza.L03_Ext__Set__Union__Inter
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
#: Game.Levels.Piazza.L04_Generalize__univ__eq_univ_iff_forall
#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
#: Game.Levels.Piazza.L05_empty__eq_empty_iff_forall_not_mem
#: Game.Levels.Piazza.L06_Ext2__univ2
#: Game.Levels.Piazza.L07_antisymm_iff
#: Game.Levels.Piazza.L07_antisymm_iff
#: Game.Levels.Piazza.L08_subset_iff
#: Game.Levels.Piazza.L08_subset_iff
#: Game.Levels.Piazza.L08_subset_iff
#: Game.Levels.Piazza.L09_subset_iff2
#: Game.Levels.Piazza.L10
#: Game.Levels.Piazza.L11_erase
#: Game.Levels.Piazza.L11_erase
#: Game.Levels.Piazza.L12_insert
#: Game.Levels.Piazza.L13_insert_erase
#: Game.Levels.Piazza.L13_insert_erase
msgid ""
msgstr ""

#: Game.Levels.Quantus
msgid "Quantus"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Spinoza
msgid "ยง0 Intro Spinoza"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Spinoza.L05_Contrapose
msgid "ยง0 Conclusion Spinoza L05"
msgstr ""

#: Game.Levels.Babylon.L05_sum_subset2
msgid "Intro Babylon L05"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Iso.L02_Inverse
msgid "ยง0 Conclusion Iso L02"
msgstr ""

#. ยง0: `b`
#. ยง1: `eq_empty_iff_forall_not_mem`
#. ยง2: `unfold Ne`
#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "Explain ยง0. Explain ยง1. Try ยง2"
msgstr ""

#. ยง0: `โ`
#. ยง1: `\\forall`
#. ยง2: `โ x, โฆ`
#. ยง3: `intro x`
#: Game.Levels.Quantus.L07_Forall
msgid "Explain ยง0 i.e. ยง1 and approch to prove ยง2  by ยง3"
msgstr ""

#. ยง0: `succ`
#. ยง1: `succ : โ โ โ`
#. ยง2: `n โฆ n + 1`
#. ยง3: `f`
#: Game.Levels.Vieta.L10_Surjective
msgid "Explain ยง0 as mapping ยง1 i.e. ยง2. Explain goal of showing ยง3 surjective."
msgstr ""

#. ยง0: `decide`
#. ยง1: `Even 42`
#: Game.Levels.Quantus.L03_Decide
msgid "Conclusion Quantus L03: Explain that ยง0 can show True/False for ยง1, if decide possesses an algorithm for making this decision"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L06_PreimageNonempty
msgid "ยง0 Conclusion Samarkand L06"
msgstr ""

#. ยง0: `E i j`
#. ยง1: `n ร n`
#. ยง2: `โ`
#. ยง3: `1`
#. ยง4: $(i, j)$
#. ยง5: `single i j (a : R)`
#. ยง6: `a`
#. ยง7: `E`
#: Game.Levels.Robotswana.L01_SMulEBasis
msgid "ยง0 ist die ยง1-Matrix (mit Werten in ยง2) mit einer ยง3 an Stelle ยง4 und Null รผberall sonst.\n"
"\n"
"Dies ist eine spezialisierte Form der generellen ยง5, welche auch nicht-quadratisch sein kann und einen beliebigen Wert ยง6 aus einem beliebigen Ring annehmen kann. Wir benutzen hier ยง7 einfach als Abkรผrzung."
msgstr ""

#. ยง0: `f`
#: Game.Levels.Robotswana.L10_Characterize
msgid "Explain that each ยง0 has stated properties"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Epo.L01_Surjective
msgid "ยง0 Intro Epo L01"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Ciao.L01
msgid "ยง0Conclusion Cia L01"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "ยง0 Intro Robotswana L04"
msgstr ""

#. ยง0: `โ`
#. ยง1: `โ`
#. ยง2: `intro`
#. ยง3: `revert`
#. ยง4: `intro`
#. ยง5: `apply`
#. ยง6: `apply at`
#. ยง7: `symm`
#. ยง8: `A โ B`
#. ยง9: `B โ A`
#. ยง10: `trans`
#. ยง11: `A โ C`
#. ยง12: `A โ B`
#. ยง13: `B โ C`
#. ยง14: `rw [h] `
#. ยง15: `h`
#. ยง16: `rw [h] at hโ`
#. ยง17: `hโ`
#. ยง18: `h`
#. ยง19: `by_cases h : P`
#. ยง20: `P`
#. ยง21: `ยฌP`
#: Game.Levels.Implis.L14_Summary
msgid "Intro Implis L14: This chapter used the following operations: ยง0, ยง1, ยง2, ยง3 (reversal of ยง4), ยง5, ยง6, ยง7 (changes ยง8 to ยง9), ยง10 (changes ยง11 to ยง12 and ยง13), ยง14 (rewrite goal with ยง15), ยง16 (rewrite assumption ยง17 using ยง18) and ยง19 (introduce cases ยง20 and ยง21)"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L05_Linarith2
msgid "ยง0 Intro Luna L05"
msgstr ""

#. ยง0: `A`
#. ยง1: `trace A`
#. ยง2: `A`
#. ยง3: `โ i, A i i`
#: Game.Doc.Definition
msgid "For a matrix ยง0, ยง1 is the trace of ยง2. The expression is also equivalent to ยง3 in Leanic."
msgstr ""

#. ยง0: `n : โ`
#. ยง1: `Fin n`
#. ยง2: $\\{0, \\dots, n-1\\}$
#. ยง3: `Fin n`
#. ยง4: `Icc 0 (n-1)`
#. ยง5: `Fin n`
#. ยง6: `Fin n : Type`
#. ยง7: `Icc 0 (n-1) : Finset โ`
#. ยง8: `โ`
#: Game.Doc.Definition
msgid "For ยง0, ยง1 is the set ยง2.\n"
"\n"
"(ยง3 is to be distinguished from ยง4: ยง5 is a set, or more precisely a type, i.e. ยง6, whereas ยง7 is a finite subset of ยง8.)"
msgstr ""

#: Game.Levels.Spinoza
msgid "Spinoza"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Robotswana
msgid "ยง0 Intro Robotswana"
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "Conclusion Mono L03"
msgstr ""

#. ยง0: `ยซ{h}ยป`
#. ยง1: `s`
#. ยง2: `s + s = ยซ{n}ยป`
#. ยง3: `choose s hs using ยซ{h}ยป`
#: Game.Levels.Quantus.L04_Exists
msgid "Explain that from ยง0 follow that there is ยง1 such that ยง2. Try ยง3"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L02_Simp
msgid "ยง0 Intro Piazza L02"
msgstr ""

#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "Conclusion Cantor L03"
msgstr ""

#. ยง0: `generalize`
#. ยง1: `generalize h : a = b`
#. ยง2: `a`
#. ยง3: `b`
#. ยง4: `h : a = b`
#. ยง5: ``` Even x โจ ยฌEven x ```
#. ยง6: ``` generalize h : (Even x) = A ```
#. ยง7: ``` A โจ ยฌA ```
#. ยง8: `tauto`
#: Game.Doc.Tactic
msgid "With ยง0, you can generalize a proof goal in the hope that a higher level of abstraction will allow for a simpler proof. More precisely, ยง1 replaces all occurrences of ยง2 in the proof goal with ยง3 (and adds the assumption ยง4).\n"
"\n"
"## Example\n"
"\n"
"A goal of the form ยง5 can be converted with ยง6 into ยง7 (and then simply proven with ยง8)."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "ยง0 Conclusion Robotswana L08"
msgstr ""

#. ยง0: `if_pos`
#: Game.Levels.Vieta.L06_Piecewise
msgid "Remind of negation for ยง0"
msgstr ""

#. ยง0: `h : X = Y`
#. ยง1: `h : X โ Y`
#. ยง2: `rw [h]`
#. ยง3: `X`
#. ยง4: `Y`
#. ยง5: `rw [โh]`
#. ยง6: `h`
#. ยง7: `Y`
#. ยง8: `X`
#. ยง9: `rw [h, g, โf]`
#. ยง10: `h`
#. ยง11: `g`
#. ยง12: `f`
#. ยง13: `rw [h] at hโ`
#. ยง14: `hโ`
#. ยง15: `nth_rw`
#. ยง16: `h`
#. ยง17: `n`
#. ยง18: ``` h : โ n, 2*n = f n ```
#. ยง19: ``` h (n : โ) : 2*n = f n ```
#. ยง20: `rw [h]`
#. ยง21: `nth_rw k [h]`
#. ยง22: `k`
#. ยง23: `2*a + 2*b > 2*a`
#. ยง24: `rw [h]`
#. ยง25: `f a + 2*b > f a`
#. ยง26: `nth_rw 2 [h]`
#. ยง27: `2*a + f b > 2*a`
#: Game.Doc.Tactic
msgid "If you have given an equation ยง0 or an equivalence ยง1 as an assumption or lemma, you can use ยง2 to replace all occurrences of ยง3 in the proof target with ยง4.\n"
"\n"
"## Variants\n"
"\n"
"* ยง5 applies ยง6 backwards, i.e., replaces all ยง7 with ยง8. * ยง9 applies ยง10, ยง11, and (backwards) ยง12. * ยง13 performs the replacements in the assumption ยง14, not in the proof target * ยง15: If ยง16 has arguments, e.g., ยง17 in ยง18 or in ยง19 ยง20 searches the proof target from left to right for a matching expression, and then replaces *all* occurrences of *the first* expression that the tactic finds. With ยง21, you can replace all occurrences of the ยง22th expression instead.\n"
"\n"
"  | before    | tactic       | after        | |:----------------- |:------------- - |:----------------- | | ยง23 | ยง24       | ยง25 | |                   | ยง26 | ยง27 |"
msgstr ""

#. ยง0: `f : A โ A`
#. ยง1: `a : A`
#. ยง2: `IsFixedPt f a`
#. ยง3: `f a = a`
#. ยง4: `unfold IsFixedPt`
#: Game.Doc.Definition
msgid "For a self-mapping ยง0 and an element ยง1, ยง2 is the expression ยง3. Look up definition with ยง4."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Babylon.L05_sum_subset2
msgid "ยง0 Conclusion Babylon L05"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L07_Contradiction
msgid "ยง0 Intro Logo L07"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Babylon.L08_Induction3_sub_insert3
msgid "ยง0 Conclusion Babylon L08"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L07_Forall
msgid "ยง0 Intro Quantus L07"
msgstr ""

#. ยง0: `push_neg`
#. ยง1: `ยฌโ x, P x`
#. ยง2: `โ x, ยฌP x`
#. ยง3: `ยฌโ x, P x`
#. ยง4: `โ x, ยฌP x`
#. ยง5: `ยฌ`
#. ยง6: ``` ยฌ โ ฮต, โ ฮด, โ y, | x - y | < ฮด โ | f x - f y | < ฮต ```
#. ยง7: `push_neg`
#. ยง8: ``` โ ฮต, โ ฮด, โ y, ยฌ (| x - y | < ฮด โ | f x - f y | < ฮต) ```
#. ยง9: `not_forall`
#. ยง10: `not_exists`
#. ยง11: `rw`
#: Game.Doc.Tactic
msgid "The ยง0 tactic pushes negation past quantifiers:\n"
"\n"
"| before       | after      | |:------------ |:-------------| | ยง1  | ยง2  | | ยง3  | ยง4  |\n"
"\n"
"In nested expressions, it pushes the negation ยง5 as far to the right as possible. For example, the proof goal ยง6 with ยง7 ยง8\n"
"\n"
"## Friends and relatives\n"
"\n"
"The two lemmas ยง9 and ยง10 can be applied individually with ยง11."
msgstr ""

#. ยง0: `(A : Prop)`
#. ยง1: `(True : Prop)`
#. ยง2: `(False : Prop)`
#: Game.Doc.Definition
msgid "ยง0 is any statement, without further specification as to whether it is true, false, or unprovable.\n"
"\n"
"See also ยง1 and ยง2 for the unconditionally true and false statements, respectively."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Iso.L01_Bijective
msgid "ยง0 Conclusion Iso L01"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Spinoza.L02_Suffices
msgid "ยง0 Intro Spinoza L02"
msgstr ""

#. ยง0: `by_cases h_leq : ยซ{a}ยป โค ยซ{b}ยป`
#. ยง1: `by_cases h_lt : ยซ{a}ยป < ยซ{b}ยป`
#: Game.Levels.Luna.L03_Linarith__lt_trichotomy
#: Game.Levels.Luna.L09_lt_trichotomy2
#: Game.Levels.Luna.L10_Icc_subset_Icc_iff
#: Game.Levels.Babylon.L07_Induction2_sum_insert2
#: Game.Levels.Cantor.L02_CantorPowerset
#: Game.Levels.Cantor.L07_idempotent
#: Game.Levels.Robotswana.L08_EvalOnEBasis
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
#: Game.Levels.Prado.L02_dvd_iff_exists_eq_mul_left
#: Game.Levels.Prado.L05_not_dvd_of_between_consec_multiples
#: Game.Levels.Epo.L05_RightInverse
#: Game.Levels.Mono.L03_NotInjective
msgid "Try ยง0, ยง1"
msgstr ""

#. ยง0: `toNat`
#. ยง1: `n : โค`
#. ยง2: `n.toNat : โ`
#. ยง3: `(-1).toNat`
#. ยง4: `n โฅ 0`
#. ยง5: `n.toNat`
#: Game.Levels.Vieta.L07_Extend
msgid "Try ยง0. Explain, given ยง1 then ยง2 is the same number interpreted as a natural number. Remind that ยง3 undefined as ยง4 for ยง5"
msgstr ""

#. ยง0: `A : Finset T`
#. ยง1: `a : T`
#. ยง2: `erase A a`
#. ยง3: `A \\ {a}`
#. ยง4: `a`
#. ยง5: `A`
#. ยง6: `erase A a = A`
#: Game.Doc.Definition
msgid "For a finite subset ยง0 and an element ยง1, ยง2 is another way of writing ยง3. If ยง4 is not in ยง5 at all, then obviously ยง6."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Spinoza.L03_ByContra
msgid "ยง0 Intro Spinoza L03"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L08_Rw
msgid "ยง0 Intro Implis L08"
msgstr ""

#. ยง0: `CONC-1`
#: Game.Levels.Cantor.L09_CantorDiag
msgid "ยง0Conclusion Cantor L09 - 1"
msgstr ""

#. ยง0: `trace`
#: Game.Levels.Robotswana.L10_Characterize
msgid "Intro Robotswana L10: Introduce ยง0"
msgstr ""

#. ยง0: `intro`
#. ยง1: `Injective f`
#: Game.Levels.Mono.L06_StrictMono
msgid "Try ยง0 on assumptions of ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L09_Boss
msgid "ยง0 Intro Babylon L09"
msgstr ""

#. ยง0: `(g โ ยซ{f}ยป) x`
#. ยง1: `g (ยซ{f}ยป x)`
#. ยง2: `simp`
#. ยง3: `rw [comp_apply]`
#: Game.Levels.Vieta.L04_Let
msgid "Explain ยง0 defined as ยง1. Try ยง2 | ยง3"
msgstr ""

#: Game.Levels.Piazza.L08_subset_iff
msgid "Conclusion Piazza L08"
msgstr ""

#. ยง0: ```i ^ 3 - 3 * i ^ 2 + 2 * i = 0```
#: Game.Levels.Babylon.L04_sum_subset
msgid "Introduce assumptions until ยง0 as goal"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Luna.L04_Omega2
msgid "ยง0 Conclusion Luna L04"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna
msgid "ยง0 Intro Luna"
msgstr ""

#. ยง0: `range f`
#. ยง1: `f`
#. ยง2: `f '' univ`
#. ยง3: `mem_range`
#: Game.Levels.Samarkand.L03_SurjectiveRange
msgid "Explain ยง0 w.r.t. ยง1 and its equivalent ยง2. Mention ยง3"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Samarkand.L01_ImagePreimage
msgid "ยง0 Intro Samarkand L01"
msgstr ""

#. ยง0: `rw`
#. ยง1: `trans`
#. ยง2: $B \\iff A \\iff D \\iff C$
#. ยง3: `B \\iff A`
#. ยง4: `trans A`
#. ยง5: `trans D`
#: Game.Levels.Implis.L09_Trans
msgid "Intro Implis L09: Instead of ยง0 use ยง1 here. With it you can solve ยง2 step-by-step by apply intermediate step ยง3 with ยง4. The next step is performed with ยง5"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L07_Symm
msgid "ยง0 Conclusion Implis L07"
msgstr ""

#: Game.Levels.Spinoza.L02_Suffices
msgid "Prove intermediate result"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Euklid.L04_Boss_infinitely_many_primes
msgid "ยง0 Intro Euklid L04"
msgstr ""

#. ยง0: `rw`
#. ยง1: `n`
#. ยง2: `ยซ{s}ยป + ยซ{s}ยป`
#. ยง3: `ring`
#: Game.Levels.Quantus.L04_Exists
msgid "Try ยง0 to replace ยง1 by ยง2, ยง3"
msgstr ""

#. ยง0: `n โ 10`
#. ยง1: `n = 10`
#. ยง2: `โ`
#. ยง3: `ยฌ(ยท = ยท)`
#: Game.Levels.Logo.L09_Contradiction
msgid "Conclusion Logo L09: ยง0 is negation of ยง1. ยง2 has to be read as ยง3"
msgstr ""

#. ยง0: `assumption`
#: Game.Doc.Tactic
msgid "The ยง0 tactic closes the proof if one of the assumptions corresponds exactly to the proof target."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Babylon.L09_Boss
msgid "ยง0 Conclusion Babylon L09"
msgstr ""

#. ยง0: `โ โ โ`
#: Game.Levels.Cantor.L11_SequenceUncountable
msgid "Intro Cantor L11: Show that set of mapping ยง0 is uncountable"
msgstr ""

#. ยง0: `rfl`
#. ยง1: `rw`
#. ยง2: `trans`
#: Game.Doc.Definition
msgid "Useful tactics for equality are: ยง0, ยง1, ยง2"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Saturn.L04_mul_assoc
msgid "ยง0 Intro Saturn L04"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L04_99
msgid "ยง0 Intro Prado L04"
msgstr ""

#: Game.Levels.Spinoza.L04_ByContra
msgid "Use proof by contradiction"
msgstr ""

#: Game.Levels.Mono.L03_NotInjective
msgid "Intro Mono L03"
msgstr ""

#. ยง0: `1 ยซ{i}ยป ยซ{x}ยป`
#. ยง1: `Matrix.one_apply`
#: Game.Levels.Robotswana.L05_EBasisDiagSum
msgid "Apply definition ยง0 by ยง1"
msgstr ""

#: Game.Levels.Implis.L12_ByCases
msgid "Try right, assumption, left, assumption"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Prado.L10_EvenPrime
msgid "ยง0 Intro Prado L10"
msgstr ""

#. ยง0: `โ`
#: Game.Levels.Vieta.L01_FunctionNotation
msgid "Conclusion Vieta L01: explain ambiguity of ยง0"
msgstr ""

#. ยง0: `A โ Set A`
#. ยง1: `Set A`
#. ยง2: `A โ Prop`
#. ยง3: `S : Set A`
#. ยง4: `A โ Prop`
#. ยง5: `a : A`
#. ยง6: `a โ S`
#: Game.Levels.Cantor.L10_CantorPowerset
msgid "Intro Cantor L10: Show that there are no surjective mappings ยง0 by interpreting ยง1 as ยง2. Sub set ยง3 can be seen as ยง4, which casts ยง5 on statement ยง6"
msgstr ""

#. ยง0: `IsEmpty.false`
#. ยง1: `โ (m : M), False`
#. ยง2: `M`
#: Game.Levels.Robotswana.L09_EvalOnEBasis
msgid "Try ยง0, with ยง1 for empty set ยง2"
msgstr ""

#. ยง0: `g โ ยซ{f}ยป`
#. ยง1: `\\comp`
#. ยง2: `let g : โค โ โค := fun x โฆ _`
#. ยง3: `use fun (x : โค) โฆ _`
#: Game.Levels.Vieta.L04_Let
msgid "Composition ยง0 can be written with ยง1. Try ยง2 or ยง3"
msgstr ""

#. ยง0: `contradiction`
#: Game.Levels.Logo.L07_Contradiction
msgid "Conclusion Logo L07: There is ยง0 in assumptions"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L03_Assumption
msgid "ยง0 Intro Logo L03"
msgstr ""

#. ยง0: `LeftInverse g f`
#. ยง1: `g โ f = id`
#. ยง2: `โ x, g (f x) = x`
#. ยง3: `unfold`
#: Game.Doc.Definition
msgid "ยง0 means ยง1, or more exactly: ยง2, as can be seen with ยง3."
msgstr ""

#. ยง0: `Finset`
#: Game.Levels.Piazza.L11_erase
msgid "Explain ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L07_antisymm_iff
msgid "ยง0 Intro Piazza L07"
msgstr ""

#. ยง0: `y โค \\tfrac{34}{7}`
#. ยง1: `linarith`
#: Game.Levels.Luna.L07_Linarith2
msgid "Goal ยง0, Try ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Cantor.L07_idempotent
msgid "ยง0Conclusion Cantor L07"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Logo.L14_Summary
msgid "ยง0 Conclusion Logo L14"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Cantor.L03_IsFixedPt_abs
msgid "ยง0 Intro Cantor L03"
msgstr ""

#. ยง0: `ยซ{b}ยป = a`
#: Game.Levels.Piazza.L13_insert_erase
msgid "Try proof by cases, if ยง0"
msgstr ""

#. ยง0: `A โจ B`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `A โจ B`
#. ยง4: `left`
#. ยง5: `right`
#. ยง6: `A โจ B`
#. ยง7: `A`
#. ยง8: `B`
#. ยง9: `A`
#. ยง10: `B`
#. ยง11: ``` obtain h | h := h ```
#: Game.Doc.Definition
msgid "ยง0 (โorโ) is the statement that at least one of the statements ยง1, ยง2 is true.\n"
"\n"
"## ยง3 as proof goal\n"
"\n"
"You can use the tactics ยง4 or ยง5 to decide which statement you want to prove.\n"
"\n"
"## ยง6 as an assumption\n"
"\n"
"Since you do not know which of the statements ยง7 or ยง8 you can assume, you may have to show the proof goal twice: once under the assumption ยง9 and once under the assumption ยง10. To do this, use the tactic ยง11"
msgstr ""

#. ยง0: `0 < n`
#. ยง1: `n < 0`
#. ยง2: `n โ 0`
#: Game.Levels.Luna.L02_Omega
msgid "Intro Luna L02: For integers ยง0 or ยง1 means ยง2"
msgstr ""

#. ยง0: `rw`
#: Game.Levels.Implis.L10_Iff
msgid "Intro Implis L10: ยง0 is not allowed here as well"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Luna.L09_lt_trichotomy2
msgid "ยง0 Intro Luna L09"
msgstr ""

#: Game.Levels.Spinoza.L03_ByContra
msgid "Derive intermediate result that lead to the conclusion"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon.L04_sum_subset
msgid "ยง0 Intro Babylon L04"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Babylon
msgid "ยง0 Intro Babylon"
msgstr ""

#. ยง0: `P : T โ Prop`
#. ยง1: `{ a : T | P a } : Set P`
#. ยง2: ``` { n : โ | Even n } ```
#. ยง3: `a โ { a : T | P a }`
#. ยง4: `P a`
#. ยง5: `simp`
#: Game.Doc.Definition
msgid "For a predicate ยง0, ยง1 is the subset consisting of all elements that satisfy the predicate.  For example, ยง2 is the set of even natural numbers. You can simplify the statement ยง3 to ยง4 using ยง5."
msgstr ""

#. ยง0: `map_sum`
#. ยง1: `simp`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Try ยง0 via ยง1"
msgstr ""

#: Game.Levels.Logo
msgid "Logo"
msgstr ""

#: Game.Levels.Robotswana
msgid "Robotswana"
msgstr ""

#. ยง0: `n`
#. ยง1: `x โฆ x ^ n`
#. ยง2: `h_odd : Odd n`
#. ยง3: `Odd.strictMono_pow h_odd`
#. ยง4: `h_odd.strictMono_pow`
#: Game.Levels.Mono.L05_StrictMono
msgid "Fรผr ungerades ยง0 ist ยง1 strikt monoton.\n"
"\n"
"*Bemerkung*: Hat man ยง2 als Annahme, so kann man statt ยง3 auch einfach ยง4 schreiben."
msgstr ""

#. ยง0: `โ (y : ยซ{People}ยป), ยซ{isDrinking}ยป y`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Try proof by case for ยง0"
msgstr ""

#. ยง0: `n : โค`
#. ยง1: `n.toNat : โ`
#. ยง2: `n : โค`
#. ยง3: `n.toNat : โ`
#. ยง4: `n : โ`
#. ยง5: `(n : โค)`
#. ยง6: `โn`
#: Game.Doc.Definition
msgid "If ยง0 is an integer greater than or equal to 0, then ยง1 is the same number, interpreted as a natural number. (If ยง2 is a negative integer, then ยง3 is also defined, but its value has no mathematical meaning.)\n"
"\n"
"## Friends and relatives\n"
"\n"
"A natural number ยง4 can always be interpreted as an integer. To do this, you either write it explicitly as ยง5 or as ยง6."
msgstr ""

#. ยง0: `obtain`
#. ยง1: `h : A โง B`
#. ยง2: `obtain โจhโ, hโโฉ := h`
#. ยง3: `hโ : A`
#. ยง4: `hโ : B`
#. ยง5: `h : A โ B`
#. ยง6: `obtain โจhโ, hโโฉ := h`
#. ยง7: `hโ : A โ B`
#. ยง8: `hโ : B โ A`
#. ยง9: `h : Nonempty X`
#. ยง10: `obtain โจxโฉ := h`
#. ยง11: `x : X`
#. ยง12: `h : โ x : X, P x`
#. ยง13: `obtain โจx, hxโฉ := h`
#. ยง14: `x : X`
#. ยง15: `hx : P x`
#. ยง16: `h : A โจ B`
#. ยง17: `obtain h \\| h := h`
#. ยง18: `h : A`
#. ยง19: `h : B`
#. ยง20: `\\<`
#. ยง21: `\\>`
#. ยง22: `โจ_, _โฉ`
#. ยง23: $(G, 0, +)$
#: Game.Doc.Tactic
msgid "The ยง0 tactic breaks down an assumption into its individual parts.\n"
"\n"
"| before       | tactic                 | after                                   | |:------------------ |:--------------------- - |:------------------------------------------ | | ยง1        | ยง2 | ยง3 and ยง4                      | | ยง5        | ยง6 | ยง7 and ยง8              | | ยง9   | ยง10      | ยง11                                    | | ยง12 | ยง13  | ยง14 and ยง15                     | | ยง16        | ยง17   | a target with ยง18, a target with ยง19 |\n"
"\n"
"Type the brackets in the first four examples as ยง20 or ยง21. Here, ยง22 is the *anonymous constructor*. You can think of it as similar to the tuple notation in โan abelian group is a tuple ยง23 such that ...โ."
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Piazza.L08_subset_iff
msgid "ยง0 Intro Piazza L08"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L02_Function
msgid "ยง0 Intro Vieta L02"
msgstr ""

#. ยง0: `obtain`
#: Game.Levels.Logo.L14_Summary
msgid "Divide ยซ{h}ยป with ยง0"
msgstr ""

#. ยง0: `Matrix.smul_ebasis`
#. ยง1: `(A i j) โข E i j`
#. ยง2: `simp [โฆ]`
#. ยง3: `rw [โฆ]`
#: Game.Levels.Robotswana.L04_MatrixEqSum
msgid "Try ยง0 on ยง1. Mention to use ยง2 instead of ยง3"
msgstr ""

#: Game.Levels.Piazza.L07_antisymm_iff
msgid "Try ext, tauto"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Ciao
msgid "ยง0 Intro Ciao"
msgstr ""

#. ยง0: `contrapose`
#. ยง1: `A โ B`
#. ยง2: `ยฌB โ ยฌA`
#. ยง3: `revert h`
#. ยง4: `contrapose`
#: Game.Doc.Tactic
msgid "The tactic ยง0 changes a proof goal of the form ยง1 to ยง2, thereby initiating a proof by contraposition.\n"
"\n"
"## Friends and relatives\n"
"\n"
"The tactic ยง3 can be useful for writing an assumption as an implication premise before you use ยง4."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#. ยง0: `ยซ{B}ยป`
#. ยง1: `ยฌยซ{B}ยป`
#: Game.Levels.Spinoza.L03_ByContra
msgid "Finish proof by stating contradiction between ยง0 and ยง1"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `S`
#. ยง2: `A`
#. ยง3: ``` f โโ S = {f a | a โ S}
#. 
#.        = {b | โ a โ S, f a = b} ```
#. ยง4: `f`
#. ยง5: `f`
#. ยง6: `โโ`
#: Game.Doc.Definition
msgid "For a mapping ยง0 and a subset ยง1 of ยง2, ยง3 is its image under ยง4.  Note the space between ยง5 and ยง6."
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L01_NonemptyUse
msgid "ยง0 Conclusion Quantus L01"
msgstr ""

#. ยง0: `congr_fun`
#. ยง1: `h : f = g`
#. ยง2: `apply congr_fun at h`
#. ยง3: `h : โ x, f x = g x`
#. ยง4: `rw [h]`
#. ยง5: `f`
#: Game.Levels.Vieta.L09_CongrFun
msgid "Try ยง0. Given assumption ยง1 rewrite it via ยง2 to ยง3. ยง4 not applicable to more complex ยง5"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L07_Symm
msgid "ยง0 Intro Implis L07"
msgstr ""

#. ยง0: `f`
#. ยง1: `E i i`
#: Game.Levels.Robotswana.L06_EBasisEqOnDiag
msgid "Explain ยง0 with ยง1"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Quantus.L06_not_even_iff_odd
msgid "ยง0 Conclusion Quantus L06"
msgstr ""

#. ยง0: `h_nonempty`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "Use assumption ยง0"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Quantus.L10_DrinkersParadox
msgid "ยง0 Intro Quantus L10"
msgstr ""

#: Game.Levels.Robotswana.L03
msgid "Intro Robotswana L03"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Samarkand.L05_InjectiveFibre
msgid "ยง0 Conclusion Samarkand L05"
msgstr ""

#: Game.Levels.Babylon.L06_Induction_sum_insert__arithmetic_sum
msgid "Conclusion Babylon L06"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Implis.L01_Intro
msgid "ยง0 Intro Implis L01"
msgstr ""

#. ยง0: `โx, P x`
#. ยง1: `use n`
#. ยง2: `P x`
#: Game.Doc.Tactic
msgid "If the proof target is of the form ยง0, you can use ยง1 to specify a concrete element for which you want to prove ยง2."
msgstr ""

#: Game.Levels.Prado.L06_Prime_Specialize__prime_def
msgid "Explain prime number"
msgstr ""

#. ยง0: `by_cases h : Even i`
#: Game.Levels.Quantus.L06_not_even_iff_odd
msgid "Try proof by cases with ยง0"
msgstr ""

#. ยง0: ``` def Even (n : โ) : Prop := โ r, n = r + r ```
#. ยง1: ``` def Odd (n : โ) : Prop := โ r, n = 2 * r + 1 ```
#: Game.Levels.Quantus.L04_Exists
msgid "Intro Quantus L04: Show defintion ยง0\n"
"\n"
"and\n"
"\n"
"ยง1"
msgstr ""

#. ยง0: `congr_fun`
#. ยง1: `ยซ{hs}ยป`
#. ยง2: `โ x, (ยซ{f}ยป โ ยซ{g}ยป) x = (succ โ ยซ{f}ยป)`
#: Game.Levels.Vieta.L10_Surjective
msgid "Try ยง0 to rewrite ยง1 to ยง2"
msgstr ""

#. ยง0: `rw`
#. ยง1: `rfl`
#: Game.Levels.Implis.L13_Rw
msgid "Conclusion Implis L13: Explain that ยง0 always tries to apply ยง1"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Logo.L08_Contradiction
msgid "ยง0 Intro Logo L08"
msgstr ""

#. ยง0: `funext`
#. ยง1: `funext x`
#. ยง2: `x`
#. ยง3: `f = g`
#. ยง4: `f x = g x`
#: Game.Levels.Vieta.L05_Funext
msgid "Try ยง0. Explain ยง1 as taking arbitrary ยง2 and changing goal from ยง3 to ยง4"
msgstr ""

#. ยง0: `CONC`
#: Game.Levels.Implis.L09_Trans
msgid "ยง0 Conclusion Implis L09"
msgstr ""

#. ยง0: `f`
#. ยง1: `E i j`
#. ยง2: `iโj`
#. ยง3: `trans โ i, โ j, if i = j then (A i j) * f (E i j) else 0`
#: Game.Levels.Robotswana.L08_EvalOnEBasis
msgid "Use disappearing ยง0 in ยง1 with ยง2. Try ยง3"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta.L10_Surjective
msgid "ยง0 Intro Vieta L10"
msgstr ""

#. ยง0: `fun (x : โค) โฆ x ^ 2`
#. ยง1: `f : โค โ โค := โฆ`
#. ยง2: `rfl`
#. ยง3: `simp [ยซ{f}ยป]`
#: Game.Levels.Vieta.L02_Function
msgid "Explain anonymous function ยง0 and naming via ยง1. Try ยง2 | ยง3"
msgstr ""

#. ยง0: `Even ยซ{n}ยป`
#. ยง1: `r`
#. ยง2: `r + r = ยซ{n}ยป. Explain why `
#. ยง3: ` does not work via `
#. ยง4: `. Try `
#: Game.Levels.Quantus.L04_Exists
msgid "Explain definition of ยง0 by ยง1 using ยง2decideยง3nยง4unfold Even at *`"
msgstr ""

#. ยง0: `INTRO`
#: Game.Levels.Vieta
msgid "ยง0 Intro Vieta"
msgstr ""
